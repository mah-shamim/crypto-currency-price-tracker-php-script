/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 1427:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

!function (t, e) {
   true ? module.exports = e(__webpack_require__(9471)) : 0;
}("undefined" != typeof self ? self : this, function (t) {
  return function (t) {
    function e(n) {
      if (r[n]) return r[n].exports;
      var o = r[n] = {
        i: n,
        l: !1,
        exports: {}
      };
      return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
    }
    var r = {};
    return e.m = t, e.c = r, e.d = function (t, r, n) {
      e.o(t, r) || Object.defineProperty(t, r, {
        configurable: !1,
        enumerable: !0,
        get: n
      });
    }, e.n = function (t) {
      var r = t && t.__esModule ? function () {
        return t.default;
      } : function () {
        return t;
      };
      return e.d(r, "a", r), r;
    }, e.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, e.p = "", e(e.s = 0);
  }([function (t, e, r) {
    "use strict";

    function n() {
      return n = Object.assign ? Object.assign.bind() : function (t) {
        for (var e = 1; e < arguments.length; e++) {
          var r = arguments[e];
          for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
        }
        return t;
      }, n.apply(this, arguments);
    }
    function o(t) {
      return a(t) || i(t) || u(t) || c();
    }
    function c() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function u(t, e) {
      if (t) {
        if ("string" == typeof t) return f(t, e);
        var r = Object.prototype.toString.call(t).slice(8, -1);
        return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? f(t, e) : void 0;
      }
    }
    function i(t) {
      if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t);
    }
    function a(t) {
      if (Array.isArray(t)) return f(t);
    }
    function f(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
      return n;
    }
    function s(t) {
      "@babel/helpers - typeof";

      return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
        return typeof t;
      } : function (t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      })(t);
    }
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), r.d(e, "HighchartsReact", function () {
      return d;
    });
    var p = r(1),
      l = r.n(p),
      y = "undefined" != typeof window ? p.useLayoutEffect : p.useEffect,
      d = Object(p.memo)(Object(p.forwardRef)(function (t, e) {
        var r = Object(p.useRef)(),
          c = Object(p.useRef)(),
          u = Object(p.useRef)(t.constructorType),
          i = Object(p.useRef)(t.highcharts);
        return y(function () {
          function e() {
            var e = t.highcharts || "object" === ("undefined" == typeof window ? "undefined" : s(window)) && window.Highcharts,
              n = t.constructorType || "chart";
            e ? e[n] ? t.options ? c.current = e[n](r.current, t.options, t.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.');
          }
          if (c.current) {
            if (!1 !== t.allowChartUpdate) if (t.constructorType !== u.current || t.highcharts !== i.current) u.current = t.constructorType, i.current = t.highcharts, e();else if (!t.immutable && c.current) {
              var n;
              (n = c.current).update.apply(n, [t.options].concat(o(t.updateArgs || [!0, !0])));
            } else e();
          } else e();
        }, [t.options, t.allowChartUpdate, t.updateArgs, t.containerProps, t.highcharts, t.constructorType]), y(function () {
          return function () {
            c.current && (c.current.destroy(), c.current = null);
          };
        }, []), Object(p.useImperativeHandle)(e, function () {
          return {
            get chart() {
              return c.current;
            },
            container: r
          };
        }, []), l.a.createElement("div", n({}, t.containerProps, {
          ref: r
        }));
      }));
    e.default = d;
  }, function (e, r) {
    e.exports = t;
  }]);
});

/***/ }),

/***/ 7684:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v10.3.3 (2023-01-20)

 (c) 2009-2021 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (aa, K) {
   true && module.exports ? (K["default"] = K, module.exports = aa.document ? K(aa) : K) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return K(aa);
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})("undefined" !== typeof window ? window : this, function (aa) {
  function K(a, A, g, F) {
    a.hasOwnProperty(A) || (a[A] = F.apply(null, g), "function" === typeof CustomEvent && aa.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
      detail: {
        path: A,
        module: a[A]
      }
    })));
  }
  var g = {};
  K(g, "Core/Globals.js", [], function () {
    var a;
    (function (a) {
      a.SVG_NS = "http://www.w3.org/2000/svg";
      a.product = "Highcharts";
      a.version = "10.3.3";
      a.win = "undefined" !== typeof aa ? aa : {};
      a.doc = a.win.document;
      a.svg = a.doc && a.doc.createElementNS && !!a.doc.createElementNS(a.SVG_NS, "svg").createSVGRect;
      a.userAgent = a.win.navigator && a.win.navigator.userAgent || "";
      a.isChrome = -1 !== a.userAgent.indexOf("Chrome");
      a.isFirefox = -1 !== a.userAgent.indexOf("Firefox");
      a.isMS = /(edge|msie|trident)/i.test(a.userAgent) && !a.win.opera;
      a.isSafari = !a.isChrome && -1 !== a.userAgent.indexOf("Safari");
      a.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a.userAgent);
      a.isWebKit = -1 !== a.userAgent.indexOf("AppleWebKit");
      a.deg2rad = 2 * Math.PI / 360;
      a.hasBidiBug = a.isFirefox && 4 > parseInt(a.userAgent.split("Firefox/")[1], 10);
      a.hasTouch = !!a.win.TouchEvent;
      a.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
      a.noop = function () {};
      a.supportsPassiveEvents = function () {
        var g = !1;
        if (!a.isMS) {
          var A = Object.defineProperty({}, "passive", {
            get: function () {
              g = !0;
            }
          });
          a.win.addEventListener && a.win.removeEventListener && (a.win.addEventListener("testPassive", a.noop, A), a.win.removeEventListener("testPassive", a.noop, A));
        }
        return g;
      }();
      a.charts = [];
      a.dateFormats = {};
      a.seriesTypes = {};
      a.symbolSizes = {};
      a.chartCount = 0;
    })(a || (a = {}));
    "";
    return a;
  });
  K(g, "Core/Utilities.js", [g["Core/Globals.js"]], function (a) {
    function g(b, c, n, J) {
      var z = c ? "Highcharts error" : "Highcharts warning";
      32 === b && (b = "" + z + ": Deprecated member");
      var q = l(b),
        u = q ? "" + z + " #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString();
      if ("undefined" !== typeof J) {
        var N = "";
        q && (u += "?");
        E(J, function (b, z) {
          N += "\n - ".concat(z, ": ").concat(b);
          q && (u += encodeURI(z) + "=" + encodeURI(b));
        });
        u += N;
      }
      y(a, "displayError", {
        chart: n,
        code: b,
        message: u,
        params: J
      }, function () {
        if (c) throw Error(u);
        f.console && -1 === g.messages.indexOf(u) && console.warn(u);
      });
      g.messages.push(u);
    }
    function x(b, f) {
      var z = {};
      E(b, function (c, q) {
        if (H(b[q], !0) && !b.nodeType && f[q]) c = x(b[q], f[q]), Object.keys(c).length && (z[q] = c);else if (H(b[q]) || b[q] !== f[q] || q in b && !(q in f)) z[q] = b[q];
      });
      return z;
    }
    function F(b, f) {
      return parseInt(b, f || 10);
    }
    function C(b) {
      return "string" === typeof b;
    }
    function B(b) {
      b = Object.prototype.toString.call(b);
      return "[object Array]" === b || "[object Array Iterator]" === b;
    }
    function H(b, f) {
      return !!b && "object" === typeof b && (!f || !B(b));
    }
    function t(b) {
      return H(b) && "number" === typeof b.nodeType;
    }
    function r(b) {
      var f = b && b.constructor;
      return !(!H(b, !0) || t(b) || !f || !f.name || "Object" === f.name);
    }
    function l(b) {
      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
    }
    function e(b) {
      return "undefined" !== typeof b && null !== b;
    }
    function d(b, f, c) {
      var z = C(f) && !e(c),
        q,
        n = function (f, c) {
          e(f) ? b.setAttribute(c, f) : z ? (q = b.getAttribute(c)) || "class" !== c || (q = b.getAttribute(c + "Name")) : b.removeAttribute(c);
        };
      C(f) ? n(c, f) : E(f, n);
      return q;
    }
    function h(b, f) {
      var c;
      b || (b = {});
      for (c in f) b[c] = f[c];
      return b;
    }
    function m() {
      for (var b = arguments, f = b.length, c = 0; c < f; c++) {
        var J = b[c];
        if ("undefined" !== typeof J && null !== J) return J;
      }
    }
    function k(b, f) {
      a.isMS && !a.svg && f && e(f.opacity) && (f.filter = "alpha(opacity=".concat(100 * f.opacity, ")"));
      h(b.style, f);
    }
    function p(b) {
      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
    }
    function D(b, f) {
      return 1E14 < b ? b : parseFloat(b.toPrecision(f || 14));
    }
    function I(b, c, n) {
      var z = a.getStyle || I;
      if ("width" === c) return c = Math.min(b.offsetWidth, b.scrollWidth), n = b.getBoundingClientRect && b.getBoundingClientRect().width, n < c && n >= c - 1 && (c = Math.floor(n)), Math.max(0, c - (z(b, "padding-left", !0) || 0) - (z(b, "padding-right", !0) || 0));
      if ("height" === c) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - (z(b, "padding-top", !0) || 0) - (z(b, "padding-bottom", !0) || 0));
      f.getComputedStyle || g(27, !0);
      if (b = f.getComputedStyle(b, void 0)) {
        var q = b.getPropertyValue(c);
        m(n, "opacity" !== c) && (q = F(q));
      }
      return q;
    }
    function E(b, f, c) {
      for (var z in b) Object.hasOwnProperty.call(b, z) && f.call(c || b[z], b[z], z, b);
    }
    function L(b, f, c) {
      function z(f, c) {
        var v = b.removeEventListener || a.removeEventListenerPolyfill;
        v && v.call(b, f, c, !1);
      }
      function q(c) {
        var v;
        if (b.nodeName) {
          if (f) {
            var q = {};
            q[f] = !0;
          } else q = c;
          E(q, function (b, f) {
            if (c[f]) for (v = c[f].length; v--;) z(f, c[f][v].fn);
          });
        }
      }
      var n = "function" === typeof b && b.prototype || b;
      if (Object.hasOwnProperty.call(n, "hcEvents")) {
        var u = n.hcEvents;
        f ? (n = u[f] || [], c ? (u[f] = n.filter(function (b) {
          return c !== b.fn;
        }), z(f, c)) : (q(u), u[f] = [])) : (q(u), delete n.hcEvents);
      }
    }
    function y(b, f, c, J) {
      c = c || {};
      if (w.createEvent && (b.dispatchEvent || b.fireEvent && b !== a)) {
        var z = w.createEvent("Events");
        z.initEvent(f, !0, !0);
        c = h(z, c);
        b.dispatchEvent ? b.dispatchEvent(c) : b.fireEvent(f, c);
      } else if (b.hcEvents) {
        c.target || h(c, {
          preventDefault: function () {
            c.defaultPrevented = !0;
          },
          target: b,
          type: f
        });
        z = [];
        for (var q = b, n = !1; q.hcEvents;) Object.hasOwnProperty.call(q, "hcEvents") && q.hcEvents[f] && (z.length && (n = !0), z.unshift.apply(z, q.hcEvents[f])), q = Object.getPrototypeOf(q);
        n && z.sort(function (b, f) {
          return b.order - f.order;
        });
        z.forEach(function (f) {
          !1 === f.fn.call(b, c) && c.preventDefault();
        });
      }
      J && !c.defaultPrevented && J.call(b, c);
    }
    var c = a.charts,
      w = a.doc,
      f = a.win;
    (g || (g = {})).messages = [];
    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };
    var n = Array.prototype.find ? function (b, f) {
      return b.find(f);
    } : function (b, f) {
      var c,
        q = b.length;
      for (c = 0; c < q; c++) if (f(b[c], c)) return b[c];
    };
    E({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, f) {
      a[f] = function (c) {
        var q;
        g(32, !1, void 0, (q = {}, q["Highcharts.".concat(f)] = "use Array.".concat(b), q));
        return Array.prototype[b].apply(c, [].slice.call(arguments, 1));
      };
    });
    var b,
      u = function () {
        var f = Math.random().toString(36).substring(2, 9) + "-",
          c = 0;
        return function () {
          return "highcharts-" + (b ? "" : f) + c++;
        };
      }();
    f.jQuery && (f.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new a[C(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : c[d(this[0], "data-highcharts-chart")];
    });
    n = {
      addEvent: function (b, f, c, J) {
        void 0 === J && (J = {});
        var q = "function" === typeof b && b.prototype || b;
        Object.hasOwnProperty.call(q, "hcEvents") || (q.hcEvents = {});
        q = q.hcEvents;
        a.Point && b instanceof a.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
        var z = b.addEventListener || a.addEventListenerPolyfill;
        z && z.call(b, f, c, a.supportsPassiveEvents ? {
          passive: void 0 === J.passive ? -1 !== f.indexOf("touch") : J.passive,
          capture: !1
        } : !1);
        q[f] || (q[f] = []);
        q[f].push({
          fn: c,
          order: "number" === typeof J.order ? J.order : Infinity
        });
        q[f].sort(function (b, f) {
          return b.order - f.order;
        });
        return function () {
          L(b, f, c);
        };
      },
      arrayMax: function (b) {
        for (var f = b.length, c = b[0]; f--;) b[f] > c && (c = b[f]);
        return c;
      },
      arrayMin: function (b) {
        for (var f = b.length, c = b[0]; f--;) b[f] < c && (c = b[f]);
        return c;
      },
      attr: d,
      clamp: function (b, f, c) {
        return b > f ? b < c ? b : c : f;
      },
      cleanRecursively: x,
      clearTimeout: function (b) {
        e(b) && clearTimeout(b);
      },
      correctFloat: D,
      createElement: function (b, f, c, J, n) {
        b = w.createElement(b);
        f && h(b, f);
        n && k(b, {
          padding: "0",
          border: "none",
          margin: "0"
        });
        c && k(b, c);
        J && J.appendChild(b);
        return b;
      },
      css: k,
      defined: e,
      destroyObjectProperties: function (b, f) {
        E(b, function (c, q) {
          c && c !== f && c.destroy && c.destroy();
          delete b[q];
        });
      },
      discardElement: function (b) {
        b && b.parentElement && b.parentElement.removeChild(b);
      },
      erase: function (b, f) {
        for (var c = b.length; c--;) if (b[c] === f) {
          b.splice(c, 1);
          break;
        }
      },
      error: g,
      extend: h,
      extendClass: function (b, f) {
        var c = function () {};
        c.prototype = new b();
        h(c.prototype, f);
        return c;
      },
      find: n,
      fireEvent: y,
      getMagnitude: p,
      getNestedProperty: function (b, c) {
        for (b = b.split("."); b.length && e(c);) {
          var q = b.shift();
          if ("undefined" === typeof q || "__proto__" === q) return;
          c = c[q];
          if (!e(c) || "function" === typeof c || "number" === typeof c.nodeType || c === f) return;
        }
        return c;
      },
      getStyle: I,
      inArray: function (b, c, f) {
        g(32, !1, void 0, {
          "Highcharts.inArray": "use Array.indexOf"
        });
        return c.indexOf(b, f);
      },
      isArray: B,
      isClass: r,
      isDOMElement: t,
      isFunction: function (b) {
        return "function" === typeof b;
      },
      isNumber: l,
      isObject: H,
      isString: C,
      keys: function (b) {
        g(32, !1, void 0, {
          "Highcharts.keys": "use Object.keys"
        });
        return Object.keys(b);
      },
      merge: function () {
        var b,
          c = arguments,
          f = {},
          J = function (b, c) {
            "object" !== typeof b && (b = {});
            E(c, function (f, v) {
              "__proto__" !== v && "constructor" !== v && (!H(f, !0) || r(f) || t(f) ? b[v] = c[v] : b[v] = J(b[v] || {}, f));
            });
            return b;
          };
        !0 === c[0] && (f = c[1], c = Array.prototype.slice.call(c, 2));
        var n = c.length;
        for (b = 0; b < n; b++) f = J(f, c[b]);
        return f;
      },
      normalizeTickInterval: function (b, c, f, J, n) {
        var q = b;
        f = m(f, p(b));
        var u = b / f;
        c || (c = n ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === J && (1 === f ? c = c.filter(function (b) {
          return 0 === b % 1;
        }) : .1 >= f && (c = [1 / f])));
        for (J = 0; J < c.length && !(q = c[J], n && q * f >= b || !n && u <= (c[J] + (c[J + 1] || c[J])) / 2); J++);
        return q = D(q * f, -Math.round(Math.log(.001) / Math.LN10));
      },
      objectEach: E,
      offset: function (b) {
        var c = w.documentElement;
        b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
          top: 0,
          left: 0,
          width: 0,
          height: 0
        };
        return {
          top: b.top + (f.pageYOffset || c.scrollTop) - (c.clientTop || 0),
          left: b.left + (f.pageXOffset || c.scrollLeft) - (c.clientLeft || 0),
          width: b.width,
          height: b.height
        };
      },
      pad: function (b, c, f) {
        return Array((c || 2) + 1 - String(b).replace("-", "").length).join(f || "0") + b;
      },
      pick: m,
      pInt: F,
      relativeLength: function (b, c, f) {
        return /%$/.test(b) ? c * parseFloat(b) / 100 + (f || 0) : parseFloat(b);
      },
      removeEvent: L,
      splat: function (b) {
        return B(b) ? b : [b];
      },
      stableSort: function (b, c) {
        var f = b.length,
          J,
          n;
        for (n = 0; n < f; n++) b[n].safeI = n;
        b.sort(function (b, f) {
          J = c(b, f);
          return 0 === J ? b.safeI - f.safeI : J;
        });
        for (n = 0; n < f; n++) delete b[n].safeI;
      },
      syncTimeout: function (b, c, f) {
        if (0 < c) return setTimeout(b, c, f);
        b.call(0, f);
        return -1;
      },
      timeUnits: {
        millisecond: 1,
        second: 1E3,
        minute: 6E4,
        hour: 36E5,
        day: 864E5,
        week: 6048E5,
        month: 24192E5,
        year: 314496E5
      },
      uniqueKey: u,
      useSerialIds: function (c) {
        return b = m(c, b);
      },
      wrap: function (b, c, f) {
        var n = b[c];
        b[c] = function () {
          var b = arguments,
            c = this;
          return f.apply(this, [function () {
            return n.apply(c, arguments.length ? arguments : b);
          }].concat([].slice.call(arguments)));
        };
      }
    };
    "";
    return n;
  });
  K(g, "Core/Chart/ChartDefaults.js", [], function () {
    return {
      alignThresholds: !1,
      panning: {
        enabled: !1,
        type: "x"
      },
      styledMode: !1,
      borderRadius: 0,
      colorCount: 10,
      allowMutatingData: !0,
      defaultSeriesType: "line",
      ignoreHiddenSeries: !0,
      spacing: [10, 10, 15, 10],
      resetZoomButton: {
        theme: {
          zIndex: 6
        },
        position: {
          align: "right",
          x: -10,
          y: 10
        }
      },
      zoomBySingleTouch: !1,
      zooming: {
        singleTouch: !1,
        resetButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        }
      },
      width: null,
      height: null,
      borderColor: "#335cad",
      backgroundColor: "#ffffff",
      plotBorderColor: "#cccccc"
    };
  });
  K(g, "Core/Color/Color.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = g.isNumber,
      F = g.merge,
      C = g.pInt;
    g = function () {
      function g(A) {
        this.rgba = [NaN, NaN, NaN, NaN];
        this.input = A;
        var t = a.Color;
        if (t && t !== g) return new t(A);
        if (!(this instanceof g)) return new g(A);
        this.init(A);
      }
      g.parse = function (a) {
        return a ? new g(a) : g.None;
      };
      g.prototype.init = function (a) {
        var t;
        if ("object" === typeof a && "undefined" !== typeof a.stops) this.stops = a.stops.map(function (d) {
          return new g(d[1]);
        });else if ("string" === typeof a) {
          this.input = a = g.names[a.toLowerCase()] || a;
          if ("#" === a.charAt(0)) {
            var r = a.length;
            var l = parseInt(a.substr(1), 16);
            7 === r ? t = [(l & 16711680) >> 16, (l & 65280) >> 8, l & 255, 1] : 4 === r && (t = [(l & 3840) >> 4 | (l & 3840) >> 8, (l & 240) >> 4 | l & 240, (l & 15) << 4 | l & 15, 1]);
          }
          if (!t) for (l = g.parsers.length; l-- && !t;) {
            var e = g.parsers[l];
            (r = e.regex.exec(a)) && (t = e.parse(r));
          }
        }
        t && (this.rgba = t);
      };
      g.prototype.get = function (a) {
        var t = this.input,
          r = this.rgba;
        if ("object" === typeof t && "undefined" !== typeof this.stops) {
          var l = F(t);
          l.stops = [].slice.call(l.stops);
          this.stops.forEach(function (e, d) {
            l.stops[d] = [l.stops[d][0], e.get(a)];
          });
          return l;
        }
        return r && A(r[0]) ? "rgb" === a || !a && 1 === r[3] ? "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")" : "a" === a ? "".concat(r[3]) : "rgba(" + r.join(",") + ")" : t;
      };
      g.prototype.brighten = function (a) {
        var t = this.rgba;
        if (this.stops) this.stops.forEach(function (l) {
          l.brighten(a);
        });else if (A(a) && 0 !== a) for (var r = 0; 3 > r; r++) t[r] += C(255 * a), 0 > t[r] && (t[r] = 0), 255 < t[r] && (t[r] = 255);
        return this;
      };
      g.prototype.setOpacity = function (a) {
        this.rgba[3] = a;
        return this;
      };
      g.prototype.tweenTo = function (a, t) {
        var r = this.rgba,
          l = a.rgba;
        if (!A(r[0]) || !A(l[0])) return a.input || "none";
        a = 1 !== l[3] || 1 !== r[3];
        return (a ? "rgba(" : "rgb(") + Math.round(l[0] + (r[0] - l[0]) * (1 - t)) + "," + Math.round(l[1] + (r[1] - l[1]) * (1 - t)) + "," + Math.round(l[2] + (r[2] - l[2]) * (1 - t)) + (a ? "," + (l[3] + (r[3] - l[3]) * (1 - t)) : "") + ")";
      };
      g.names = {
        white: "#ffffff",
        black: "#000000"
      };
      g.parsers = [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function (a) {
          return [C(a[1]), C(a[2]), C(a[3]), parseFloat(a[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function (a) {
          return [C(a[1]), C(a[2]), C(a[3]), 1];
        }
      }];
      g.None = new g("");
      return g;
    }();
    "";
    return g;
  });
  K(g, "Core/Color/Palettes.js", [], function () {
    return {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ")
    };
  });
  K(g, "Core/Time.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = a.win,
      F = g.defined,
      C = g.error,
      B = g.extend,
      H = g.isObject,
      t = g.merge,
      r = g.objectEach,
      l = g.pad,
      e = g.pick,
      d = g.splat,
      h = g.timeUnits,
      m = a.isSafari && A.Intl && A.Intl.DateTimeFormat.prototype.formatRange,
      k = a.isSafari && A.Intl && !A.Intl.DateTimeFormat.prototype.formatRange;
    g = function () {
      function p(d) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = A.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(d);
      }
      p.prototype.get = function (d, e) {
        if (this.variableTimezone || this.timezoneOffset) {
          var h = e.getTime(),
            k = h - this.getTimezoneOffset(e);
          e.setTime(k);
          d = e["getUTC" + d]();
          e.setTime(h);
          return d;
        }
        return this.useUTC ? e["getUTC" + d]() : e["get" + d]();
      };
      p.prototype.set = function (d, e, h) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === d || "Seconds" === d || "Minutes" === d && 0 === this.getTimezoneOffset(e) % 36E5) return e["setUTC" + d](h);
          var k = this.getTimezoneOffset(e);
          k = e.getTime() - k;
          e.setTime(k);
          e["setUTC" + d](h);
          d = this.getTimezoneOffset(e);
          k = e.getTime() + d;
          return e.setTime(k);
        }
        return this.useUTC || m && "FullYear" === d ? e["setUTC" + d](h) : e["set" + d](h);
      };
      p.prototype.update = function (d) {
        void 0 === d && (d = {});
        var h = e(d.useUTC, !0);
        this.options = d = t(!0, this.options, d);
        this.Date = d.Date || A.Date || Date;
        this.timezoneOffset = (this.useUTC = h) && d.timezoneOffset || void 0;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = h && !(!d.getTimezoneOffset && !d.timezone);
      };
      p.prototype.makeTime = function (d, h, m, p, y, c) {
        if (this.useUTC) {
          var w = this.Date.UTC.apply(0, arguments);
          var f = this.getTimezoneOffset(w);
          w += f;
          var n = this.getTimezoneOffset(w);
          f !== n ? w += n - f : f - 36E5 !== this.getTimezoneOffset(w - 36E5) || k || (w -= 36E5);
        } else w = new this.Date(d, h, e(m, 1), e(p, 0), e(y, 0), e(c, 0)).getTime();
        return w;
      };
      p.prototype.timezoneOffsetFunction = function () {
        var d = this,
          e = this.options,
          h = e.getTimezoneOffset,
          k = e.moment || A.moment;
        if (!this.useUTC) return function (d) {
          return 6E4 * new Date(d.toString()).getTimezoneOffset();
        };
        if (e.timezone) {
          if (k) return function (d) {
            return 6E4 * -k.tz(d, e.timezone).utcOffset();
          };
          C(25);
        }
        return this.useUTC && h ? function (d) {
          return 6E4 * h(d.valueOf());
        } : function () {
          return 6E4 * (d.timezoneOffset || 0);
        };
      };
      p.prototype.dateFormat = function (d, h, k) {
        if (!F(h) || isNaN(h)) return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
        d = e(d, "%Y-%m-%d %H:%M:%S");
        var m = this,
          p = new this.Date(h),
          c = this.get("Hours", p),
          w = this.get("Day", p),
          f = this.get("Date", p),
          n = this.get("Month", p),
          b = this.get("FullYear", p),
          u = a.defaultOptions.lang,
          z = u && u.weekdays,
          q = u && u.shortWeekdays;
        p = B({
          a: q ? q[w] : z[w].substr(0, 3),
          A: z[w],
          d: l(f),
          e: l(f, 2, " "),
          w: w,
          b: u.shortMonths[n],
          B: u.months[n],
          m: l(n + 1),
          o: n + 1,
          y: b.toString().substr(2, 2),
          Y: b,
          H: l(c),
          k: c,
          I: l(c % 12 || 12),
          l: c % 12 || 12,
          M: l(this.get("Minutes", p)),
          p: 12 > c ? "AM" : "PM",
          P: 12 > c ? "am" : "pm",
          S: l(p.getSeconds()),
          L: l(Math.floor(h % 1E3), 3)
        }, a.dateFormats);
        r(p, function (b, c) {
          for (; -1 !== d.indexOf("%" + c);) d = d.replace("%" + c, "function" === typeof b ? b.call(m, h) : b);
        });
        return k ? d.substr(0, 1).toUpperCase() + d.substr(1) : d;
      };
      p.prototype.resolveDTLFormat = function (e) {
        return H(e, !0) ? e : (e = d(e), {
          main: e[0],
          from: e[1],
          to: e[2]
        });
      };
      p.prototype.getTimeTicks = function (d, k, p, m) {
        var y = this,
          c = [],
          w = {},
          f = new y.Date(k),
          n = d.unitRange,
          b = d.count || 1,
          u;
        m = e(m, 1);
        if (F(k)) {
          y.set("Milliseconds", f, n >= h.second ? 0 : b * Math.floor(y.get("Milliseconds", f) / b));
          n >= h.second && y.set("Seconds", f, n >= h.minute ? 0 : b * Math.floor(y.get("Seconds", f) / b));
          n >= h.minute && y.set("Minutes", f, n >= h.hour ? 0 : b * Math.floor(y.get("Minutes", f) / b));
          n >= h.hour && y.set("Hours", f, n >= h.day ? 0 : b * Math.floor(y.get("Hours", f) / b));
          n >= h.day && y.set("Date", f, n >= h.month ? 1 : Math.max(1, b * Math.floor(y.get("Date", f) / b)));
          if (n >= h.month) {
            y.set("Month", f, n >= h.year ? 0 : b * Math.floor(y.get("Month", f) / b));
            var z = y.get("FullYear", f);
          }
          n >= h.year && y.set("FullYear", f, z - z % b);
          n === h.week && (z = y.get("Day", f), y.set("Date", f, y.get("Date", f) - z + m + (z < m ? -7 : 0)));
          z = y.get("FullYear", f);
          m = y.get("Month", f);
          var q = y.get("Date", f),
            N = y.get("Hours", f);
          k = f.getTime();
          !y.variableTimezone && y.useUTC || !F(p) || (u = p - k > 4 * h.month || y.getTimezoneOffset(k) !== y.getTimezoneOffset(p));
          k = f.getTime();
          for (f = 1; k < p;) c.push(k), k = n === h.year ? y.makeTime(z + f * b, 0) : n === h.month ? y.makeTime(z, m + f * b) : !u || n !== h.day && n !== h.week ? u && n === h.hour && 1 < b ? y.makeTime(z, m, q, N + f * b) : k + n * b : y.makeTime(z, m, q + f * b * (n === h.day ? 1 : 7)), f++;
          c.push(k);
          n <= h.hour && 1E4 > c.length && c.forEach(function (b) {
            0 === b % 18E5 && "000000000" === y.dateFormat("%H%M%S%L", b) && (w[b] = "day");
          });
        }
        c.info = B(d, {
          higherRanks: w,
          totalRange: n * b
        });
        return c;
      };
      p.prototype.getDateFormat = function (d, e, k, p) {
        var m = this.dateFormat("%m-%d %H:%M:%S.%L", e),
          c = {
            millisecond: 15,
            second: 12,
            minute: 9,
            hour: 6,
            day: 3
          },
          w = "millisecond";
        for (f in h) {
          if (d === h.week && +this.dateFormat("%w", e) === k && "00:00:00.000" === m.substr(6)) {
            var f = "week";
            break;
          }
          if (h[f] > d) {
            f = w;
            break;
          }
          if (c[f] && m.substr(c[f]) !== "01-01 00:00:00.000".substr(c[f])) break;
          "week" !== f && (w = f);
        }
        return this.resolveDTLFormat(p[f]).main;
      };
      return p;
    }();
    "";
    return g;
  });
  K(g, "Core/Defaults.js", [g["Core/Chart/ChartDefaults.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Color/Palettes.js"], g["Core/Time.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B) {
    g = g.parse;
    var A = B.merge,
      t = {
        colors: F.colors,
        symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
        lang: {
          loading: "Loading...",
          months: "January February March April May June July August September October November December".split(" "),
          shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
          decimalPoint: ".",
          numericSymbols: "kMGTPE".split(""),
          resetZoom: "Reset zoom",
          resetZoomTitle: "Reset zoom level 1:1",
          thousandsSep: " "
        },
        global: {},
        time: {
          Date: void 0,
          getTimezoneOffset: void 0,
          timezone: void 0,
          timezoneOffset: 0,
          useUTC: !0
        },
        chart: a,
        title: {
          text: "Chart title",
          align: "center",
          margin: 15,
          widthAdjust: -44
        },
        subtitle: {
          text: "",
          align: "center",
          widthAdjust: -44
        },
        caption: {
          margin: 15,
          text: "",
          align: "left",
          verticalAlign: "bottom"
        },
        plotOptions: {},
        labels: {
          style: {
            position: "absolute",
            color: "#333333"
          }
        },
        legend: {
          enabled: !0,
          align: "center",
          alignColumns: !0,
          className: "highcharts-no-tooltip",
          layout: "horizontal",
          labelFormatter: function () {
            return this.name;
          },
          borderColor: "#999999",
          borderRadius: 0,
          navigation: {
            activeColor: "#003399",
            inactiveColor: "#cccccc"
          },
          itemStyle: {
            color: "#333333",
            cursor: "pointer",
            fontSize: "12px",
            fontWeight: "bold",
            textOverflow: "ellipsis"
          },
          itemHoverStyle: {
            color: "#000000"
          },
          itemHiddenStyle: {
            color: "#cccccc"
          },
          shadow: !1,
          itemCheckboxStyle: {
            position: "absolute",
            width: "13px",
            height: "13px"
          },
          squareSymbol: !0,
          symbolPadding: 5,
          verticalAlign: "bottom",
          x: 0,
          y: 0,
          title: {
            style: {
              fontWeight: "bold"
            }
          }
        },
        loading: {
          labelStyle: {
            fontWeight: "bold",
            position: "relative",
            top: "45%"
          },
          style: {
            position: "absolute",
            backgroundColor: "#ffffff",
            opacity: .5,
            textAlign: "center"
          }
        },
        tooltip: {
          enabled: !0,
          animation: x.svg,
          borderRadius: 3,
          dateTimeLabelFormats: {
            millisecond: "%A, %b %e, %H:%M:%S.%L",
            second: "%A, %b %e, %H:%M:%S",
            minute: "%A, %b %e, %H:%M",
            hour: "%A, %b %e, %H:%M",
            day: "%A, %b %e, %Y",
            week: "Week from %A, %b %e, %Y",
            month: "%B %Y",
            year: "%Y"
          },
          footerFormat: "",
          headerShape: "callout",
          hideDelay: 500,
          padding: 8,
          shape: "callout",
          shared: !1,
          snap: x.isTouchDevice ? 25 : 10,
          headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
          pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
          backgroundColor: g("#f7f7f7").setOpacity(.85).get(),
          borderWidth: 1,
          shadow: !0,
          stickOnContact: !1,
          style: {
            color: "#333333",
            cursor: "default",
            fontSize: "12px",
            whiteSpace: "nowrap"
          },
          useHTML: !1
        },
        credits: {
          enabled: !0,
          href: "https://www.highcharts.com?credits",
          position: {
            align: "right",
            x: -10,
            verticalAlign: "bottom",
            y: -5
          },
          style: {
            cursor: "pointer",
            color: "#999999",
            fontSize: "9px"
          },
          text: "Highcharts.com"
        }
      };
    t.chart.styledMode = !1;
    "";
    var r = new C(A(t.global, t.time));
    a = {
      defaultOptions: t,
      defaultTime: r,
      getOptions: function () {
        return t;
      },
      setOptions: function (l) {
        A(!0, t, l);
        if (l.time || l.global) x.time ? x.time.update(A(t.global, t.time, l.global, l.time)) : x.time = r;
        return t;
      }
    };
    "";
    return a;
  });
  K(g, "Core/Animation/Fx.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = a.parse,
      C = g.win,
      B = x.isNumber,
      H = x.objectEach;
    return function () {
      function a(a, l, e) {
        this.pos = NaN;
        this.options = l;
        this.elem = a;
        this.prop = e;
      }
      a.prototype.dSetter = function () {
        var a = this.paths,
          l = a && a[0];
        a = a && a[1];
        var e = this.now || 0,
          d = [];
        if (1 !== e && l && a) {
          if (l.length === a.length && 1 > e) for (var h = 0; h < a.length; h++) {
            for (var m = l[h], k = a[h], p = [], D = 0; D < k.length; D++) {
              var I = m[D],
                E = k[D];
              B(I) && B(E) && ("A" !== k[0] || 4 !== D && 5 !== D) ? p[D] = I + e * (E - I) : p[D] = E;
            }
            d.push(p);
          } else d = a;
        } else d = this.toD || [];
        this.elem.attr("d", d, void 0, !0);
      };
      a.prototype.update = function () {
        var a = this.elem,
          l = this.prop,
          e = this.now,
          d = this.options.step;
        if (this[l + "Setter"]) this[l + "Setter"]();else a.attr ? a.element && a.attr(l, e, null, !0) : a.style[l] = e + this.unit;
        d && d.call(a, e, this);
      };
      a.prototype.run = function (r, l, e) {
        var d = this,
          h = d.options,
          m = function (e) {
            return m.stopped ? !1 : d.step(e);
          },
          k = C.requestAnimationFrame || function (d) {
            setTimeout(d, 13);
          },
          p = function () {
            for (var d = 0; d < a.timers.length; d++) a.timers[d]() || a.timers.splice(d--, 1);
            a.timers.length && k(p);
          };
        r !== l || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = r, this.end = l, this.unit = e, this.now = this.start, this.pos = 0, m.elem = this.elem, m.prop = this.prop, m() && 1 === a.timers.push(m) && k(p)) : (delete h.curAnim[this.prop], h.complete && 0 === Object.keys(h.curAnim).length && h.complete.call(this.elem));
      };
      a.prototype.step = function (a) {
        var l = +new Date(),
          e = this.options,
          d = this.elem,
          h = e.complete,
          m = e.duration,
          k = e.curAnim;
        if (d.attr && !d.element) a = !1;else if (a || l >= m + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var p = k[this.prop] = !0;
          H(k, function (d) {
            !0 !== d && (p = !1);
          });
          p && h && h.call(d);
          a = !1;
        } else this.pos = e.easing((l - this.startTime) / m), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a = !0;
        return a;
      };
      a.prototype.initPath = function (a, l, e) {
        function d(d, c) {
          for (; d.length < L;) {
            var e = d[0],
              f = c[L - d.length];
            f && "M" === e[0] && (d[0] = "C" === f[0] ? ["C", e[1], e[2], e[1], e[2], e[1], e[2]] : ["L", e[1], e[2]]);
            d.unshift(e);
            p && (e = d.pop(), d.push(d[d.length - 1], e));
          }
        }
        function h(d, c) {
          for (; d.length < L;) if (c = d[Math.floor(d.length / D) - 1].slice(), "C" === c[0] && (c[1] = c[5], c[2] = c[6]), p) {
            var e = d[Math.floor(d.length / D)].slice();
            d.splice(d.length / 2, 0, c, e);
          } else d.push(c);
        }
        var m = a.startX,
          k = a.endX;
        e = e.slice();
        var p = a.isArea,
          D = p ? 2 : 1;
        l = l && l.slice();
        if (!l) return [e, e];
        if (m && k && k.length) {
          for (a = 0; a < m.length; a++) if (m[a] === k[0]) {
            var I = a;
            break;
          } else if (m[0] === k[k.length - m.length + a]) {
            I = a;
            var E = !0;
            break;
          } else if (m[m.length - 1] === k[k.length - m.length + a]) {
            I = m.length - a;
            break;
          }
          "undefined" === typeof I && (l = []);
        }
        if (l.length && B(I)) {
          var L = e.length + I * D;
          E ? (d(l, e), h(e, l)) : (d(e, l), h(l, e));
        }
        return [l, e];
      };
      a.prototype.fillSetter = function () {
        a.prototype.strokeSetter.apply(this, arguments);
      };
      a.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, A(this.start).tweenTo(A(this.end), this.pos), void 0, !0);
      };
      a.timers = [];
      return a;
    }();
  });
  K(g, "Core/Animation/AnimationUtilities.js", [g["Core/Animation/Fx.js"], g["Core/Utilities.js"]], function (a, g) {
    function A(d) {
      return r(d) ? l({
        duration: 500,
        defer: 0
      }, d) : {
        duration: d ? 500 : 0,
        defer: 0
      };
    }
    function F(d, e) {
      for (var k = a.timers.length; k--;) a.timers[k].elem !== d || e && e !== a.timers[k].prop || (a.timers[k].stopped = !0);
    }
    var C = g.defined,
      B = g.getStyle,
      H = g.isArray,
      t = g.isNumber,
      r = g.isObject,
      l = g.merge,
      e = g.objectEach,
      d = g.pick;
    return {
      animate: function (d, m, k) {
        var p,
          h = "",
          I,
          E;
        if (!r(k)) {
          var g = arguments;
          k = {
            duration: g[2],
            easing: g[3],
            complete: g[4]
          };
        }
        t(k.duration) || (k.duration = 400);
        k.easing = "function" === typeof k.easing ? k.easing : Math[k.easing] || Math.easeInOutSine;
        k.curAnim = l(m);
        e(m, function (e, c) {
          F(d, c);
          E = new a(d, k, c);
          I = void 0;
          "d" === c && H(m.d) ? (E.paths = E.initPath(d, d.pathArray, m.d), E.toD = m.d, p = 0, I = 1) : d.attr ? p = d.attr(c) : (p = parseFloat(B(d, c)) || 0, "opacity" !== c && (h = "px"));
          I || (I = e);
          "string" === typeof I && I.match("px") && (I = I.replace(/px/g, ""));
          E.run(p, I, h);
        });
      },
      animObject: A,
      getDeferredAnimation: function (d, e, k) {
        var p = A(e),
          h = 0,
          m = 0;
        (k ? [k] : d.series).forEach(function (d) {
          d = A(d.options.animation);
          h = e && C(e.defer) ? p.defer : Math.max(h, d.duration + d.defer);
          m = Math.min(p.duration, d.duration);
        });
        d.renderer.forExport && (h = 0);
        return {
          defer: Math.max(0, h - m),
          duration: Math.min(h, m)
        };
      },
      setAnimation: function (e, m) {
        m.renderer.globalAnimation = d(e, m.options.chart.animation, !0);
      },
      stop: F
    };
  });
  K(g, "Core/Renderer/HTML/AST.js", [g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = a.SVG_NS,
      F = g.attr,
      C = g.createElement,
      B = g.css,
      H = g.error,
      t = g.isFunction,
      r = g.isString,
      l = g.objectEach,
      e = g.splat,
      d = (g = a.win.trustedTypes) && t(g.createPolicy) && g.createPolicy("highcharts", {
        createHTML: function (d) {
          return d;
        }
      }),
      h = d ? d.createHTML("") : "";
    try {
      var m = !!new DOMParser().parseFromString(h, "text/html");
    } catch (k) {
      m = !1;
    }
    t = function () {
      function k(d) {
        this.nodes = "string" === typeof d ? this.parseMarkup(d) : d;
      }
      k.filterUserAttributes = function (d) {
        l(d, function (e, h) {
          var m = !0;
          -1 === k.allowedAttributes.indexOf(h) && (m = !1);
          -1 !== ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(h) && (m = r(e) && k.allowedReferences.some(function (d) {
            return 0 === e.indexOf(d);
          }));
          m || (H(33, !1, void 0, {
            "Invalid attribute in config": "".concat(h)
          }), delete d[h]);
          r(e) && d[h] && (d[h] = e.replace(/</g, "&lt;"));
        });
        return d;
      };
      k.parseStyle = function (d) {
        return d.split(";").reduce(function (d, e) {
          e = e.split(":").map(function (d) {
            return d.trim();
          });
          var k = e.shift();
          k && e.length && (d[k.replace(/-([a-z])/g, function (d) {
            return d[1].toUpperCase();
          })] = e.join(":"));
          return d;
        }, {});
      };
      k.setElementHTML = function (d, e) {
        d.innerHTML = k.emptyHTML;
        e && new k(e).addToDOM(d);
      };
      k.prototype.addToDOM = function (d) {
        function h(d, m) {
          var p;
          e(d).forEach(function (d) {
            var c = d.tagName,
              e = d.textContent ? a.doc.createTextNode(d.textContent) : void 0,
              f = k.bypassHTMLFiltering;
            if (c) if ("#text" === c) var n = e;else if (-1 !== k.allowedTags.indexOf(c) || f) {
              c = a.doc.createElementNS("svg" === c ? A : m.namespaceURI || A, c);
              var b = d.attributes || {};
              l(d, function (c, f) {
                "tagName" !== f && "attributes" !== f && "children" !== f && "style" !== f && "textContent" !== f && (b[f] = c);
              });
              F(c, f ? b : k.filterUserAttributes(b));
              d.style && B(c, d.style);
              e && c.appendChild(e);
              h(d.children || [], c);
              n = c;
            } else H(33, !1, void 0, {
              "Invalid tagName in config": c
            });
            n && m.appendChild(n);
            p = n;
          });
          return p;
        }
        return h(this.nodes, d);
      };
      k.prototype.parseMarkup = function (e) {
        var h = [];
        e = e.trim().replace(/ style=(["'])/g, " data-style=$1");
        if (m) e = new DOMParser().parseFromString(d ? d.createHTML(e) : e, "text/html");else {
          var p = C("div");
          p.innerHTML = e;
          e = {
            body: p
          };
        }
        var a = function (d, e) {
          var c = d.nodeName.toLowerCase(),
            h = {
              tagName: c
            };
          "#text" === c && (h.textContent = d.textContent || "");
          if (c = d.attributes) {
            var f = {};
            [].forEach.call(c, function (b) {
              "data-style" === b.name ? h.style = k.parseStyle(b.value) : f[b.name] = b.value;
            });
            h.attributes = f;
          }
          if (d.childNodes.length) {
            var n = [];
            [].forEach.call(d.childNodes, function (b) {
              a(b, n);
            });
            n.length && (h.children = n);
          }
          e.push(h);
        };
        [].forEach.call(e.body.childNodes, function (d) {
          return a(d, h);
        });
        return h;
      };
      k.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(" ");
      k.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
      k.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(" ");
      k.emptyHTML = h;
      k.bypassHTMLFiltering = !1;
      return k;
    }();
    "";
    return t;
  });
  K(g, "Core/FormatUtilities.js", [g["Core/Defaults.js"], g["Core/Utilities.js"]], function (a, g) {
    function A(a, e, d, h) {
      a = +a || 0;
      e = +e;
      var m = F.lang,
        k = (a.toString().split(".")[1] || "").split("e")[0].length,
        p = a.toString().split("e"),
        l = e;
      if (-1 === e) e = Math.min(k, 20);else if (!H(e)) e = 2;else if (e && p[1] && 0 > p[1]) {
        var g = e + +p[1];
        0 <= g ? (p[0] = (+p[0]).toExponential(g).split("e")[0], e = g) : (p[0] = p[0].split(".")[0] || 0, a = 20 > e ? (p[0] * Math.pow(10, p[1])).toFixed(e) : 0, p[1] = 0);
      }
      g = (Math.abs(p[1] ? p[0] : a) + Math.pow(10, -Math.max(e, k) - 1)).toFixed(e);
      k = String(r(g));
      var E = 3 < k.length ? k.length % 3 : 0;
      d = t(d, m.decimalPoint);
      h = t(h, m.thousandsSep);
      a = (0 > a ? "-" : "") + (E ? k.substr(0, E) + h : "");
      a = 0 > +p[1] && !l ? "0" : a + k.substr(E).replace(/(\d{3})(?=\d)/g, "$1" + h);
      e && (a += d + g.slice(-e));
      p[1] && 0 !== +a && (a += "e" + p[1]);
      return a;
    }
    var F = a.defaultOptions,
      C = a.defaultTime,
      B = g.getNestedProperty,
      H = g.isNumber,
      t = g.pick,
      r = g.pInt;
    return {
      dateFormat: function (a, e, d) {
        return C.dateFormat(a, e, d);
      },
      format: function (a, e, d) {
        var h = "{",
          m = !1,
          k = /f$/,
          p = /\.([0-9])/,
          l = F.lang,
          g = d && d.time || C;
        d = d && d.numberFormatter || A;
        for (var E = []; a;) {
          var t = a.indexOf(h);
          if (-1 === t) break;
          var y = a.slice(0, t);
          if (m) {
            y = y.split(":");
            h = B(y.shift() || "", e);
            if (y.length && "number" === typeof h) if (y = y.join(":"), k.test(y)) {
              var c = parseInt((y.match(p) || ["", "-1"])[1], 10);
              null !== h && (h = d(h, c, l.decimalPoint, -1 < y.indexOf(",") ? l.thousandsSep : ""));
            } else h = g.dateFormat(y, h);
            E.push(h);
          } else E.push(y);
          a = a.slice(t + 1);
          h = (m = !m) ? "}" : "{";
        }
        E.push(a);
        return E.join("");
      },
      numberFormat: A
    };
  });
  K(g, "Core/Renderer/RendererUtilities.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.clamp,
      x = a.pick,
      F = a.stableSort,
      C;
    (function (a) {
      function A(a, r, l) {
        var e = a,
          d = e.reducedLen || r,
          h = function (d, e) {
            return (e.rank || 0) - (d.rank || 0);
          },
          m = function (d, e) {
            return d.target - e.target;
          },
          k,
          p = !0,
          D = [],
          I = 0;
        for (k = a.length; k--;) I += a[k].size;
        if (I > d) {
          F(a, h);
          for (I = k = 0; I <= d;) I += a[k].size, k++;
          D = a.splice(k - 1, a.length);
        }
        F(a, m);
        for (a = a.map(function (d) {
          return {
            size: d.size,
            targets: [d.target],
            align: x(d.align, .5)
          };
        }); p;) {
          for (k = a.length; k--;) d = a[k], h = (Math.min.apply(0, d.targets) + Math.max.apply(0, d.targets)) / 2, d.pos = g(h - d.size * d.align, 0, r - d.size);
          k = a.length;
          for (p = !1; k--;) 0 < k && a[k - 1].pos + a[k - 1].size > a[k].pos && (a[k - 1].size += a[k].size, a[k - 1].targets = a[k - 1].targets.concat(a[k].targets), a[k - 1].align = .5, a[k - 1].pos + a[k - 1].size > r && (a[k - 1].pos = r - a[k - 1].size), a.splice(k, 1), p = !0);
        }
        e.push.apply(e, D);
        k = 0;
        a.some(function (d) {
          var h = 0;
          return (d.targets || []).some(function () {
            e[k].pos = d.pos + h;
            if ("undefined" !== typeof l && Math.abs(e[k].pos - e[k].target) > l) return e.slice(0, k + 1).forEach(function (d) {
              return delete d.pos;
            }), e.reducedLen = (e.reducedLen || r) - .1 * r, e.reducedLen > .1 * r && A(e, r, l), !0;
            h += e[k].size;
            k++;
            return !1;
          });
        });
        F(e, m);
        return e;
      }
      a.distribute = A;
    })(C || (C = {}));
    return C;
  });
  K(g, "Core/Renderer/SVG/SVGElement.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = a.animate,
      B = a.animObject,
      H = a.stop,
      t = x.deg2rad,
      r = x.doc,
      l = x.svg,
      e = x.SVG_NS,
      d = x.win,
      h = F.addEvent,
      m = F.attr,
      k = F.createElement,
      p = F.css,
      D = F.defined,
      I = F.erase,
      E = F.extend,
      L = F.fireEvent,
      y = F.isArray,
      c = F.isFunction,
      w = F.isString,
      f = F.merge,
      n = F.objectEach,
      b = F.pick,
      u = F.pInt,
      z = F.syncTimeout,
      q = F.uniqueKey;
    a = function () {
      function a() {
        this.element = void 0;
        this.onEvents = {};
        this.opacity = 1;
        this.renderer = void 0;
        this.SVG_NS = e;
        this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
      }
      a.prototype._defaultGetter = function (c) {
        c = b(this[c + "Value"], this[c], this.element ? this.element.getAttribute(c) : null, 0);
        /^[\-0-9\.]+$/.test(c) && (c = parseFloat(c));
        return c;
      };
      a.prototype._defaultSetter = function (b, c, f) {
        f.setAttribute(c, b);
      };
      a.prototype.add = function (b) {
        var c = this.renderer,
          f = this.element;
        b && (this.parentGroup = b);
        "undefined" !== typeof this.textStr && "text" === this.element.nodeName && c.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var d = this.zIndexSetter();
        d || (b ? b.element : c.box).appendChild(f);
        if (this.onAdd) this.onAdd();
        return this;
      };
      a.prototype.addClass = function (b, c) {
        var f = c ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, c) {
          -1 === f.indexOf(c) && b.push(c);
          return b;
        }, f ? [f] : []).join(" ");
        b !== f && this.attr("class", b);
        return this;
      };
      a.prototype.afterSetters = function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      };
      a.prototype.align = function (c, f, d) {
        var n = {},
          e = this.renderer,
          v = e.alignedObjects,
          q,
          J,
          u;
        if (c) {
          if (this.alignOptions = c, this.alignByTranslate = f, !d || w(d)) this.alignTo = q = d || "renderer", I(v, this), v.push(this), d = void 0;
        } else c = this.alignOptions, f = this.alignByTranslate, q = this.alignTo;
        d = b(d, e[q], "scrollablePlotBox" === q ? e.plotBox : void 0, e);
        q = c.align;
        var a = c.verticalAlign;
        e = (d.x || 0) + (c.x || 0);
        v = (d.y || 0) + (c.y || 0);
        "right" === q ? J = 1 : "center" === q && (J = 2);
        J && (e += (d.width - (c.width || 0)) / J);
        n[f ? "translateX" : "x"] = Math.round(e);
        "bottom" === a ? u = 1 : "middle" === a && (u = 2);
        u && (v += (d.height - (c.height || 0)) / u);
        n[f ? "translateY" : "y"] = Math.round(v);
        this[this.placed ? "animate" : "attr"](n);
        this.placed = !0;
        this.alignAttr = n;
        return this;
      };
      a.prototype.alignSetter = function (b) {
        var c = {
          left: "start",
          center: "middle",
          right: "end"
        };
        c[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", c[b]));
      };
      a.prototype.animate = function (c, f, d) {
        var e = this,
          q = B(b(f, this.renderer.globalAnimation, !0));
        f = q.defer;
        b(r.hidden, r.msHidden, r.webkitHidden, !1) && (q.duration = 0);
        0 !== q.duration ? (d && (q.complete = d), z(function () {
          e.element && A(e, c, q);
        }, f)) : (this.attr(c, void 0, d || q.complete), n(c, function (b, c) {
          q.step && q.step.call(this, b, {
            prop: c,
            pos: 1,
            elem: this
          });
        }, this));
        return this;
      };
      a.prototype.applyTextOutline = function (b) {
        var c = this.element;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));
        var f = b.split(" ");
        b = f[f.length - 1];
        if ((f = f[0]) && "none" !== f && x.svg) {
          this.fakeTS = !0;
          f = f.replace(/(^[\d\.]+)(.*?)$/g, function (b, c, f) {
            return 2 * Number(c) + f;
          });
          this.removeTextOutline();
          var d = r.createElementNS(e, "tspan");
          m(d, {
            "class": "highcharts-text-outline",
            fill: b,
            stroke: b,
            "stroke-width": f,
            "stroke-linejoin": "round"
          });
          b = c.querySelector("textPath") || c;
          [].forEach.call(b.childNodes, function (b) {
            var c = b.cloneNode(!0);
            c.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function (b) {
              return c.removeAttribute(b);
            });
            d.appendChild(c);
          });
          var n = 0;
          [].forEach.call(b.querySelectorAll("text tspan"), function (b) {
            n += Number(b.getAttribute("dy"));
          });
          f = r.createElementNS(e, "tspan");
          f.textContent = "\u200b";
          m(f, {
            x: Number(c.getAttribute("x")),
            dy: -n
          });
          d.appendChild(f);
          b.insertBefore(d, b.firstChild);
        }
      };
      a.prototype.attr = function (b, c, f, d) {
        var e = this.element,
          v = this.symbolCustomAttribs,
          q,
          u = this,
          J,
          a;
        if ("string" === typeof b && "undefined" !== typeof c) {
          var G = b;
          b = {};
          b[G] = c;
        }
        "string" === typeof b ? u = (this[b + "Getter"] || this._defaultGetter).call(this, b, e) : (n(b, function (c, f) {
          J = !1;
          d || H(this, f);
          this.symbolName && -1 !== v.indexOf(f) && (q || (this.symbolAttr(b), q = !0), J = !0);
          !this.rotation || "x" !== f && "y" !== f || (this.doTransform = !0);
          J || (a = this[f + "Setter"] || this._defaultSetter, a.call(this, c, f, e), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(f) && this.updateShadows(f, c, a));
        }, this), this.afterSetters());
        f && f.call(this);
        return u;
      };
      a.prototype.clip = function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      };
      a.prototype.crisp = function (b, c) {
        c = c || b.strokeWidth || 0;
        var f = Math.round(c) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + f;
        b.y = Math.floor(b.y || this.y || 0) + f;
        b.width = Math.floor((b.width || this.width || 0) - 2 * f);
        b.height = Math.floor((b.height || this.height || 0) - 2 * f);
        D(b.strokeWidth) && (b.strokeWidth = c);
        return b;
      };
      a.prototype.complexColor = function (b, c, d) {
        var e = this.renderer,
          u,
          v,
          a,
          J,
          h,
          z,
          G,
          k,
          M,
          w,
          m = [],
          p;
        L(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? v = "radialGradient" : b.linearGradient && (v = "linearGradient");
          if (v) {
            a = b[v];
            h = e.gradients;
            z = b.stops;
            M = d.radialReference;
            y(a) && (b[v] = a = {
              x1: a[0],
              y1: a[1],
              x2: a[2],
              y2: a[3],
              gradientUnits: "userSpaceOnUse"
            });
            "radialGradient" === v && M && !D(a.gradientUnits) && (J = a, a = f(a, e.getRadialAttr(M, J), {
              gradientUnits: "userSpaceOnUse"
            }));
            n(a, function (b, c) {
              "id" !== c && m.push(c, b);
            });
            n(z, function (b) {
              m.push(b);
            });
            m = m.join(",");
            if (h[m]) w = h[m].attr("id");else {
              a.id = w = q();
              var U = h[m] = e.createElement(v).attr(a).add(e.defs);
              U.radAttr = J;
              U.stops = [];
              z.forEach(function (b) {
                0 === b[1].indexOf("rgba") ? (u = g.parse(b[1]), G = u.get("rgb"), k = u.get("a")) : (G = b[1], k = 1);
                b = e.createElement("stop").attr({
                  offset: b[0],
                  "stop-color": G,
                  "stop-opacity": k
                }).add(U);
                U.stops.push(b);
              });
            }
            p = "url(" + e.url + "#" + w + ")";
            d.setAttribute(c, p);
            d.gradient = m;
            b.toString = function () {
              return p;
            };
          }
        });
      };
      a.prototype.css = function (b) {
        var c = this.styles,
          d = {},
          e = this.element,
          q = !c;
        b.color && (b.fill = b.color);
        c && n(b, function (b, f) {
          c && c[f] !== b && (d[f] = b, q = !0);
        });
        if (q) {
          c && (b = E(c, d));
          if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === e.nodeName.toLowerCase() && b.width) var v = this.textWidth = u(b.width);
          this.styles = b;
          v && !l && this.renderer.forExport && delete b.width;
          var a = f(b);
          e.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function (b) {
            return a && delete a[b];
          });
          p(e, a);
          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b.textOutline && this.applyTextOutline(b.textOutline));
        }
        return this;
      };
      a.prototype.dashstyleSetter = function (c) {
        var f = this["stroke-width"];
        "inherit" === f && (f = 1);
        if (c = c && c.toLowerCase()) {
          var d = c.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
          for (c = d.length; c--;) d[c] = "" + u(d[c]) * b(f, NaN);
          c = d.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", c);
        }
      };
      a.prototype.destroy = function () {
        var b = this,
          c = b.element || {},
          f = b.renderer,
          d = c.ownerSVGElement,
          e = f.isSVG && "SPAN" === c.nodeName && b.parentGroup || void 0;
        c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;
        H(b);
        if (b.clipPath && d) {
          var v = b.clipPath;
          [].forEach.call(d.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
            -1 < b.getAttribute("clip-path").indexOf(v.element.id) && b.removeAttribute("clip-path");
          });
          b.clipPath = v.destroy();
        }
        if (b.stops) {
          for (d = 0; d < b.stops.length; d++) b.stops[d].destroy();
          b.stops.length = 0;
          b.stops = void 0;
        }
        b.safeRemoveChild(c);
        for (f.styledMode || b.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) c = e.parentGroup, b.safeRemoveChild(e.div), delete e.div, e = c;
        b.alignTo && I(f.alignedObjects, b);
        n(b, function (c, f) {
          b[f] && b[f].parentGroup === b && b[f].destroy && b[f].destroy();
          delete b[f];
        });
      };
      a.prototype.destroyShadows = function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      };
      a.prototype.dSetter = function (b, c, f) {
        y(b) && ("string" === typeof b[0] && (b = this.renderer.pathToSegments(b)), this.pathArray = b, b = b.reduce(function (b, c, f) {
          return c && c.join ? (f ? b + " " : "") + c.join(" ") : (c || "").toString();
        }, ""));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[c] !== b && (f.setAttribute(c, b), this[c] = b);
      };
      a.prototype.fadeOut = function (c) {
        var f = this;
        f.animate({
          opacity: 0
        }, {
          duration: b(c, 150),
          complete: function () {
            f.hide();
          }
        });
      };
      a.prototype.fillSetter = function (b, c, f) {
        "string" === typeof b ? f.setAttribute(c, b) : b && this.complexColor(b, c, f);
      };
      a.prototype.getBBox = function (f, d) {
        var n = this.alignValue,
          e = this.element,
          q = this.renderer,
          v = this.styles,
          u = this.textStr,
          h = q.cache,
          z = q.cacheKeys,
          k = e.namespaceURI === this.SVG_NS;
        d = b(d, this.rotation, 0);
        var G = q.styledMode ? e && a.prototype.getStyle.call(e, "font-size") : v && v.fontSize,
          m;
        if (D(u)) {
          var M = u.toString();
          -1 === M.indexOf("<") && (M = M.replace(/[0-9]/g, "0"));
          M += ["", d, G, this.textWidth, n, v && v.textOverflow, v && v.fontWeight].join();
        }
        M && !f && (m = h[M]);
        if (!m) {
          if (k || q.forExport) {
            try {
              var w = this.fakeTS && function (b) {
                var c = e.querySelector(".highcharts-text-outline");
                c && p(c, {
                  display: b
                });
              };
              c(w) && w("none");
              m = e.getBBox ? E({}, e.getBBox()) : {
                width: e.offsetWidth,
                height: e.offsetHeight,
                x: 0,
                y: 0
              };
              c(w) && w("");
            } catch (V) {
              "";
            }
            if (!m || 0 > m.width) m = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          } else m = this.htmlGetBBox();
          if (q.isSVG && (q = m.width, f = m.height, k && (m.height = f = {
            "11px,17": 14,
            "13px,20": 16
          }["" + (G || "") + ",".concat(Math.round(f))] || f), d)) {
            k = Number(e.getAttribute("y") || 0) - m.y;
            n = {
              right: 1,
              center: .5
            }[n || 0] || 0;
            v = d * t;
            G = (d - 90) * t;
            var J = q * Math.cos(v);
            d = q * Math.sin(v);
            w = Math.cos(G);
            v = Math.sin(G);
            q = m.x + n * (q - J) + k * w;
            G = q + J;
            w = G - f * w;
            J = w - J;
            k = m.y + k - n * d + k * v;
            n = k + d;
            f = n - f * v;
            d = f - d;
            m.x = Math.min(q, G, w, J);
            m.y = Math.min(k, n, f, d);
            m.width = Math.max(q, G, w, J) - m.x;
            m.height = Math.max(k, n, f, d) - m.y;
          }
          if (M && ("" === u || 0 < m.height)) {
            for (; 250 < z.length;) delete h[z.shift()];
            h[M] || z.push(M);
            h[M] = m;
          }
        }
        return m;
      };
      a.prototype.getStyle = function (b) {
        return d.getComputedStyle(this.element || this, "").getPropertyValue(b);
      };
      a.prototype.hasClass = function (b) {
        return -1 !== ("" + this.attr("class")).split(" ").indexOf(b);
      };
      a.prototype.hide = function () {
        return this.attr({
          visibility: "hidden"
        });
      };
      a.prototype.htmlGetBBox = function () {
        return {
          height: 0,
          width: 0,
          x: 0,
          y: 0
        };
      };
      a.prototype.init = function (b, c) {
        this.element = "span" === c ? k(c) : r.createElementNS(this.SVG_NS, c);
        this.renderer = b;
        L(this, "afterInit");
      };
      a.prototype.on = function (b, c) {
        var f = this.onEvents;
        if (f[b]) f[b]();
        f[b] = h(this.element, b, c);
        return this;
      };
      a.prototype.opacitySetter = function (b, c, f) {
        this.opacity = b = Number(Number(b).toFixed(3));
        f.setAttribute(c, b);
      };
      a.prototype.removeClass = function (b) {
        return this.attr("class", ("" + this.attr("class")).replace(w(b) ? new RegExp("(^| )".concat(b, "( |$)")) : b, " ").replace(/ +/g, " ").trim());
      };
      a.prototype.removeTextOutline = function () {
        var b = this.element.querySelector("tspan.highcharts-text-outline");
        b && this.safeRemoveChild(b);
      };
      a.prototype.safeRemoveChild = function (b) {
        var c = b.parentNode;
        c && c.removeChild(b);
      };
      a.prototype.setRadialReference = function (b) {
        var c = this.element.gradient && this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        c && c.radAttr && c.animate(this.renderer.getRadialAttr(b, c.radAttr));
        return this;
      };
      a.prototype.setTextPath = function (b, c) {
        var d = this;
        c = f(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, c);
        var n = this.renderer.url,
          e = this.text || this,
          v = e.textPath,
          u = c.attributes,
          a = c.enabled;
        b = b || v && v.path;
        v && v.undo();
        b && a ? (c = h(e, "afterModifyTree", function (c) {
          if (b && a) {
            var f = b.attr("id");
            f || b.attr("id", f = q());
            var v = {
              x: 0,
              y: 0
            };
            D(u.dx) && (v.dx = u.dx, delete u.dx);
            D(u.dy) && (v.dy = u.dy, delete u.dy);
            e.attr(v);
            d.attr({
              transform: ""
            });
            d.box && (d.box = d.box.destroy());
            v = c.nodes.slice(0);
            c.nodes.length = 0;
            c.nodes[0] = {
              tagName: "textPath",
              attributes: E(u, {
                "text-anchor": u.textAnchor,
                href: "" + n + "#".concat(f)
              }),
              children: v
            };
          }
        }), e.textPath = {
          path: b,
          undo: c
        }) : (e.attr({
          dx: 0,
          dy: 0
        }), delete e.textPath);
        this.added && (e.textCache = "", this.renderer.buildText(e));
        return this;
      };
      a.prototype.shadow = function (b, c, f) {
        var d = [],
          e = this.element,
          v = this.oldShadowOptions,
          q = this.parentGroup,
          u = q && 90 === q.rotation;
        q = {
          color: "#000000",
          offsetX: u ? -1 : 1,
          offsetY: u ? -1 : 1,
          opacity: .15,
          width: 3
        };
        var a = !1,
          h;
        !0 === b ? h = q : "object" === typeof b && (h = E(q, b));
        h && (h && v && n(h, function (b, c) {
          b !== v[c] && (a = !0);
        }), a && this.destroyShadows(), this.oldShadowOptions = h);
        if (!h) this.destroyShadows();else if (!this.shadows) {
          q = h.opacity / h.width;
          var G = u ? "translate(".concat(h.offsetY, ", ").concat(h.offsetX, ")") : "translate(".concat(h.offsetX, ", ").concat(h.offsetY, ")");
          for (u = 1; u <= h.width; u++) {
            var k = e.cloneNode(!1);
            var z = 2 * h.width + 1 - 2 * u;
            m(k, {
              stroke: b.color || "#000000",
              "stroke-opacity": q * u,
              "stroke-width": z,
              transform: G,
              fill: "none"
            });
            k.setAttribute("class", (k.getAttribute("class") || "") + " highcharts-shadow");
            f && (m(k, "height", Math.max(m(k, "height") - z, 0)), k.cutHeight = z);
            c ? c.element.appendChild(k) : e.parentNode && e.parentNode.insertBefore(k, e);
            d.push(k);
          }
          this.shadows = d;
        }
        return this;
      };
      a.prototype.show = function (b) {
        void 0 === b && (b = !0);
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      };
      a.prototype["stroke-widthSetter"] = function (b, c, f) {
        this[c] = b;
        f.setAttribute(c, b);
      };
      a.prototype.strokeWidth = function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
          c = 0;
        if (b.indexOf("px") === b.length - 2) c = u(b);else if ("" !== b) {
          var f = r.createElementNS(e, "rect");
          m(f, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(f);
          c = f.getBBox().width;
          f.parentNode.removeChild(f);
        }
        return c;
      };
      a.prototype.symbolAttr = function (c) {
        var f = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (d) {
          f[d] = b(c[d], f[d]);
        });
        f.attr({
          d: f.renderer.symbols[f.symbolName](f.x, f.y, f.width, f.height, f)
        });
      };
      a.prototype.textSetter = function (b) {
        b !== this.textStr && (delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      };
      a.prototype.titleSetter = function (c) {
        var f = this.element,
          d = f.getElementsByTagName("title")[0] || r.createElementNS(this.SVG_NS, "title");
        f.insertBefore ? f.insertBefore(d, f.firstChild) : f.appendChild(d);
        d.textContent = String(b(c, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
      };
      a.prototype.toFront = function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      };
      a.prototype.translate = function (b, c) {
        return this.attr({
          translateX: b,
          translateY: c
        });
      };
      a.prototype.updateShadows = function (b, c, f) {
        var d = this.shadows;
        if (d) for (var e = d.length; e--;) f.call(d[e], "height" === b ? Math.max(c - (d[e].cutHeight || 0), 0) : "d" === b ? this.d : c, b, d[e]);
      };
      a.prototype.updateTransform = function () {
        var c = this.element,
          f = this.matrix,
          d = this.rotation;
        d = void 0 === d ? 0 : d;
        var e = this.scaleX,
          n = this.scaleY,
          v = this.translateX,
          q = this.translateY;
        v = ["translate(" + (void 0 === v ? 0 : v) + "," + (void 0 === q ? 0 : q) + ")"];
        D(f) && v.push("matrix(" + f.join(",") + ")");
        d && v.push("rotate(" + d + " " + b(this.rotationOriginX, c.getAttribute("x"), 0) + " " + b(this.rotationOriginY, c.getAttribute("y") || 0) + ")");
        (D(e) || D(n)) && v.push("scale(" + b(e, 1) + " " + b(n, 1) + ")");
        v.length && !(this.text || this).textPath && c.setAttribute("transform", v.join(" "));
      };
      a.prototype.visibilitySetter = function (b, c, f) {
        "inherit" === b ? f.removeAttribute(c) : this[c] !== b && f.setAttribute(c, b);
        this[c] = b;
      };
      a.prototype.xGetter = function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      };
      a.prototype.zIndexSetter = function (b, c) {
        var f = this.renderer,
          d = this.parentGroup,
          e = (d || f).element || f.box,
          v = this.element;
        f = e === f.box;
        var n = !1;
        var q = this.added;
        var a;
        D(b) ? (v.setAttribute("data-z-index", b), b = +b, this[c] === b && (q = !1)) : D(this[c]) && v.removeAttribute("data-z-index");
        this[c] = b;
        if (q) {
          (b = this.zIndex) && d && (d.handleZ = !0);
          c = e.childNodes;
          for (a = c.length - 1; 0 <= a && !n; a--) {
            d = c[a];
            q = d.getAttribute("data-z-index");
            var h = !D(q);
            if (d !== v) if (0 > b && h && !f && !a) e.insertBefore(v, c[a]), n = !0;else if (u(q) <= b || h && (!D(b) || 0 <= b)) e.insertBefore(v, c[a + 1] || null), n = !0;
          }
          n || (e.insertBefore(v, c[f ? 3 : 0] || null), n = !0);
        }
        return n;
      };
      return a;
    }();
    a.prototype.strokeSetter = a.prototype.fillSetter;
    a.prototype.yGetter = a.prototype.xGetter;
    a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function (b, c) {
      this[c] = b;
      this.doTransform = !0;
    };
    "";
    return a;
  });
  K(g, "Core/Renderer/RendererRegistry.js", [g["Core/Globals.js"]], function (a) {
    var g;
    (function (g) {
      g.rendererTypes = {};
      var A;
      g.getRendererType = function (a) {
        void 0 === a && (a = A);
        return g.rendererTypes[a] || g.rendererTypes[A];
      };
      g.registerRendererType = function (x, B, H) {
        g.rendererTypes[x] = B;
        if (!A || H) A = x, a.Renderer = B;
      };
    })(g || (g = {}));
    return g;
  });
  K(g, "Core/Renderer/SVG/SVGLabel.js", [g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = this && this.__extends || function () {
        var a = function (e, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, e) {
            d.__proto__ = e;
          } || function (d, e) {
            for (var a in e) e.hasOwnProperty(a) && (d[a] = e[a]);
          };
          return a(e, d);
        };
        return function (e, d) {
          function h() {
            this.constructor = e;
          }
          a(e, d);
          e.prototype = null === d ? Object.create(d) : (h.prototype = d.prototype, new h());
        };
      }(),
      F = g.defined,
      C = g.extend,
      B = g.isNumber,
      H = g.merge,
      t = g.pick,
      r = g.removeEvent;
    return function (g) {
      function e(d, a, m, k, p, l, I, E, r, y) {
        var c = g.call(this) || this;
        c.paddingLeftSetter = c.paddingSetter;
        c.paddingRightSetter = c.paddingSetter;
        c.init(d, "g");
        c.textStr = a;
        c.x = m;
        c.y = k;
        c.anchorX = l;
        c.anchorY = I;
        c.baseline = r;
        c.className = y;
        c.addClass("button" === y ? "highcharts-no-tooltip" : "highcharts-label");
        y && c.addClass("highcharts-" + y);
        c.text = d.text(void 0, 0, 0, E).attr({
          zIndex: 1
        });
        var h;
        "string" === typeof p && ((h = /^url\((.*?)\)$/.test(p)) || c.renderer.symbols[p]) && (c.symbolKey = p);
        c.bBox = e.emptyBBox;
        c.padding = 3;
        c.baselineOffset = 0;
        c.needsBox = d.styledMode || h;
        c.deferredAttr = {};
        c.alignFactor = 0;
        return c;
      }
      A(e, g);
      e.prototype.alignSetter = function (d) {
        d = {
          left: 0,
          center: .5,
          right: 1
        }[d];
        d !== this.alignFactor && (this.alignFactor = d, this.bBox && B(this.xSetting) && this.attr({
          x: this.xSetting
        }));
      };
      e.prototype.anchorXSetter = function (d, e) {
        this.anchorX = d;
        this.boxAttr(e, Math.round(d) - this.getCrispAdjust() - this.xSetting);
      };
      e.prototype.anchorYSetter = function (d, e) {
        this.anchorY = d;
        this.boxAttr(e, d - this.ySetting);
      };
      e.prototype.boxAttr = function (d, e) {
        this.box ? this.box.attr(d, e) : this.deferredAttr[d] = e;
      };
      e.prototype.css = function (d) {
        if (d) {
          var h = {};
          d = H(d);
          e.textProps.forEach(function (e) {
            "undefined" !== typeof d[e] && (h[e] = d[e], delete d[e]);
          });
          this.text.css(h);
          "fontSize" in h || "fontWeight" in h ? this.updateTextPadding() : ("width" in h || "textOverflow" in h) && this.updateBoxSize();
        }
        return a.prototype.css.call(this, d);
      };
      e.prototype.destroy = function () {
        r(this.element, "mouseenter");
        r(this.element, "mouseleave");
        this.text && this.text.destroy();
        this.box && (this.box = this.box.destroy());
        a.prototype.destroy.call(this);
      };
      e.prototype.fillSetter = function (d, e) {
        d && (this.needsBox = !0);
        this.fill = d;
        this.boxAttr(e, d);
      };
      e.prototype.getBBox = function () {
        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();
        var d = this.padding,
          e = t(this.paddingLeft, d);
        return {
          width: this.width,
          height: this.height,
          x: this.bBox.x - e,
          y: this.bBox.y - d
        };
      };
      e.prototype.getCrispAdjust = function () {
        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
      };
      e.prototype.heightSetter = function (d) {
        this.heightSetting = d;
      };
      e.prototype.onAdd = function () {
        this.text.add(this);
        this.attr({
          text: t(this.textStr, ""),
          x: this.x || 0,
          y: this.y || 0
        });
        this.box && F(this.anchorX) && this.attr({
          anchorX: this.anchorX,
          anchorY: this.anchorY
        });
      };
      e.prototype.paddingSetter = function (d, e) {
        B(d) ? d !== this[e] && (this[e] = d, this.updateTextPadding()) : this[e] = void 0;
      };
      e.prototype.rSetter = function (d, e) {
        this.boxAttr(e, d);
      };
      e.prototype.shadow = function (d) {
        d && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(d));
        return this;
      };
      e.prototype.strokeSetter = function (d, e) {
        this.stroke = d;
        this.boxAttr(e, d);
      };
      e.prototype["stroke-widthSetter"] = function (d, e) {
        d && (this.needsBox = !0);
        this["stroke-width"] = d;
        this.boxAttr(e, d);
      };
      e.prototype["text-alignSetter"] = function (d) {
        this.textAlign = d;
      };
      e.prototype.textSetter = function (d) {
        "undefined" !== typeof d && this.text.attr({
          text: d
        });
        this.updateTextPadding();
      };
      e.prototype.updateBoxSize = function () {
        var d = this.text,
          a = d.element.style,
          m = {},
          k = this.padding,
          p = this.bBox = B(this.widthSetting) && B(this.heightSetting) && !this.textAlign || !F(d.textStr) ? e.emptyBBox : d.getBBox();
        this.width = this.getPaddedWidth();
        this.height = (this.heightSetting || p.height || 0) + 2 * k;
        a = this.renderer.fontMetrics(a && a.fontSize, d);
        this.baselineOffset = k + Math.min((this.text.firstLineMetrics || a).b, p.height || Infinity);
        this.heightSetting && (this.baselineOffset += (this.heightSetting - a.h) / 2);
        this.needsBox && !d.textPath && (this.box || (d = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), d.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), d.add(this)), d = this.getCrispAdjust(), m.x = d, m.y = (this.baseline ? -this.baselineOffset : 0) + d, m.width = Math.round(this.width), m.height = Math.round(this.height), this.box.attr(C(m, this.deferredAttr)), this.deferredAttr = {});
      };
      e.prototype.updateTextPadding = function () {
        var d = this.text;
        if (!d.textPath) {
          this.updateBoxSize();
          var e = this.baseline ? 0 : this.baselineOffset,
            a = t(this.paddingLeft, this.padding);
          F(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (a += {
            center: .5,
            right: 1
          }[this.textAlign] * (this.widthSetting - this.bBox.width));
          if (a !== d.x || e !== d.y) d.attr("x", a), d.hasBoxWidthChanged && (this.bBox = d.getBBox(!0)), "undefined" !== typeof e && d.attr("y", e);
          d.x = a;
          d.y = e;
        }
      };
      e.prototype.widthSetter = function (d) {
        this.widthSetting = B(d) ? d : void 0;
      };
      e.prototype.getPaddedWidth = function () {
        var d = this.padding,
          e = t(this.paddingLeft, d);
        d = t(this.paddingRight, d);
        return (this.widthSetting || this.bBox.width || 0) + e + d;
      };
      e.prototype.xSetter = function (d) {
        this.x = d;
        this.alignFactor && (d -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0);
        this.xSetting = Math.round(d);
        this.attr("translateX", this.xSetting);
      };
      e.prototype.ySetter = function (d) {
        this.ySetting = this.y = Math.round(d);
        this.attr("translateY", this.ySetting);
      };
      e.emptyBBox = {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      };
      e.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
      return e;
    }(a);
  });
  K(g, "Core/Renderer/SVG/Symbols.js", [g["Core/Utilities.js"]], function (a) {
    function g(a, g, l, e, d) {
      var h = [];
      if (d) {
        var m = d.start || 0,
          k = H(d.r, l);
        l = H(d.r, e || l);
        var p = (d.end || 0) - .001;
        e = d.innerR;
        var D = H(d.open, .001 > Math.abs((d.end || 0) - m - 2 * Math.PI)),
          I = Math.cos(m),
          E = Math.sin(m),
          r = Math.cos(p),
          y = Math.sin(p);
        m = H(d.longArc, .001 > p - m - Math.PI ? 0 : 1);
        h.push(["M", a + k * I, g + l * E], ["A", k, l, 0, m, H(d.clockwise, 1), a + k * r, g + l * y]);
        C(e) && h.push(D ? ["M", a + e * r, g + e * y] : ["L", a + e * r, g + e * y], ["A", e, e, 0, m, C(d.clockwise) ? 1 - d.clockwise : 0, a + e * I, g + e * E]);
        D || h.push(["Z"]);
      }
      return h;
    }
    function x(a, g, l, e, d) {
      return d && d.r ? F(a, g, l, e, d) : [["M", a, g], ["L", a + l, g], ["L", a + l, g + e], ["L", a, g + e], ["Z"]];
    }
    function F(a, g, l, e, d) {
      d = d && d.r || 0;
      return [["M", a + d, g], ["L", a + l - d, g], ["C", a + l, g, a + l, g, a + l, g + d], ["L", a + l, g + e - d], ["C", a + l, g + e, a + l, g + e, a + l - d, g + e], ["L", a + d, g + e], ["C", a, g + e, a, g + e, a, g + e - d], ["L", a, g + d], ["C", a, g, a, g, a + d, g]];
    }
    var C = a.defined,
      B = a.isNumber,
      H = a.pick;
    return {
      arc: g,
      callout: function (a, g, l, e, d) {
        var h = Math.min(d && d.r || 0, l, e),
          m = h + 6,
          k = d && d.anchorX;
        d = d && d.anchorY || 0;
        var p = F(a, g, l, e, {
          r: h
        });
        if (!B(k)) return p;
        a + k >= l ? d > g + m && d < g + e - m ? p.splice(3, 1, ["L", a + l, d - 6], ["L", a + l + 6, d], ["L", a + l, d + 6], ["L", a + l, g + e - h]) : p.splice(3, 1, ["L", a + l, e / 2], ["L", k, d], ["L", a + l, e / 2], ["L", a + l, g + e - h]) : 0 >= a + k ? d > g + m && d < g + e - m ? p.splice(7, 1, ["L", a, d + 6], ["L", a - 6, d], ["L", a, d - 6], ["L", a, g + h]) : p.splice(7, 1, ["L", a, e / 2], ["L", k, d], ["L", a, e / 2], ["L", a, g + h]) : d && d > e && k > a + m && k < a + l - m ? p.splice(5, 1, ["L", k + 6, g + e], ["L", k, g + e + 6], ["L", k - 6, g + e], ["L", a + h, g + e]) : d && 0 > d && k > a + m && k < a + l - m && p.splice(1, 1, ["L", k - 6, g], ["L", k, g - 6], ["L", k + 6, g], ["L", l - h, g]);
        return p;
      },
      circle: function (a, r, l, e) {
        return g(a + l / 2, r + e / 2, l / 2, e / 2, {
          start: .5 * Math.PI,
          end: 2.5 * Math.PI,
          open: !1
        });
      },
      diamond: function (a, g, l, e) {
        return [["M", a + l / 2, g], ["L", a + l, g + e / 2], ["L", a + l / 2, g + e], ["L", a, g + e / 2], ["Z"]];
      },
      rect: x,
      roundedRect: F,
      square: x,
      triangle: function (a, g, l, e) {
        return [["M", a + l / 2, g], ["L", a + l, g + e], ["L", a, g + e], ["Z"]];
      },
      "triangle-down": function (a, g, l, e) {
        return [["M", a, g], ["L", a + l, g], ["L", a + l / 2, g + e], ["Z"]];
      }
    };
  });
  K(g, "Core/Renderer/SVG/TextBuilder.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = g.doc,
      C = g.SVG_NS,
      B = g.win,
      H = x.attr,
      t = x.extend,
      r = x.fireEvent,
      l = x.isString,
      e = x.objectEach,
      d = x.pick;
    return function () {
      function h(d) {
        var e = d.styles;
        this.renderer = d.renderer;
        this.svgElement = d;
        this.width = d.textWidth;
        this.textLineHeight = e && e.lineHeight;
        this.textOutline = e && e.textOutline;
        this.ellipsis = !(!e || "ellipsis" !== e.textOverflow);
        this.noWrap = !(!e || "nowrap" !== e.whiteSpace);
        this.fontSize = e && e.fontSize;
      }
      h.prototype.buildSVG = function () {
        var e = this.svgElement,
          k = e.element,
          h = e.renderer,
          g = d(e.textStr, "").toString(),
          I = -1 !== g.indexOf("<"),
          E = k.childNodes;
        h = this.width && !e.added && h.box;
        var L = /<br.*?>/g,
          y = [g, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();
        if (y !== e.textCache) {
          e.textCache = y;
          delete e.actualWidth;
          for (y = E.length; y--;) k.removeChild(E[y]);
          I || this.ellipsis || this.width || e.textPath || -1 !== g.indexOf(" ") && (!this.noWrap || L.test(g)) ? "" !== g && (h && h.appendChild(k), g = new a(g), this.modifyTree(g.nodes), g.addToDOM(k), this.modifyDOM(), this.ellipsis && -1 !== (k.textContent || "").indexOf("\u2026") && e.attr("title", this.unescapeEntities(e.textStr || "", ["&lt;", "&gt;"])), h && h.removeChild(k)) : k.appendChild(A.createTextNode(this.unescapeEntities(g)));
          l(this.textOutline) && e.applyTextOutline && e.applyTextOutline(this.textOutline);
        }
      };
      h.prototype.modifyDOM = function () {
        var d = this,
          e = this.svgElement,
          a = H(e.element, "x");
        e.firstLineMetrics = void 0;
        for (var h; h = e.element.firstChild;) if (/^[\s\u200B]*$/.test(h.textContent || " ")) e.element.removeChild(h);else break;
        [].forEach.call(e.element.querySelectorAll("tspan.highcharts-br"), function (h, c) {
          h.nextSibling && h.previousSibling && (0 === c && 1 === h.previousSibling.nodeType && (e.firstLineMetrics = e.renderer.fontMetrics(void 0, h.previousSibling)), H(h, {
            dy: d.getLineHeight(h.nextSibling),
            x: a
          }));
        });
        var g = this.width || 0;
        if (g) {
          var l = function (h, c) {
              var w = h.textContent || "",
                f = w.replace(/([^\^])-/g, "$1- ").split(" "),
                n = !d.noWrap && (1 < f.length || 1 < e.element.childNodes.length),
                b = d.getLineHeight(c),
                u = 0,
                z = e.actualWidth;
              if (d.ellipsis) w && d.truncate(h, w, void 0, 0, Math.max(0, g - parseInt(d.fontSize || 12, 10)), function (b, c) {
                return b.substring(0, c) + "\u2026";
              });else if (n) {
                w = [];
                for (n = []; c.firstChild && c.firstChild !== h;) n.push(c.firstChild), c.removeChild(c.firstChild);
                for (; f.length;) f.length && !d.noWrap && 0 < u && (w.push(h.textContent || ""), h.textContent = f.join(" ").replace(/- /g, "-")), d.truncate(h, void 0, f, 0 === u ? z || 0 : 0, g, function (b, c) {
                  return f.slice(0, c).join(" ").replace(/- /g, "-");
                }), z = e.actualWidth, u++;
                n.forEach(function (b) {
                  c.insertBefore(b, h);
                });
                w.forEach(function (f) {
                  c.insertBefore(A.createTextNode(f), h);
                  f = A.createElementNS(C, "tspan");
                  f.textContent = "\u200b";
                  H(f, {
                    dy: b,
                    x: a
                  });
                  c.insertBefore(f, h);
                });
              }
            },
            L = function (d) {
              [].slice.call(d.childNodes).forEach(function (c) {
                c.nodeType === B.Node.TEXT_NODE ? l(c, d) : (-1 !== c.className.baseVal.indexOf("highcharts-br") && (e.actualWidth = 0), L(c));
              });
            };
          L(e.element);
        }
      };
      h.prototype.getLineHeight = function (d) {
        var e;
        d = d.nodeType === B.Node.TEXT_NODE ? d.parentElement : d;
        this.renderer.styledMode || (e = d && /(px|em)$/.test(d.style.fontSize) ? d.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(e, d || this.svgElement.element).h;
      };
      h.prototype.modifyTree = function (d) {
        var e = this,
          a = function (h, k) {
            var m = h.attributes;
            m = void 0 === m ? {} : m;
            var p = h.children,
              g = h.style;
            g = void 0 === g ? {} : g;
            var c = h.tagName,
              w = e.renderer.styledMode;
            if ("b" === c || "strong" === c) w ? m["class"] = "highcharts-strong" : g.fontWeight = "bold";else if ("i" === c || "em" === c) w ? m["class"] = "highcharts-emphasized" : g.fontStyle = "italic";
            g && g.color && (g.fill = g.color);
            "br" === c ? (m["class"] = "highcharts-br", h.textContent = "\u200b", (k = d[k + 1]) && k.textContent && (k.textContent = k.textContent.replace(/^ +/gm, ""))) : "a" === c && p && p.some(function (c) {
              return "#text" === c.tagName;
            }) && (h.children = [{
              children: p,
              tagName: "tspan"
            }]);
            "#text" !== c && "a" !== c && (h.tagName = "tspan");
            t(h, {
              attributes: m,
              style: g
            });
            p && p.filter(function (c) {
              return "#text" !== c.tagName;
            }).forEach(a);
          };
        d.forEach(a);
        r(this.svgElement, "afterModifyTree", {
          nodes: d
        });
      };
      h.prototype.truncate = function (d, e, a, h, g, l) {
        var k = this.svgElement,
          m = k.renderer,
          c = k.rotation,
          w = [],
          f = a ? 1 : 0,
          n = (e || a || "").length,
          b = n,
          u,
          z = function (b, c) {
            c = c || b;
            var f = d.parentNode;
            if (f && "undefined" === typeof w[c]) if (f.getSubStringLength) try {
              w[c] = h + f.getSubStringLength(0, a ? c + 1 : c);
            } catch (Q) {
              "";
            } else m.getSpanWidth && (d.textContent = l(e || a, b), w[c] = h + m.getSpanWidth(k, d));
            return w[c];
          };
        k.rotation = 0;
        var q = z(d.textContent.length);
        if (h + q > g) {
          for (; f <= n;) b = Math.ceil((f + n) / 2), a && (u = l(a, b)), q = z(b, u && u.length - 1), f === n ? f = n + 1 : q > g ? n = b - 1 : f = b;
          0 === n ? d.textContent = "" : e && n === e.length - 1 || (d.textContent = u || l(e || a, b));
        }
        a && a.splice(0, b);
        k.actualWidth = q;
        k.rotation = c;
      };
      h.prototype.unescapeEntities = function (d, a) {
        e(this.renderer.escapes, function (e, h) {
          a && -1 !== a.indexOf(e) || (d = d.toString().replace(new RegExp(e, "g"), h));
        });
        return d;
      };
      return h;
    }();
  });
  K(g, "Core/Renderer/SVG/SVGRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGLabel.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Renderer/SVG/TextBuilder.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B, H, t, r) {
    var l = x.charts,
      e = x.deg2rad,
      d = x.doc,
      h = x.isFirefox,
      m = x.isMS,
      k = x.isWebKit,
      p = x.noop,
      D = x.SVG_NS,
      I = x.symbolSizes,
      E = x.win,
      L = r.addEvent,
      y = r.attr,
      c = r.createElement,
      w = r.css,
      f = r.defined,
      n = r.destroyObjectProperties,
      b = r.extend,
      u = r.isArray,
      z = r.isNumber,
      q = r.isObject,
      N = r.isString,
      J = r.merge,
      O = r.pick,
      Q = r.pInt,
      A = r.uniqueKey,
      Y;
    x = function () {
      function v(b, c, f, d, e, v, a) {
        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
        this.init(b, c, f, d, e, v, a);
      }
      v.prototype.init = function (b, c, f, e, v, a, n) {
        var G = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }),
          q = G.element;
        n || G.css(this.getStyle(e));
        b.appendChild(q);
        y(b, "dir", "ltr");
        -1 === b.innerHTML.indexOf("xmlns") && y(q, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = q;
        this.boxWrapper = G;
        this.alignedObjects = [];
        this.url = this.getReferenceURL();
        this.createElement("desc").add().element.appendChild(d.createTextNode("Created with Highcharts 10.3.3"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = a;
        this.forExport = v;
        this.styledMode = n;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(c, f, !1);
        var u;
        h && b.getBoundingClientRect && (c = function () {
          w(b, {
            left: 0,
            top: 0
          });
          u = b.getBoundingClientRect();
          w(b, {
            left: Math.ceil(u.left) - u.left + "px",
            top: Math.ceil(u.top) - u.top + "px"
          });
        }, c(), this.unSubPixelFix = L(E, "resize", c));
      };
      v.prototype.definition = function (b) {
        return new a([b]).addToDOM(this.defs.element);
      };
      v.prototype.getReferenceURL = function () {
        if ((h || k) && d.getElementsByTagName("base").length) {
          if (!f(Y)) {
            var b = A();
            b = new a([{
              tagName: "svg",
              attributes: {
                width: 8,
                height: 8
              },
              children: [{
                tagName: "defs",
                children: [{
                  tagName: "clipPath",
                  attributes: {
                    id: b
                  },
                  children: [{
                    tagName: "rect",
                    attributes: {
                      width: 4,
                      height: 4
                    }
                  }]
                }]
              }, {
                tagName: "rect",
                attributes: {
                  id: "hitme",
                  width: 8,
                  height: 8,
                  "clip-path": "url(#".concat(b, ")"),
                  fill: "rgba(0,0,0,0.001)"
                }
              }]
            }]).addToDOM(d.body);
            w(b, {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 9E5
            });
            var c = d.elementFromPoint(6, 6);
            Y = "hitme" === (c && c.id);
            d.body.removeChild(b);
          }
          if (Y) return E.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
        }
        return "";
      };
      v.prototype.getStyle = function (c) {
        return this.style = b({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, c);
      };
      v.prototype.setStyle = function (b) {
        this.boxWrapper.css(this.getStyle(b));
      };
      v.prototype.isHidden = function () {
        return !this.boxWrapper.getBBox().width;
      };
      v.prototype.destroy = function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        n(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      };
      v.prototype.createElement = function (b) {
        var c = new this.Element();
        c.init(this, b);
        return c;
      };
      v.prototype.getRadialAttr = function (b, c) {
        return {
          cx: b[0] - b[2] / 2 + (c.cx || 0) * b[2],
          cy: b[1] - b[2] / 2 + (c.cy || 0) * b[2],
          r: (c.r || 0) * b[2]
        };
      };
      v.prototype.buildText = function (b) {
        new t(b).buildSVG();
      };
      v.prototype.getContrast = function (b) {
        b = g.parse(b).rgba.map(function (b) {
          b /= 255;
          return .03928 >= b ? b / 12.92 : Math.pow((b + .055) / 1.055, 2.4);
        });
        b = .2126 * b[0] + .7152 * b[1] + .0722 * b[2];
        return 1.05 / (b + .05) > (b + .05) / .05 ? "#FFFFFF" : "#000000";
      };
      v.prototype.button = function (c, f, d, e, v, n, u, h, z, w) {
        void 0 === v && (v = {});
        var G = this.label(c, f, d, z, void 0, void 0, w, void 0, "button"),
          k = this.styledMode;
        c = v.states || {};
        var M = 0;
        v = J(v);
        delete v.states;
        var g = J({
          color: "#333333",
          cursor: "pointer",
          fontWeight: "normal"
        }, v.style);
        delete v.style;
        var p = a.filterUserAttributes(v);
        G.attr(J({
          padding: 8,
          r: 2
        }, p));
        if (!k) {
          p = J({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1
          }, p);
          n = J(p, {
            fill: "#e6e6e6"
          }, a.filterUserAttributes(n || c.hover || {}));
          var U = n.style;
          delete n.style;
          u = J(p, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, a.filterUserAttributes(u || c.select || {}));
          var P = u.style;
          delete u.style;
          h = J(p, {
            style: {
              color: "#cccccc"
            }
          }, a.filterUserAttributes(h || c.disabled || {}));
          var y = h.style;
          delete h.style;
        }
        L(G.element, m ? "mouseover" : "mouseenter", function () {
          3 !== M && G.setState(1);
        });
        L(G.element, m ? "mouseout" : "mouseleave", function () {
          3 !== M && G.setState(M);
        });
        G.setState = function (b) {
          1 !== b && (G.state = M = b);
          G.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          k || (G.attr([p, n, u, h][b || 0]), b = [g, U, P, y][b || 0], q(b) && G.css(b));
        };
        k || (G.attr(p).css(b({
          cursor: "default"
        }, g)), w && G.text.css({
          pointerEvents: "none"
        }));
        return G.on("touchstart", function (b) {
          return b.stopPropagation();
        }).on("click", function (b) {
          3 !== M && e.call(G, b);
        });
      };
      v.prototype.crispLine = function (b, c, d) {
        void 0 === d && (d = "round");
        var e = b[0],
          v = b[1];
        f(e[1]) && e[1] === v[1] && (e[1] = v[1] = Math[d](e[1]) - c % 2 / 2);
        f(e[2]) && e[2] === v[2] && (e[2] = v[2] = Math[d](e[2]) + c % 2 / 2);
        return b;
      };
      v.prototype.path = function (c) {
        var f = this.styledMode ? {} : {
          fill: "none"
        };
        u(c) ? f.d = c : q(c) && b(f, c);
        return this.createElement("path").attr(f);
      };
      v.prototype.circle = function (b, c, f) {
        b = q(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: c,
          r: f
        };
        c = this.createElement("circle");
        c.xSetter = c.ySetter = function (b, c, f) {
          f.setAttribute("c" + c, b);
        };
        return c.attr(b);
      };
      v.prototype.arc = function (b, c, f, d, e, v) {
        q(b) ? (d = b, c = d.y, f = d.r, b = d.x) : d = {
          innerR: d,
          start: e,
          end: v
        };
        b = this.symbol("arc", b, c, f, f, d);
        b.r = f;
        return b;
      };
      v.prototype.rect = function (b, c, f, d, e, v) {
        e = q(b) ? b.r : e;
        var a = this.createElement("rect");
        b = q(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: c,
          width: Math.max(f, 0),
          height: Math.max(d, 0)
        };
        this.styledMode || ("undefined" !== typeof v && (b["stroke-width"] = v, b = a.crisp(b)), b.fill = "none");
        e && (b.r = e);
        a.rSetter = function (b, c, f) {
          a.r = b;
          y(f, {
            rx: b,
            ry: b
          });
        };
        a.rGetter = function () {
          return a.r || 0;
        };
        return a.attr(b);
      };
      v.prototype.setSize = function (b, c, f) {
        this.width = b;
        this.height = c;
        this.boxWrapper.animate({
          width: b,
          height: c
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: O(f, !0) ? void 0 : 0
        });
        this.alignElements();
      };
      v.prototype.g = function (b) {
        var c = this.createElement("g");
        return b ? c.attr({
          "class": "highcharts-" + b
        }) : c;
      };
      v.prototype.image = function (b, c, f, d, e, v) {
        var a = {
            preserveAspectRatio: "none"
          },
          n = function (b, c) {
            b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", c) : b.setAttribute("hc-svg-href", c);
          };
        z(c) && (a.x = c);
        z(f) && (a.y = f);
        z(d) && (a.width = d);
        z(e) && (a.height = e);
        var G = this.createElement("image").attr(a);
        c = function (c) {
          n(G.element, b);
          v.call(G, c);
        };
        v ? (n(G.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), f = new E.Image(), L(f, "load", c), f.src = b, f.complete && c({})) : n(G.element, b);
        return G;
      };
      v.prototype.symbol = function (e, v, a, n, G, q) {
        var u = this,
          h = /^url\((.*?)\)$/,
          z = h.test(e),
          k = !z && (this.symbols[e] ? e : "circle"),
          g = k && this.symbols[k],
          m;
        if (g) {
          "number" === typeof v && (m = g.call(this.symbols, Math.round(v || 0), Math.round(a || 0), n || 0, G || 0, q));
          var p = this.path(m);
          u.styledMode || p.attr("fill", "none");
          b(p, {
            symbolName: k || void 0,
            x: v,
            y: a,
            width: n,
            height: G
          });
          q && b(p, q);
        } else if (z) {
          var P = e.match(h)[1];
          var U = p = this.image(P);
          U.imgwidth = O(I[P] && I[P].width, q && q.width);
          U.imgheight = O(I[P] && I[P].height, q && q.height);
          var N = function (b) {
            return b.attr({
              width: b.width,
              height: b.height
            });
          };
          ["width", "height"].forEach(function (b) {
            U[b + "Setter"] = function (b, c) {
              this[c] = b;
              b = this.alignByTranslate;
              var d = this.element,
                e = this.width,
                v = this.height,
                a = this.imgwidth,
                n = this.imgheight,
                G = this["img" + c];
              if (f(G)) {
                var u = 1;
                q && "within" === q.backgroundSize && e && v ? (u = Math.min(e / a, v / n), G = Math.round(G * u), y(d, {
                  width: Math.round(a * u),
                  height: Math.round(n * u)
                })) : d && d.setAttribute(c, G);
                b || this.translate(((e || 0) - G * u) / 2, ((v || 0) - G * u) / 2);
              }
            };
          });
          f(v) && U.attr({
            x: v,
            y: a
          });
          U.isImg = !0;
          f(U.imgwidth) && f(U.imgheight) ? N(U) : (U.attr({
            width: 0,
            height: 0
          }), c("img", {
            onload: function () {
              var b = l[u.chartIndex];
              0 === this.width && (w(this, {
                position: "absolute",
                top: "-999em"
              }), d.body.appendChild(this));
              I[P] = {
                width: this.width,
                height: this.height
              };
              U.imgwidth = this.width;
              U.imgheight = this.height;
              U.element && N(U);
              this.parentNode && this.parentNode.removeChild(this);
              u.imgCount--;
              if (!u.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: P
          }), this.imgCount++);
        }
        return p;
      };
      v.prototype.clipRect = function (b, c, f, d) {
        var e = A() + "-",
          v = this.createElement("clipPath").attr({
            id: e
          }).add(this.defs);
        b = this.rect(b, c, f, d, 0).add(v);
        b.id = e;
        b.clipPath = v;
        b.count = 0;
        return b;
      };
      v.prototype.text = function (b, c, d, e) {
        var v = {};
        if (e && (this.allowHTML || !this.forExport)) return this.html(b, c, d);
        v.x = Math.round(c || 0);
        d && (v.y = Math.round(d));
        f(b) && (v.text = b);
        b = this.createElement("text").attr(v);
        if (!e || this.forExport && !this.allowHTML) b.xSetter = function (b, c, f) {
          for (var d = f.getElementsByTagName("tspan"), e = f.getAttribute(c), v = 0, a; v < d.length; v++) a = d[v], a.getAttribute(c) === e && a.setAttribute(c, b);
          f.setAttribute(c, b);
        };
        return b;
      };
      v.prototype.fontMetrics = function (b, c) {
        b = !this.styledMode && /px/.test(b) || !E.getComputedStyle ? b || c && c.style && c.style.fontSize || this.style && this.style.fontSize : c && C.prototype.getStyle.call(c, "font-size");
        b = /px/.test(b) ? Q(b) : 12;
        c = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: c,
          b: Math.round(.8 * c),
          f: b
        };
      };
      v.prototype.rotCorr = function (b, c, f) {
        var d = b;
        c && f && (d = Math.max(d * Math.cos(c * e), 4));
        return {
          x: -b / 3 * Math.sin(c * e),
          y: d
        };
      };
      v.prototype.pathToSegments = function (b) {
        for (var c = [], f = [], d = {
            A: 8,
            C: 7,
            H: 2,
            L: 3,
            M: 3,
            Q: 5,
            S: 5,
            T: 3,
            V: 2
          }, e = 0; e < b.length; e++) N(f[0]) && z(b[e]) && f.length === d[f[0].toUpperCase()] && b.splice(e, 0, f[0].replace("M", "L").replace("m", "l")), "string" === typeof b[e] && (f.length && c.push(f.slice(0)), f.length = 0), f.push(b[e]);
        c.push(f.slice(0));
        return c;
      };
      v.prototype.label = function (b, c, f, d, e, v, a, n, q) {
        return new B(this, b, c, f, d, e, v, a, n, q);
      };
      v.prototype.alignElements = function () {
        this.alignedObjects.forEach(function (b) {
          return b.align();
        });
      };
      return v;
    }();
    b(x.prototype, {
      Element: C,
      SVG_NS: D,
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      symbols: H,
      draw: p
    });
    F.registerRendererType("svg", x, !0);
    "";
    return x;
  });
  K(g, "Core/Renderer/HTML/HTMLElement.js", [g["Core/Globals.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = this && this.__extends || function () {
        var d = function (e, a) {
          d = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, e) {
            d.__proto__ = e;
          } || function (d, e) {
            for (var a in e) e.hasOwnProperty(a) && (d[a] = e[a]);
          };
          return d(e, a);
        };
        return function (e, a) {
          function h() {
            this.constructor = e;
          }
          d(e, a);
          e.prototype = null === a ? Object.create(a) : (h.prototype = a.prototype, new h());
        };
      }(),
      C = a.isFirefox,
      B = a.isMS,
      H = a.isWebKit,
      t = a.win,
      r = x.css,
      l = x.defined,
      e = x.extend,
      d = x.pick,
      h = x.pInt;
    return function (a) {
      function k() {
        return null !== a && a.apply(this, arguments) || this;
      }
      A(k, a);
      k.compose = function (d) {
        if (-1 === k.composedClasses.indexOf(d)) {
          k.composedClasses.push(d);
          var e = k.prototype,
            a = d.prototype;
          a.getSpanCorrection = e.getSpanCorrection;
          a.htmlCss = e.htmlCss;
          a.htmlGetBBox = e.htmlGetBBox;
          a.htmlUpdateTransform = e.htmlUpdateTransform;
          a.setSpanRotation = e.setSpanRotation;
        }
        return d;
      };
      k.prototype.getSpanCorrection = function (d, e, a) {
        this.xCorr = -d * a;
        this.yCorr = -e;
      };
      k.prototype.htmlCss = function (a) {
        var h = "SPAN" === this.element.tagName && a && "width" in a,
          k = d(h && a.width, void 0);
        if (h) {
          delete a.width;
          this.textWidth = k;
          var g = !0;
        }
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = e(this.styles, a);
        r(this.element, a);
        g && this.htmlUpdateTransform();
        return this;
      };
      k.prototype.htmlGetBBox = function () {
        var d = this.element;
        return {
          x: d.offsetLeft,
          y: d.offsetTop,
          width: d.offsetWidth,
          height: d.offsetHeight
        };
      };
      k.prototype.htmlUpdateTransform = function () {
        if (this.added) {
          var d = this.renderer,
            e = this.element,
            a = this.translateX || 0,
            k = this.translateY || 0,
            g = this.x || 0,
            m = this.y || 0,
            c = this.textAlign || "left",
            w = {
              left: 0,
              center: .5,
              right: 1
            }[c],
            f = this.styles;
          f = f && f.whiteSpace;
          r(e, {
            marginLeft: a,
            marginTop: k
          });
          !d.styledMode && this.shadows && this.shadows.forEach(function (b) {
            r(b, {
              marginLeft: a + 1,
              marginTop: k + 1
            });
          });
          this.inverted && [].forEach.call(e.childNodes, function (b) {
            d.invertChild(b, e);
          });
          if ("SPAN" === e.tagName) {
            var n = this.rotation,
              b = this.textWidth && h(this.textWidth),
              u = [n, c, e.innerHTML, this.textWidth, this.textAlign].join(),
              z = void 0;
            z = !1;
            if (b !== this.oldTextWidth) {
              if (this.textPxLength) var q = this.textPxLength;else r(e, {
                width: "",
                whiteSpace: f || "nowrap"
              }), q = e.offsetWidth;
              (b > this.oldTextWidth || q > b) && (/[ \-]/.test(e.textContent || e.innerText) || "ellipsis" === e.style.textOverflow) && (r(e, {
                width: q > b || n ? b + "px" : "auto",
                display: "block",
                whiteSpace: f || "normal"
              }), this.oldTextWidth = b, z = !0);
            }
            this.hasBoxWidthChanged = z;
            u !== this.cTT && (z = d.fontMetrics(e.style.fontSize, e).b, !l(n) || n === (this.oldRotation || 0) && c === this.oldAlign || this.setSpanRotation(n, w, z), this.getSpanCorrection(!l(n) && this.textPxLength || e.offsetWidth, z, w, n, c));
            r(e, {
              left: g + (this.xCorr || 0) + "px",
              top: m + (this.yCorr || 0) + "px"
            });
            this.cTT = u;
            this.oldRotation = n;
            this.oldAlign = c;
          }
        } else this.alignOnAdd = !0;
      };
      k.prototype.setSpanRotation = function (d, e, a) {
        var h = {},
          k = B && !/Edge/.test(t.navigator.userAgent) ? "-ms-transform" : H ? "-webkit-transform" : C ? "MozTransform" : t.opera ? "-o-transform" : void 0;
        k && (h[k] = h.transform = "rotate(" + d + "deg)", h[k + (C ? "Origin" : "-origin")] = h.transformOrigin = 100 * e + "% " + a + "px", r(this.element, h));
      };
      k.composedClasses = [];
      return k;
    }(g);
  });
  K(g, "Core/Renderer/HTML/HTMLRenderer.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = this && this.__extends || function () {
        var a = function (e, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (d, e) {
            d.__proto__ = e;
          } || function (d, e) {
            for (var a in e) e.hasOwnProperty(a) && (d[a] = e[a]);
          };
          return a(e, d);
        };
        return function (e, d) {
          function h() {
            this.constructor = e;
          }
          a(e, d);
          e.prototype = null === d ? Object.create(d) : (h.prototype = d.prototype, new h());
        };
      }(),
      B = F.attr,
      H = F.createElement,
      t = F.extend,
      r = F.pick;
    return function (l) {
      function e() {
        return null !== l && l.apply(this, arguments) || this;
      }
      A(e, l);
      e.compose = function (d) {
        -1 === e.composedClasses.indexOf(d) && (e.composedClasses.push(d), d.prototype.html = e.prototype.html);
        return d;
      };
      e.prototype.html = function (d, e, m) {
        var h = this.createElement("span"),
          p = h.element,
          l = h.renderer,
          I = l.isSVG,
          E = function (d, e) {
            ["opacity", "visibility"].forEach(function (c) {
              d[c + "Setter"] = function (a, f, n) {
                var b = d.div ? d.div.style : e;
                g.prototype[c + "Setter"].call(this, a, f, n);
                b && (b[f] = a);
              };
            });
            d.addedSetters = !0;
          };
        h.textSetter = function (d) {
          d !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, r(d, "")), this.textStr = d, h.doTransform = !0);
        };
        I && E(h, h.element.style);
        h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function (d, e) {
          "align" === e ? h.alignValue = h.textAlign = d : h[e] = d;
          h.doTransform = !0;
        };
        h.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };
        h.attr({
          text: d,
          x: Math.round(e),
          y: Math.round(m)
        }).css({
          position: "absolute"
        });
        l.styledMode || h.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        p.style.whiteSpace = "nowrap";
        h.css = h.htmlCss;
        I && (h.add = function (d) {
          var e = l.box.parentNode,
            c = [];
          if (this.parentGroup = d) {
            var a = d.div;
            if (!a) {
              for (; d;) c.push(d), d = d.parentGroup;
              c.reverse().forEach(function (f) {
                function d(b, c) {
                  f[c] = b;
                  "translateX" === c ? z.left = b + "px" : z.top = b + "px";
                  f.doTransform = !0;
                }
                var b = B(f.element, "class"),
                  u = f.styles || {};
                a = f.div = f.div || H("div", b ? {
                  className: b
                } : void 0, {
                  position: "absolute",
                  left: (f.translateX || 0) + "px",
                  top: (f.translateY || 0) + "px",
                  display: f.display,
                  opacity: f.opacity,
                  cursor: u.cursor,
                  pointerEvents: u.pointerEvents,
                  visibility: f.visibility
                }, a || e);
                var z = a.style;
                t(f, {
                  classSetter: function (b) {
                    return function (c) {
                      this.element.setAttribute("class", c);
                      b.className = c;
                    };
                  }(a),
                  on: function () {
                    c[0].div && h.on.apply({
                      element: c[0].div,
                      onEvents: f.onEvents
                    }, arguments);
                    return f;
                  },
                  translateXSetter: d,
                  translateYSetter: d
                });
                f.addedSetters || E(f);
              });
            }
          } else a = e;
          a.appendChild(p);
          h.added = !0;
          h.alignOnAdd && h.htmlUpdateTransform();
          return h;
        });
        return h;
      };
      e.composedClasses = [];
      return e;
    }(x);
  });
  K(g, "Core/Axis/AxisDefaults.js", [], function () {
    var a;
    (function (a) {
      a.defaultXAxisOptions = {
        alignTicks: !0,
        allowDecimals: void 0,
        panningEnabled: !0,
        zIndex: 2,
        zoomEnabled: !0,
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        gridLineDashStyle: "Solid",
        gridZIndex: 1,
        labels: {
          autoRotation: void 0,
          autoRotationLimit: 80,
          distance: void 0,
          enabled: !0,
          indentation: 10,
          overflow: "justify",
          padding: 5,
          reserveSpace: void 0,
          rotation: void 0,
          staggerLines: 0,
          step: 0,
          useHTML: !1,
          x: 0,
          zIndex: 7,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorGridLineDashStyle: "Solid",
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        offset: void 0,
        opposite: !1,
        reversed: void 0,
        reversedStacks: !1,
        showEmpty: !0,
        showFirstLabel: !0,
        showLastLabel: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          rotation: 0,
          useHTML: !1,
          x: 0,
          y: 0,
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        uniqueNames: !0,
        visible: !0,
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        gridLineWidth: void 0,
        tickColor: "#ccd6eb"
      };
      a.defaultYAxisOptions = {
        reversedStacks: !0,
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          animation: {},
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total || 0, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      };
      a.defaultLeftAxisOptions = {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      };
      a.defaultRightAxisOptions = {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      };
      a.defaultBottomAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
      a.defaultTopAxisOptions = {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      };
    })(a || (a = {}));
    return a;
  });
  K(g, "Core/Foundation.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.addEvent,
      x = a.isFunction,
      F = a.objectEach,
      C = a.removeEvent,
      B;
    (function (a) {
      a.registerEventOptions = function (a, r) {
        a.eventOptions = a.eventOptions || {};
        F(r.events, function (l, e) {
          a.eventOptions[e] !== l && (a.eventOptions[e] && (C(a, e, a.eventOptions[e]), delete a.eventOptions[e]), x(l) && (a.eventOptions[e] = l, g(a, e, l)));
        });
      };
    })(B || (B = {}));
    return B;
  });
  K(g, "Core/Axis/Tick.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = g.deg2rad,
      C = x.clamp,
      B = x.correctFloat,
      H = x.defined,
      t = x.destroyObjectProperties,
      r = x.extend,
      l = x.fireEvent,
      e = x.isNumber,
      d = x.merge,
      h = x.objectEach,
      m = x.pick;
    g = function () {
      function g(d, e, a, h, g) {
        this.isNewLabel = this.isNew = !0;
        this.axis = d;
        this.pos = e;
        this.type = a || "";
        this.parameters = g || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        l(this, "init");
        a || h || this.addLabel();
      }
      g.prototype.addLabel = function () {
        var d = this,
          h = d.axis,
          g = h.options,
          k = h.chart,
          L = h.categories,
          y = h.logarithmic,
          c = h.names,
          w = d.pos,
          f = m(d.options && d.options.labels, g.labels),
          n = h.tickPositions,
          b = w === n[0],
          u = w === n[n.length - 1],
          z = (!f.step || 1 === f.step) && 1 === h.tickInterval;
        n = n.info;
        var q = d.label,
          N;
        L = this.parameters.category || (L ? m(L[w], c[w], w) : w);
        y && e(L) && (L = B(y.lin2log(L)));
        if (h.dateTime) if (n) {
          var J = k.time.resolveDTLFormat(g.dateTimeLabelFormats[!g.grid && n.higherRanks[w] || n.unitName]);
          var O = J.main;
        } else e(L) && (O = h.dateTime.getXDateFormat(L, g.dateTimeLabelFormats || {}));
        d.isFirst = b;
        d.isLast = u;
        var Q = {
          axis: h,
          chart: k,
          dateTimeLabelFormat: O,
          isFirst: b,
          isLast: u,
          pos: w,
          tick: d,
          tickPositionInfo: n,
          value: L
        };
        l(this, "labelFormat", Q);
        var t = function (b) {
          return f.formatter ? f.formatter.call(b, b) : f.format ? (b.text = h.defaultLabelFormatter.call(b, b), a.format(f.format, b, k)) : h.defaultLabelFormatter.call(b, b);
        };
        g = t.call(Q, Q);
        var Y = J && J.list;
        d.shortenLabel = Y ? function () {
          for (N = 0; N < Y.length; N++) if (r(Q, {
            dateTimeLabelFormat: Y[N]
          }), q.attr({
            text: t.call(Q, Q)
          }), q.getBBox().width < h.getSlotWidth(d) - 2 * f.padding) return;
          q.attr({
            text: ""
          });
        } : void 0;
        z && h._addedPlotLB && d.moveLabel(g, f);
        H(q) || d.movedLabel ? q && q.textStr !== g && !z && (!q.textWidth || f.style.width || q.styles.width || q.css({
          width: null
        }), q.attr({
          text: g
        }), q.textPxLength = q.getBBox().width) : (d.label = q = d.createLabel({
          x: 0,
          y: 0
        }, g, f), d.rotation = 0);
      };
      g.prototype.createLabel = function (e, a, h) {
        var g = this.axis,
          k = g.chart;
        if (e = H(a) && h.enabled ? k.renderer.text(a, e.x, e.y, h.useHTML).add(g.labelGroup) : null) k.styledMode || e.css(d(h.style)), e.textPxLength = e.getBBox().width;
        return e;
      };
      g.prototype.destroy = function () {
        t(this, this.axis);
      };
      g.prototype.getPosition = function (d, e, a, h) {
        var g = this.axis,
          k = g.chart,
          c = h && k.oldChartHeight || k.chartHeight;
        d = {
          x: d ? B(g.translate(e + a, void 0, void 0, h) + g.transB) : g.left + g.offset + (g.opposite ? (h && k.oldChartWidth || k.chartWidth) - g.right - g.left : 0),
          y: d ? c - g.bottom + g.offset - (g.opposite ? g.height : 0) : B(c - g.translate(e + a, void 0, void 0, h) - g.transB)
        };
        d.y = C(d.y, -1E5, 1E5);
        l(this, "afterGetPosition", {
          pos: d
        });
        return d;
      };
      g.prototype.getLabelPosition = function (d, e, a, h, g, k, c, w) {
        var f = this.axis,
          n = f.transA,
          b = f.isLinked && f.linkedParent ? f.linkedParent.reversed : f.reversed,
          u = f.staggerLines,
          z = f.tickRotCorr || {
            x: 0,
            y: 0
          },
          q = h || f.reserveSpaceDefault ? 0 : -f.labelOffset * ("center" === f.labelAlign ? .5 : 1),
          m = {};
        a = 0 === f.side ? a.rotation ? -8 : -a.getBBox().height : 2 === f.side ? z.y + 8 : Math.cos(a.rotation * A) * (z.y - a.getBBox(!1, 0).height / 2);
        H(g.y) && (a = 0 === f.side && f.horiz ? g.y + a : g.y);
        d = d + g.x + q + z.x - (k && h ? k * n * (b ? -1 : 1) : 0);
        e = e + a - (k && !h ? k * n * (b ? 1 : -1) : 0);
        u && (h = c / (w || 1) % u, f.opposite && (h = u - h - 1), e += f.labelOffset / u * h);
        m.x = d;
        m.y = Math.round(e);
        l(this, "afterGetLabelPosition", {
          pos: m,
          tickmarkOffset: k,
          index: c
        });
        return m;
      };
      g.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };
      g.prototype.getMarkPath = function (d, e, a, h, g, k) {
        return k.crispLine([["M", d, e], ["L", d + (g ? 0 : -a), e + (g ? a : 0)]], h);
      };
      g.prototype.handleOverflow = function (d) {
        var e = this.axis,
          a = e.options.labels,
          h = d.x,
          g = e.chart.chartWidth,
          k = e.chart.spacing,
          c = m(e.labelLeft, Math.min(e.pos, k[3]));
        k = m(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, g - k[1]));
        var w = this.label,
          f = this.rotation,
          n = {
            left: 0,
            center: .5,
            right: 1
          }[e.labelAlign || w.attr("align")],
          b = w.getBBox().width,
          u = e.getSlotWidth(this),
          z = {},
          q = u,
          p = 1,
          l;
        if (f || "justify" !== a.overflow) 0 > f && h - n * b < c ? l = Math.round(h / Math.cos(f * A) - c) : 0 < f && h + n * b > k && (l = Math.round((g - h) / Math.cos(f * A)));else if (g = h + (1 - n) * b, h - n * b < c ? q = d.x + q * (1 - n) - c : g > k && (q = k - d.x + q * n, p = -1), q = Math.min(u, q), q < u && "center" === e.labelAlign && (d.x += p * (u - q - n * (u - Math.min(b, q)))), b > q || e.autoRotation && (w.styles || {}).width) l = q;
        l && (this.shortenLabel ? this.shortenLabel() : (z.width = Math.floor(l) + "px", (a.style || {}).textOverflow || (z.textOverflow = "ellipsis"), w.css(z)));
      };
      g.prototype.moveLabel = function (d, e) {
        var a = this,
          g = a.label,
          k = a.axis,
          m = k.reversed,
          c = !1;
        g && g.textStr === d ? (a.movedLabel = g, c = !0, delete a.label) : h(k.ticks, function (f) {
          c || f.isNew || f === a || !f.label || f.label.textStr !== d || (a.movedLabel = f.label, c = !0, f.labelPos = a.movedLabel.xy, delete f.label);
        });
        if (!c && (a.labelPos || g)) {
          var w = a.labelPos || g.xy;
          g = k.horiz ? m ? 0 : k.width + k.left : w.x;
          k = k.horiz ? w.y : m ? k.width + k.left : 0;
          a.movedLabel = a.createLabel({
            x: g,
            y: k
          }, d, e);
          a.movedLabel && a.movedLabel.attr({
            opacity: 0
          });
        }
      };
      g.prototype.render = function (d, e, a) {
        var h = this.axis,
          g = h.horiz,
          k = this.pos,
          c = m(this.tickmarkOffset, h.tickmarkOffset);
        k = this.getPosition(g, k, c, e);
        c = k.x;
        var w = k.y;
        h = g && c === h.pos + h.len || !g && w === h.pos ? -1 : 1;
        g = m(a, this.label && this.label.newOpacity, 1);
        a = m(a, 1);
        this.isActive = !0;
        this.renderGridLine(e, a, h);
        this.renderMark(k, a, h);
        this.renderLabel(k, e, g, d);
        this.isNew = !1;
        l(this, "afterRender");
      };
      g.prototype.renderGridLine = function (d, e, a) {
        var h = this.axis,
          g = h.options,
          k = {},
          c = this.pos,
          w = this.type,
          f = m(this.tickmarkOffset, h.tickmarkOffset),
          n = h.chart.renderer,
          b = this.gridLine,
          u = g.gridLineWidth,
          z = g.gridLineColor,
          q = g.gridLineDashStyle;
        "minor" === this.type && (u = g.minorGridLineWidth, z = g.minorGridLineColor, q = g.minorGridLineDashStyle);
        b || (h.chart.styledMode || (k.stroke = z, k["stroke-width"] = u || 0, k.dashstyle = q), w || (k.zIndex = 1), d && (e = 0), this.gridLine = b = n.path().attr(k).addClass("highcharts-" + (w ? w + "-" : "") + "grid-line").add(h.gridGroup));
        if (b && (a = h.getPlotLinePath({
          value: c + f,
          lineWidth: b.strokeWidth() * a,
          force: "pass",
          old: d,
          acrossPanes: !1
        }))) b[d || this.isNew ? "attr" : "animate"]({
          d: a,
          opacity: e
        });
      };
      g.prototype.renderMark = function (d, e, a) {
        var h = this.axis,
          g = h.options,
          k = h.chart.renderer,
          c = this.type,
          w = h.tickSize(c ? c + "Tick" : "tick"),
          f = d.x;
        d = d.y;
        var n = m(g["minor" !== c ? "tickWidth" : "minorTickWidth"], !c && h.isXAxis ? 1 : 0);
        g = g["minor" !== c ? "tickColor" : "minorTickColor"];
        var b = this.mark,
          u = !b;
        w && (h.opposite && (w[0] = -w[0]), b || (this.mark = b = k.path().addClass("highcharts-" + (c ? c + "-" : "") + "tick").add(h.axisGroup), h.chart.styledMode || b.attr({
          stroke: g,
          "stroke-width": n
        })), b[u ? "attr" : "animate"]({
          d: this.getMarkPath(f, d, w[0], b.strokeWidth() * a, h.horiz, k),
          opacity: e
        }));
      };
      g.prototype.renderLabel = function (d, a, h, g) {
        var k = this.axis,
          l = k.horiz,
          c = k.options,
          w = this.label,
          f = c.labels,
          n = f.step;
        k = m(this.tickmarkOffset, k.tickmarkOffset);
        var b = d.x;
        d = d.y;
        var u = !0;
        w && e(b) && (w.xy = d = this.getLabelPosition(b, d, w, l, f, k, g, n), this.isFirst && !this.isLast && !c.showFirstLabel || this.isLast && !this.isFirst && !c.showLastLabel ? u = !1 : !l || f.step || f.rotation || a || 0 === h || this.handleOverflow(d), n && g % n && (u = !1), u && e(d.y) ? (d.opacity = h, w[this.isNewLabel ? "attr" : "animate"](d).show(!0), this.isNewLabel = !1) : (w.hide(), this.isNewLabel = !0));
      };
      g.prototype.replaceMovedLabel = function () {
        var d = this.label,
          e = this.axis,
          a = e.reversed;
        if (d && !this.isNew) {
          var h = e.horiz ? a ? e.left : e.width + e.left : d.xy.x;
          a = e.horiz ? d.xy.y : a ? e.width + e.top : e.top;
          d.animate({
            x: h,
            y: a,
            opacity: 0
          }, void 0, d.destroy);
          delete this.label;
        }
        e.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };
      return g;
    }();
    "";
    return g;
  });
  K(g, "Core/Axis/Axis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/AxisDefaults.js"], g["Core/Color/Color.js"], g["Core/Defaults.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Axis/Tick.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B, H, t) {
    var r = a.animObject,
      l = F.defaultOptions,
      e = C.registerEventOptions,
      d = B.deg2rad,
      h = t.arrayMax,
      m = t.arrayMin,
      k = t.clamp,
      p = t.correctFloat,
      D = t.defined,
      I = t.destroyObjectProperties,
      E = t.erase,
      A = t.error,
      y = t.extend,
      c = t.fireEvent,
      w = t.isArray,
      f = t.isNumber,
      n = t.isString,
      b = t.merge,
      u = t.normalizeTickInterval,
      z = t.objectEach,
      q = t.pick,
      N = t.relativeLength,
      J = t.removeEvent,
      O = t.splat,
      Q = t.syncTimeout,
      T = function (b, c) {
        return u(c, void 0, void 0, q(b.options.allowDecimals, .5 > c || void 0 !== b.tickAmount), !!b.tickAmount);
      };
    a = function () {
      function a(b, c) {
        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
        this.init(b, c);
      }
      a.prototype.init = function (b, d) {
        var a = d.isX;
        this.chart = b;
        this.horiz = b.inverted && !this.isZAxis ? !a : a;
        this.isXAxis = a;
        this.coll = this.coll || (a ? "xAxis" : "yAxis");
        c(this, "init", {
          userOptions: d
        });
        this.opposite = q(d.opposite, this.opposite);
        this.side = q(d.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
        this.setOptions(d);
        var v = this.options,
          n = v.labels,
          h = v.type;
        this.userOptions = d;
        this.minPixelPadding = 0;
        this.reversed = q(v.reversed, this.reversed);
        this.visible = v.visible;
        this.zoomEnabled = v.zoomEnabled;
        this.hasNames = "category" === h || !0 === v.categories;
        this.categories = v.categories || (this.hasNames ? [] : void 0);
        this.names || (this.names = [], this.names.keys = {});
        this.plotLinesAndBandsGroups = {};
        this.positiveValuesOnly = !!this.logarithmic;
        this.isLinked = D(v.linkedTo);
        this.ticks = {};
        this.labelEdge = [];
        this.minorTicks = {};
        this.plotLinesAndBands = [];
        this.alternateBands = {};
        this.len = 0;
        this.minRange = this.userMinRange = v.minRange || v.maxZoom;
        this.range = v.range;
        this.offset = v.offset || 0;
        this.min = this.max = null;
        d = q(v.crosshair, O(b.options.tooltip.crosshairs)[a ? 0 : 1]);
        this.crosshair = !0 === d ? {} : d;
        -1 === b.axes.indexOf(this) && (a ? b.axes.splice(b.xAxis.length, 0, this) : b.axes.push(this), b[this.coll].push(this));
        this.series = this.series || [];
        b.inverted && !this.isZAxis && a && "undefined" === typeof this.reversed && (this.reversed = !0);
        this.labelRotation = f(n.rotation) ? n.rotation : void 0;
        e(this, v);
        c(this, "afterInit");
      };
      a.prototype.setOptions = function (f) {
        this.options = b(g.defaultXAxisOptions, "yAxis" === this.coll && g.defaultYAxisOptions, [g.defaultTopAxisOptions, g.defaultRightAxisOptions, g.defaultBottomAxisOptions, g.defaultLeftAxisOptions][this.side], b(l[this.coll], f));
        c(this, "afterSetOptions", {
          userOptions: f
        });
      };
      a.prototype.defaultLabelFormatter = function (b) {
        var c = this.axis;
        b = this.chart.numberFormatter;
        var d = f(this.value) ? this.value : NaN,
          a = c.chart.time,
          e = this.dateTimeLabelFormat,
          v = l.lang,
          n = v.numericSymbols;
        v = v.numericSymbolMagnitude || 1E3;
        var h = c.logarithmic ? Math.abs(d) : c.tickInterval,
          q = n && n.length;
        if (c.categories) var u = "".concat(this.value);else if (e) u = a.dateFormat(e, d);else if (q && 1E3 <= h) for (; q-- && "undefined" === typeof u;) c = Math.pow(v, q + 1), h >= c && 0 === 10 * d % c && null !== n[q] && 0 !== d && (u = b(d / c, -1) + n[q]);
        "undefined" === typeof u && (u = 1E4 <= Math.abs(d) ? b(d, -1) : b(d, -1, void 0, ""));
        return u;
      };
      a.prototype.getSeriesExtremes = function () {
        var b = this,
          d = b.chart,
          a;
        c(this, "getSeriesExtremes", null, function () {
          b.hasVisibleSeries = !1;
          b.dataMin = b.dataMax = b.threshold = null;
          b.softThreshold = !b.isXAxis;
          b.series.forEach(function (c) {
            if (c.visible || !d.options.chart.ignoreHiddenSeries) {
              var e = c.options,
                v = e.threshold;
              b.hasVisibleSeries = !0;
              b.positiveValuesOnly && 0 >= v && (v = null);
              if (b.isXAxis) {
                if (e = c.xData, e.length) {
                  e = b.logarithmic ? e.filter(b.validatePositiveValue) : e;
                  a = c.getXExtremes(e);
                  var n = a.min;
                  var h = a.max;
                  f(n) || n instanceof Date || (e = e.filter(f), a = c.getXExtremes(e), n = a.min, h = a.max);
                  e.length && (b.dataMin = Math.min(q(b.dataMin, n), n), b.dataMax = Math.max(q(b.dataMax, h), h));
                }
              } else if (c = c.applyExtremes(), f(c.dataMin) && (n = c.dataMin, b.dataMin = Math.min(q(b.dataMin, n), n)), f(c.dataMax) && (h = c.dataMax, b.dataMax = Math.max(q(b.dataMax, h), h)), D(v) && (b.threshold = v), !e.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
            }
          });
        });
        c(this, "afterGetSeriesExtremes");
      };
      a.prototype.translate = function (b, c, d, a, e, n) {
        var v = this.linkedParent || this,
          h = a && v.old ? v.old.min : v.min;
        if (!f(h)) return NaN;
        var q = v.minPixelPadding;
        e = (v.isOrdinal || v.brokenAxis && v.brokenAxis.hasBreaks || v.logarithmic && e) && v.lin2val;
        var u = 1,
          G = 0;
        a = a && v.old ? v.old.transA : v.transA;
        a || (a = v.transA);
        d && (u *= -1, G = v.len);
        v.reversed && (u *= -1, G -= u * (v.sector || v.len));
        c ? (n = (b * u + G - q) / a + h, e && (n = v.lin2val(n))) : (e && (b = v.val2lin(b)), b = u * (b - h) * a, n = (v.isRadial ? b : p(b)) + G + u * q + (f(n) ? a * n : 0));
        return n;
      };
      a.prototype.toPixels = function (b, c) {
        return this.translate(b, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);
      };
      a.prototype.toValue = function (b, c) {
        return this.translate(b - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);
      };
      a.prototype.getPlotLinePath = function (b) {
        function d(b, c, f) {
          "pass" !== p && (b < c || b > f) && (p ? b = k(b, c, f) : r = !0);
          return b;
        }
        var a = this,
          e = a.chart,
          v = a.left,
          n = a.top,
          h = b.old,
          u = b.value,
          g = b.lineWidth,
          z = h && e.oldChartHeight || e.chartHeight,
          w = h && e.oldChartWidth || e.chartWidth,
          m = a.transB,
          l = b.translatedValue,
          p = b.force,
          J,
          N,
          y,
          O,
          r;
        b = {
          value: u,
          lineWidth: g,
          old: h,
          force: p,
          acrossPanes: b.acrossPanes,
          translatedValue: l
        };
        c(this, "getPlotLinePath", b, function (b) {
          l = q(l, a.translate(u, void 0, void 0, h));
          l = k(l, -1E5, 1E5);
          J = y = Math.round(l + m);
          N = O = Math.round(z - l - m);
          f(l) ? a.horiz ? (N = n, O = z - a.bottom, J = y = d(J, v, v + a.width)) : (J = v, y = w - a.right, N = O = d(N, n, n + a.height)) : (r = !0, p = !1);
          b.path = r && !p ? null : e.renderer.crispLine([["M", J, N], ["L", y, O]], g || 1);
        });
        return b.path;
      };
      a.prototype.getLinearTickPositions = function (b, c, f) {
        var d = p(Math.floor(c / b) * b);
        f = p(Math.ceil(f / b) * b);
        var a = [],
          e;
        p(d + b) === d && (e = 20);
        if (this.single) return [c];
        for (c = d; c <= f;) {
          a.push(c);
          c = p(c + b, e);
          if (c === v) break;
          var v = c;
        }
        return a;
      };
      a.prototype.getMinorTickInterval = function () {
        var b = this.options;
        return !0 === b.minorTicks ? q(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
      };
      a.prototype.getMinorTickPositions = function () {
        var b = this.options,
          c = this.tickPositions,
          f = this.minorTickInterval,
          d = this.pointRangePadding || 0,
          a = this.min - d;
        d = this.max + d;
        var e = d - a,
          n = [];
        if (e && e / f < this.len / 3) {
          var h = this.logarithmic;
          if (h) this.paddedTicks.forEach(function (b, c, d) {
            c && n.push.apply(n, h.getLogTickPositions(f, d[c - 1], d[c], !0));
          });else if (this.dateTime && "auto" === this.getMinorTickInterval()) n = n.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(f), a, d, b.startOfWeek));else for (b = a + (c[0] - a) % f; b <= d && b !== n[0]; b += f) n.push(b);
        }
        0 !== n.length && this.trimTicks(n);
        return n;
      };
      a.prototype.adjustForMinRange = function () {
        var b = this.options,
          c = this.logarithmic,
          f = this.min,
          d = this.max,
          a = 0,
          e,
          n,
          u,
          g;
        this.isXAxis && "undefined" === typeof this.minRange && !c && (D(b.min) || D(b.max) || D(b.floor) || D(b.ceiling) ? this.minRange = null : (this.series.forEach(function (b) {
          u = b.xData;
          g = b.xIncrement ? 1 : u.length - 1;
          if (1 < u.length) for (e = g; 0 < e; e--) if (n = u[e] - u[e - 1], !a || n < a) a = n;
        }), this.minRange = Math.min(5 * a, this.dataMax - this.dataMin)));
        if (d - f < this.minRange) {
          var z = this.dataMax - this.dataMin >= this.minRange;
          var k = this.minRange;
          var w = (k - d + f) / 2;
          w = [f - w, q(b.min, f - w)];
          z && (w[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
          f = h(w);
          d = [f + k, q(b.max, f + k)];
          z && (d[2] = c ? c.log2lin(this.dataMax) : this.dataMax);
          d = m(d);
          d - f < k && (w[0] = d - k, w[1] = q(b.min, d - k), f = h(w));
        }
        this.min = f;
        this.max = d;
      };
      a.prototype.getClosest = function () {
        var b;
        this.categories ? b = 1 : this.series.forEach(function (c) {
          var f = c.closestPointRange,
            d = c.visible || !c.chart.options.chart.ignoreHiddenSeries;
          !c.noSharedTooltip && D(f) && d && (b = D(b) ? Math.min(b, f) : f);
        });
        return b;
      };
      a.prototype.nameToX = function (b) {
        var c = w(this.options.categories),
          f = c ? this.categories : this.names,
          d = b.options.x;
        b.series.requireSorting = !1;
        D(d) || (d = this.options.uniqueNames && f ? c ? f.indexOf(b.name) : q(f.keys[b.name], -1) : b.series.autoIncrement());
        if (-1 === d) {
          if (!c && f) var a = f.length;
        } else a = d;
        "undefined" !== typeof a ? (this.names[a] = b.name, this.names.keys[b.name] = a) : b.x && (a = b.x);
        return a;
      };
      a.prototype.updateNames = function () {
        var b = this,
          c = this.names;
        0 < c.length && (Object.keys(c.keys).forEach(function (b) {
          delete c.keys[b];
        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {
          c.xIncrement = null;
          if (!c.points || c.isDirtyData) b.max = Math.max(b.max, c.xData.length - 1), c.processData(), c.generatePoints();
          c.data.forEach(function (f, d) {
            if (f && f.options && "undefined" !== typeof f.name) {
              var a = b.nameToX(f);
              "undefined" !== typeof a && a !== f.x && (f.x = a, c.xData[d] = a);
            }
          });
        }));
      };
      a.prototype.setAxisTranslation = function () {
        var b = this,
          f = b.max - b.min,
          d = b.linkedParent,
          a = !!b.categories,
          e = b.isXAxis,
          h = b.axisPointRange || 0,
          u = 0,
          g = 0,
          k = b.transA;
        if (e || a || h) {
          var z = b.getClosest();
          d ? (u = d.minPointOffset, g = d.pointRangePadding) : b.series.forEach(function (c) {
            var f = a ? 1 : e ? q(c.options.pointRange, z, 0) : b.axisPointRange || 0,
              d = c.options.pointPlacement;
            h = Math.max(h, f);
            if (!b.single || a) c = c.is("xrange") ? !e : e, u = Math.max(u, c && n(d) ? 0 : f / 2), g = Math.max(g, c && "on" === d ? 0 : f);
          });
          d = b.ordinal && b.ordinal.slope && z ? b.ordinal.slope / z : 1;
          b.minPointOffset = u *= d;
          b.pointRangePadding = g *= d;
          b.pointRange = Math.min(h, b.single && a ? 1 : f);
          e && (b.closestPointRange = z);
        }
        b.translationSlope = b.transA = k = b.staticScale || b.len / (f + g || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = k * u;
        c(this, "afterSetAxisTranslation");
      };
      a.prototype.minFromRange = function () {
        return this.max - this.range;
      };
      a.prototype.setTickInterval = function (b) {
        var d = this.chart,
          a = this.logarithmic,
          e = this.options,
          n = this.isXAxis,
          h = this.isLinked,
          u = e.tickPixelInterval,
          v = this.categories,
          g = this.softThreshold,
          k = e.maxPadding,
          z = e.minPadding,
          w = f(e.tickInterval) && 0 <= e.tickInterval ? e.tickInterval : void 0,
          m = f(this.threshold) ? this.threshold : null;
        this.dateTime || v || h || this.getTickAmount();
        var l = q(this.userMin, e.min);
        var J = q(this.userMax, e.max);
        if (h) {
          this.linkedParent = d[this.coll][e.linkedTo];
          var N = this.linkedParent.getExtremes();
          this.min = q(N.min, N.dataMin);
          this.max = q(N.max, N.dataMax);
          e.type !== this.linkedParent.options.type && A(11, 1, d);
        } else {
          if (g && D(m)) if (this.dataMin >= m) N = m, z = 0;else if (this.dataMax <= m) {
            var y = m;
            k = 0;
          }
          this.min = q(l, N, this.dataMin);
          this.max = q(J, y, this.dataMax);
        }
        a && (this.positiveValuesOnly && !b && 0 >= Math.min(this.min, q(this.dataMin, this.min)) && A(10, 1, d), this.min = p(a.log2lin(this.min), 16), this.max = p(a.log2lin(this.max), 16));
        this.range && D(this.max) && (this.userMin = this.min = l = Math.max(this.dataMin, this.minFromRange()), this.userMax = J = this.max, this.range = null);
        c(this, "foundExtremes");
        this.beforePadding && this.beforePadding();
        this.adjustForMinRange();
        !(v || this.axisPointRange || this.stacking && this.stacking.usePercentage || h) && D(this.min) && D(this.max) && (d = this.max - this.min) && (!D(l) && z && (this.min -= d * z), !D(J) && k && (this.max += d * k));
        f(this.userMin) || (f(e.softMin) && e.softMin < this.min && (this.min = l = e.softMin), f(e.floor) && (this.min = Math.max(this.min, e.floor)));
        f(this.userMax) || (f(e.softMax) && e.softMax > this.max && (this.max = J = e.softMax), f(e.ceiling) && (this.max = Math.min(this.max, e.ceiling)));
        g && D(this.dataMin) && (m = m || 0, !D(l) && this.min < m && this.dataMin >= m ? this.min = this.options.minRange ? Math.min(m, this.max - this.minRange) : m : !D(J) && this.max > m && this.dataMax <= m && (this.max = this.options.minRange ? Math.max(m, this.min + this.minRange) : m));
        f(this.min) && f(this.max) && !this.chart.polar && this.min > this.max && (D(this.options.min) ? this.max = this.min : D(this.options.max) && (this.min = this.max));
        this.tickInterval = this.min === this.max || "undefined" === typeof this.min || "undefined" === typeof this.max ? 1 : h && this.linkedParent && !w && u === this.linkedParent.options.tickPixelInterval ? w = this.linkedParent.tickInterval : q(w, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, v ? 1 : (this.max - this.min) * u / Math.max(this.len, u));
        if (n && !b) {
          var O = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
          this.series.forEach(function (b) {
            b.forceCrop = b.forceCropping && b.forceCropping();
            b.processData(O);
          });
          c(this, "postProcessData", {
            hasExtremesChanged: O
          });
        }
        this.setAxisTranslation();
        c(this, "initialAxisTranslation");
        this.pointRange && !w && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
        b = q(e.minTickInterval, this.dateTime && !this.series.some(function (b) {
          return b.noSharedTooltip;
        }) ? this.closestPointRange : 0);
        !w && this.tickInterval < b && (this.tickInterval = b);
        this.dateTime || this.logarithmic || w || (this.tickInterval = T(this, this.tickInterval));
        this.tickAmount || (this.tickInterval = this.unsquish());
        this.setTickPositions();
      };
      a.prototype.setTickPositions = function () {
        var b = this.options,
          d = b.tickPositions,
          a = b.tickPositioner,
          e = this.getMinorTickInterval(),
          n = this.hasVerticalPanning(),
          h = "colorAxis" === this.coll,
          u = (h || !n) && b.startOnTick;
        n = (h || !n) && b.endOnTick;
        h = [];
        var q;
        this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === e && this.tickInterval ? this.tickInterval / 5 : e;
        this.single = this.min === this.max && D(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
        if (d) h = d.slice();else if (f(this.min) && f(this.max)) {
          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
            if (this.dateTime) h = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) h = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (e = b = this.tickInterval; e <= 2 * b;) if (h = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && h.length > this.tickAmount) this.tickInterval = T(this, e *= 1.1);else break;
          } else h = [this.min, this.max], A(19, !1, this.chart);
          h.length > this.len && (h = [h[0], h[h.length - 1]], h[0] === h[1] && (h.length = 1));
          a && (this.tickPositions = h, (q = a.apply(this, [this.min, this.max])) && (h = q));
        }
        this.tickPositions = h;
        this.paddedTicks = h.slice(0);
        this.trimTicks(h, u, n);
        !this.isLinked && f(this.min) && f(this.max) && (this.single && 2 > h.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), d || q || this.adjustTickAmount());
        c(this, "afterSetTickPositions");
      };
      a.prototype.trimTicks = function (b, f, d) {
        var a = b[0],
          e = b[b.length - 1],
          h = !this.isOrdinal && this.minPointOffset || 0;
        c(this, "trimTicks");
        if (!this.isLinked) {
          if (f && -Infinity !== a) this.min = a;else for (; this.min - h > b[0];) b.shift();
          if (d) this.max = e;else for (; this.max + h < b[b.length - 1];) b.pop();
          0 === b.length && D(a) && !this.options.tickPositions && b.push((e + a) / 2);
        }
      };
      a.prototype.alignToOthers = function () {
        var b = this,
          c = [this],
          d = b.options,
          a = "yAxis" === this.coll && this.chart.options.chart.alignThresholds,
          e = [],
          h;
        b.thresholdAlignment = void 0;
        if ((!1 !== this.chart.options.chart.alignTicks && d.alignTicks || a) && !1 !== d.startOnTick && !1 !== d.endOnTick && !b.logarithmic) {
          var n = function (b) {
              var c = b.options;
              return [b.horiz ? c.left : c.top, c.width, c.height, c.pane].join();
            },
            u = n(this);
          this.chart[this.coll].forEach(function (f) {
            var d = f.series;
            d.length && d.some(function (b) {
              return b.visible;
            }) && f !== b && n(f) === u && (h = !0, c.push(f));
          });
        }
        if (h && a) {
          c.forEach(function (c) {
            c = c.getThresholdAlignment(b);
            f(c) && e.push(c);
          });
          var q = 1 < e.length ? e.reduce(function (b, c) {
            return b + c;
          }, 0) / e.length : void 0;
          c.forEach(function (b) {
            b.thresholdAlignment = q;
          });
        }
        return h;
      };
      a.prototype.getThresholdAlignment = function (b) {
        (!f(this.dataMin) || this !== b && this.series.some(function (b) {
          return b.isDirty || b.isDirtyData;
        })) && this.getSeriesExtremes();
        if (f(this.threshold)) return b = k((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (b = 1 - b), b;
      };
      a.prototype.getTickAmount = function () {
        var b = this.options,
          c = b.tickPixelInterval,
          f = b.tickAmount;
        !D(b.tickInterval) && !f && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (f = 2);
        !f && this.alignToOthers() && (f = Math.ceil(this.len / c) + 1);
        4 > f && (this.finalTickAmt = f, f = 5);
        this.tickAmount = f;
      };
      a.prototype.adjustTickAmount = function () {
        var b = this,
          c = b.finalTickAmt,
          d = b.max,
          a = b.min,
          e = b.options,
          h = b.tickPositions,
          n = b.tickAmount,
          u = b.thresholdAlignment,
          g = h && h.length,
          k = q(b.threshold, b.softThreshold ? 0 : null);
        var z = b.tickInterval;
        if (f(u)) {
          var w = .5 > u ? Math.ceil(u * (n - 1)) : Math.floor(u * (n - 1));
          e.reversed && (w = n - 1 - w);
        }
        if (b.hasData() && f(a) && f(d)) {
          u = function () {
            b.transA *= (g - 1) / (n - 1);
            b.min = e.startOnTick ? h[0] : Math.min(a, h[0]);
            b.max = e.endOnTick ? h[h.length - 1] : Math.max(d, h[h.length - 1]);
          };
          if (f(w) && f(b.threshold)) {
            for (; h[w] !== k || h.length !== n || h[0] > a || h[h.length - 1] < d;) {
              h.length = 0;
              for (h.push(b.threshold); h.length < n;) void 0 === h[w] || h[w] > b.threshold ? h.unshift(p(h[0] - z)) : h.push(p(h[h.length - 1] + z));
              if (z > 8 * b.tickInterval) break;
              z *= 2;
            }
            u();
          } else if (g < n) {
            for (; h.length < n;) h.length % 2 || a === k ? h.push(p(h[h.length - 1] + z)) : h.unshift(p(h[0] - z));
            u();
          }
          if (D(c)) {
            for (z = k = h.length; z--;) (3 === c && 1 === z % 2 || 2 >= c && 0 < z && z < k - 1) && h.splice(z, 1);
            b.finalTickAmt = void 0;
          }
        }
      };
      a.prototype.setScale = function () {
        var b = !1,
          f = !1;
        this.series.forEach(function (c) {
          b = b || c.isDirtyData || c.isDirty;
          f = f || c.xAxis && c.xAxis.isDirty || !1;
        });
        this.setAxisSize();
        var d = this.len !== (this.old && this.old.len);
        d || b || f || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && (this.stacking.resetStacks(), this.stacking.buildStacks()), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = d || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
        b && this.panningState && (this.panningState.isDirty = !0);
        c(this, "afterSetScale");
      };
      a.prototype.setExtremes = function (b, f, d, a, e) {
        var h = this,
          n = h.chart;
        d = q(d, !0);
        h.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = y(e, {
          min: b,
          max: f
        });
        c(h, "setExtremes", e, function () {
          h.userMin = b;
          h.userMax = f;
          h.eventArgs = e;
          d && n.redraw(a);
        });
      };
      a.prototype.zoom = function (b, f) {
        var d = this,
          a = this.dataMin,
          e = this.dataMax,
          h = this.options,
          n = Math.min(a, q(h.min, a)),
          u = Math.max(e, q(h.max, e));
        b = {
          newMin: b,
          newMax: f
        };
        c(this, "zoom", b, function (b) {
          var c = b.newMin,
            f = b.newMax;
          if (c !== d.min || f !== d.max) d.allowZoomOutside || (D(a) && (c < n && (c = n), c > u && (c = u)), D(e) && (f < n && (f = n), f > u && (f = u))), d.displayBtn = "undefined" !== typeof c || "undefined" !== typeof f, d.setExtremes(c, f, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return b.zoomed;
      };
      a.prototype.setAxisSize = function () {
        var b = this.chart,
          c = this.options,
          f = c.offsets || [0, 0, 0, 0],
          d = this.horiz,
          a = this.width = Math.round(N(q(c.width, b.plotWidth - f[3] + f[1]), b.plotWidth)),
          e = this.height = Math.round(N(q(c.height, b.plotHeight - f[0] + f[2]), b.plotHeight)),
          h = this.top = Math.round(N(q(c.top, b.plotTop + f[0]), b.plotHeight, b.plotTop));
        c = this.left = Math.round(N(q(c.left, b.plotLeft + f[3]), b.plotWidth, b.plotLeft));
        this.bottom = b.chartHeight - e - h;
        this.right = b.chartWidth - a - c;
        this.len = Math.max(d ? a : e, 0);
        this.pos = d ? c : h;
      };
      a.prototype.getExtremes = function () {
        var b = this.logarithmic;
        return {
          min: b ? p(b.lin2log(this.min)) : this.min,
          max: b ? p(b.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      };
      a.prototype.getThreshold = function (b) {
        var c = this.logarithmic,
          f = c ? c.lin2log(this.min) : this.min;
        c = c ? c.lin2log(this.max) : this.max;
        null === b || -Infinity === b ? b = f : Infinity === b ? b = c : f > b ? b = f : c < b && (b = c);
        return this.translate(b, 0, 1, 0, 1);
      };
      a.prototype.autoLabelAlign = function (b) {
        var f = (q(b, 0) - 90 * this.side + 720) % 360;
        b = {
          align: "center"
        };
        c(this, "autoLabelAlign", b, function (b) {
          15 < f && 165 > f ? b.align = "right" : 195 < f && 345 > f && (b.align = "left");
        });
        return b.align;
      };
      a.prototype.tickSize = function (b) {
        var f = this.options,
          d = q(f["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0),
          a = f["tick" === b ? "tickLength" : "minorTickLength"];
        if (d && a) {
          "inside" === f[b + "Position"] && (a = -a);
          var e = [a, d];
        }
        b = {
          tickSize: e
        };
        c(this, "afterTickSize", b);
        return b.tickSize;
      };
      a.prototype.labelMetrics = function () {
        var b = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
      };
      a.prototype.unsquish = function () {
        var b = this.options.labels,
          c = this.horiz,
          a = this.tickInterval,
          e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a),
          h = b.rotation,
          n = this.labelMetrics(),
          u = Math.max(this.max - this.min, 0),
          g = function (b) {
            var c = b / (e || 1);
            c = 1 < c ? Math.ceil(c) : 1;
            c * a > u && Infinity !== b && Infinity !== e && u && (c = Math.ceil(u / a));
            return p(c * a);
          },
          z = a,
          k = Number.MAX_VALUE;
        if (c) {
          if (!b.staggerLines) if (f(h)) var w = [h];else e < b.autoRotationLimit && (w = b.autoRotation);
          if (w) for (var m = c = void 0, l = 0, J = w; l < J.length; l++) {
            var N = J[l];
            if (N === h || N && -90 <= N && 90 >= N) if (c = g(Math.abs(n.h / Math.sin(d * N))), m = c + Math.abs(N / 360), m < k) {
              k = m;
              var y = N;
              z = c;
            }
          }
        } else z = g(n.h);
        this.autoRotation = w;
        this.labelRotation = q(y, f(h) ? h : 0);
        return b.step ? a : z;
      };
      a.prototype.getSlotWidth = function (b) {
        var c = this.chart,
          d = this.horiz,
          a = this.options.labels,
          e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
          h = c.margin[3];
        if (b && f(b.slotWidth)) return b.slotWidth;
        if (d && 2 > a.step) return a.rotation ? 0 : (this.staggerLines || 1) * this.len / e;
        if (!d) {
          b = a.style.width;
          if (void 0 !== b) return parseInt(String(b), 10);
          if (h) return h - c.spacing[3];
        }
        return .33 * c.chartWidth;
      };
      a.prototype.renderUnsquish = function () {
        var b = this.chart,
          c = b.renderer,
          f = this.tickPositions,
          d = this.ticks,
          a = this.options.labels,
          e = a.style,
          h = this.horiz,
          u = this.getSlotWidth(),
          q = Math.max(1, Math.round(u - 2 * a.padding)),
          g = {},
          z = this.labelMetrics(),
          k = e.textOverflow,
          w = 0;
        n(a.rotation) || (g.rotation = a.rotation || 0);
        f.forEach(function (b) {
          b = d[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > w && (w = b.label.textPxLength);
        });
        this.maxLabelLength = w;
        if (this.autoRotation) w > q && w > z.h ? g.rotation = this.labelRotation : this.labelRotation = 0;else if (u) {
          var m = q;
          if (!k) {
            var l = "clip";
            for (q = f.length; !h && q--;) {
              var p = f[q];
              if (p = d[p].label) p.styles && "ellipsis" === p.styles.textOverflow ? p.css({
                textOverflow: "clip"
              }) : p.textPxLength > u && p.css({
                width: u + "px"
              }), p.getBBox().height > this.len / f.length - (z.h - z.f) && (p.specificTextOverflow = "ellipsis");
            }
          }
        }
        g.rotation && (m = w > .5 * b.chartHeight ? .33 * b.chartHeight : w, k || (l = "ellipsis"));
        if (this.labelAlign = a.align || this.autoLabelAlign(this.labelRotation)) g.align = this.labelAlign;
        f.forEach(function (b) {
          var c = (b = d[b]) && b.label,
            f = e.width,
            a = {};
          c && (c.attr(g), b.shortenLabel ? b.shortenLabel() : m && !f && "nowrap" !== e.whiteSpace && (m < c.textPxLength || "SPAN" === c.element.tagName) ? (a.width = m + "px", k || (a.textOverflow = c.specificTextOverflow || l), c.css(a)) : c.styles && c.styles.width && !a.width && !f && c.css({
            width: null
          }), delete c.specificTextOverflow, b.rotation = g.rotation);
        }, this);
        this.tickRotCorr = c.rotCorr(z.b, this.labelRotation || 0, 0 !== this.side);
      };
      a.prototype.hasData = function () {
        return this.series.some(function (b) {
          return b.hasData();
        }) || this.options.showEmpty && D(this.min) && D(this.max);
      };
      a.prototype.addTitle = function (c) {
        var f = this.chart.renderer,
          d = this.horiz,
          a = this.opposite,
          e = this.options.title,
          h = this.chart.styledMode,
          n;
        this.axisTitle || ((n = e.textAlign) || (n = (d ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: a ? "right" : "left",
          middle: "center",
          high: a ? "left" : "right"
        })[e.align]), this.axisTitle = f.text(e.text || "", 0, 0, e.useHTML).attr({
          zIndex: 7,
          rotation: e.rotation,
          align: n
        }).addClass("highcharts-axis-title"), h || this.axisTitle.css(b(e.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        h || e.style.width || this.isRadial || this.axisTitle.css({
          width: this.len + "px"
        });
        this.axisTitle[c ? "show" : "hide"](c);
      };
      a.prototype.generateTick = function (b) {
        var c = this.ticks;
        c[b] ? c[b].addLabel() : c[b] = new H(this, b);
      };
      a.prototype.getOffset = function () {
        var b = this,
          f = this,
          d = f.chart,
          a = f.horiz,
          e = f.options,
          h = f.side,
          n = f.ticks,
          u = f.tickPositions,
          g = f.coll,
          k = f.axisParent,
          w = d.renderer,
          m = d.inverted && !f.isZAxis ? [1, 0, 3, 2][h] : h,
          l = f.hasData(),
          p = e.title,
          N = e.labels,
          J = d.axisOffset;
        d = d.clipOffset;
        var y = [-1, 1, 1, -1][h],
          O = e.className,
          r,
          Q = 0,
          ja = 0,
          da = 0;
        f.showAxis = r = l || e.showEmpty;
        f.staggerLines = f.horiz && N.staggerLines || void 0;
        if (!f.axisGroup) {
          var I = function (c, f, d) {
            return w.g(c).attr({
              zIndex: d
            }).addClass("highcharts-".concat(g.toLowerCase()).concat(f, " ") + (b.isRadial ? "highcharts-radial-axis".concat(f, " ") : "") + (O || "")).add(k);
          };
          f.gridGroup = I("grid", "-grid", e.gridZIndex);
          f.axisGroup = I("axis", "", e.zIndex);
          f.labelGroup = I("axis-labels", "-labels", N.zIndex);
        }
        l || f.isLinked ? (u.forEach(function (b) {
          f.generateTick(b);
        }), f.renderUnsquish(), f.reserveSpaceDefault = 0 === h || 2 === h || {
          1: "left",
          3: "right"
        }[h] === f.labelAlign, q(N.reserveSpace, "center" === f.labelAlign ? !0 : null, f.reserveSpaceDefault) && u.forEach(function (b) {
          da = Math.max(n[b].getLabelSize(), da);
        }), f.staggerLines && (da *= f.staggerLines), f.labelOffset = da * (f.opposite ? -1 : 1)) : z(n, function (b, c) {
          b.destroy();
          delete n[c];
        });
        if (p && p.text && !1 !== p.enabled && (f.addTitle(r), r && !1 !== p.reserveSpace)) {
          f.titleOffset = Q = f.axisTitle.getBBox()[a ? "height" : "width"];
          var t = p.offset;
          ja = D(t) ? 0 : q(p.margin, a ? 5 : 10);
        }
        f.renderLine();
        f.offset = y * q(e.offset, J[h] ? J[h] + (e.margin || 0) : 0);
        f.tickRotCorr = f.tickRotCorr || {
          x: 0,
          y: 0
        };
        p = 0 === h ? -f.labelMetrics().h : 2 === h ? f.tickRotCorr.y : 0;
        l = Math.abs(da) + ja;
        da && (l = l - p + y * (a ? q(N.y, f.tickRotCorr.y + 8 * y) : N.x));
        f.axisTitleMargin = q(t, l);
        f.getMaxLabelDimensions && (f.maxLabelDimensions = f.getMaxLabelDimensions(n, u));
        "colorAxis" !== g && (a = this.tickSize("tick"), J[h] = Math.max(J[h], (f.axisTitleMargin || 0) + Q + y * f.offset, l, u && u.length && a ? a[0] + y * f.offset : 0), e = !f.axisLine || e.offset ? 0 : 2 * Math.floor(f.axisLine.strokeWidth() / 2), d[m] = Math.max(d[m], e));
        c(this, "afterGetOffset");
      };
      a.prototype.getLinePath = function (b) {
        var c = this.chart,
          f = this.opposite,
          d = this.offset,
          a = this.horiz,
          e = this.left + (f ? this.width : 0) + d;
        d = c.chartHeight - this.bottom - (f ? this.height : 0) + d;
        f && (b *= -1);
        return c.renderer.crispLine([["M", a ? this.left : e, a ? d : this.top], ["L", a ? c.chartWidth - this.right : e, a ? d : c.chartHeight - this.bottom]], b);
      };
      a.prototype.renderLine = function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      };
      a.prototype.getTitlePosition = function () {
        var b = this.horiz,
          f = this.left,
          d = this.top,
          a = this.len,
          e = this.options.title,
          h = b ? f : d,
          n = this.opposite,
          u = this.offset,
          q = e.x,
          g = e.y,
          z = this.axisTitle,
          k = this.chart.renderer.fontMetrics(e.style.fontSize, z);
        z = z ? Math.max(z.getBBox(!1, 0).height - k.h - 1, 0) : 0;
        a = {
          low: h + (b ? 0 : a),
          middle: h + a / 2,
          high: h + (b ? a : 0)
        }[e.align];
        f = (b ? d + this.height : f) + (b ? 1 : -1) * (n ? -1 : 1) * (this.axisTitleMargin || 0) + [-z, z, k.f, -z][this.side];
        b = {
          x: b ? a + q : f + (n ? this.width : 0) + u + q,
          y: b ? f + g - (n ? this.height : 0) + u : a + g
        };
        c(this, "afterGetTitlePosition", {
          titlePosition: b
        });
        return b;
      };
      a.prototype.renderMinorTick = function (b, c) {
        var f = this.minorTicks;
        f[b] || (f[b] = new H(this, b, "minor"));
        c && f[b].isNew && f[b].render(null, !0);
        f[b].render(null, !1, 1);
      };
      a.prototype.renderTick = function (b, c, f) {
        var d = this.ticks;
        if (!this.isLinked || b >= this.min && b <= this.max || this.grid && this.grid.isColumn) d[b] || (d[b] = new H(this, b)), f && d[b].isNew && d[b].render(c, !0, -1), d[b].render(c);
      };
      a.prototype.render = function () {
        var b = this,
          d = b.chart,
          a = b.logarithmic,
          e = b.options,
          h = b.isLinked,
          n = b.tickPositions,
          u = b.axisTitle,
          q = b.ticks,
          g = b.minorTicks,
          k = b.alternateBands,
          w = e.stackLabels,
          m = e.alternateGridColor,
          l = b.tickmarkOffset,
          p = b.axisLine,
          N = b.showAxis,
          J = r(d.renderer.globalAnimation),
          y,
          O;
        b.labelEdge.length = 0;
        b.overlap = !1;
        [q, g, k].forEach(function (b) {
          z(b, function (b) {
            b.isActive = !1;
          });
        });
        if (b.hasData() || h) {
          var D = b.chart.hasRendered && b.old && f(b.old.min);
          b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (c) {
            b.renderMinorTick(c, D);
          });
          n.length && (n.forEach(function (c, f) {
            b.renderTick(c, f, D);
          }), l && (0 === b.min || b.single) && (q[-1] || (q[-1] = new H(b, -1, null, !0)), q[-1].render(-1)));
          m && n.forEach(function (c, f) {
            O = "undefined" !== typeof n[f + 1] ? n[f + 1] + l : b.max - l;
            0 === f % 2 && c < b.max && O <= b.max + (d.polar ? -l : l) && (k[c] || (k[c] = new B.PlotLineOrBand(b)), y = c + l, k[c].options = {
              from: a ? a.lin2log(y) : y,
              to: a ? a.lin2log(O) : O,
              color: m,
              className: "highcharts-alternate-grid"
            }, k[c].render(), k[c].isActive = !0);
          });
          b._addedPlotLB || (b._addedPlotLB = !0, (e.plotLines || []).concat(e.plotBands || []).forEach(function (c) {
            b.addPlotBandOrLine(c);
          }));
        }
        [q, g, k].forEach(function (b) {
          var c = [],
            f = J.duration;
          z(b, function (b, f) {
            b.isActive || (b.render(f, !1, 0), b.isActive = !1, c.push(f));
          });
          Q(function () {
            for (var f = c.length; f--;) b[c[f]] && !b[c[f]].isActive && (b[c[f]].destroy(), delete b[c[f]]);
          }, b !== k && d.hasRendered && f ? f : 0);
        });
        p && (p[p.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(p.strokeWidth())
        }), p.isPlaced = !0, p[N ? "show" : "hide"](N));
        u && N && (e = b.getTitlePosition(), u[u.isNew ? "attr" : "animate"](e), u.isNew = !1);
        w && w.enabled && b.stacking && b.stacking.renderStackTotals();
        b.old = {
          len: b.len,
          max: b.max,
          min: b.min,
          transA: b.transA,
          userMax: b.userMax,
          userMin: b.userMin
        };
        b.isDirty = !1;
        c(this, "afterRender");
      };
      a.prototype.redraw = function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
          b.render();
        }));
        this.series.forEach(function (b) {
          b.isDirty = !0;
        });
      };
      a.prototype.getKeepProps = function () {
        return this.keepProps || a.keepProps;
      };
      a.prototype.destroy = function (b) {
        var f = this,
          d = f.plotLinesAndBands,
          a = this.eventOptions;
        c(this, "destroy", {
          keepEvents: b
        });
        b || J(f);
        [f.ticks, f.minorTicks, f.alternateBands].forEach(function (b) {
          I(b);
        });
        if (d) for (b = d.length; b--;) d[b].destroy();
        "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
          f[b] && (f[b] = f[b].destroy());
        });
        for (var e in f.plotLinesAndBandsGroups) f.plotLinesAndBandsGroups[e] = f.plotLinesAndBandsGroups[e].destroy();
        z(f, function (b, c) {
          -1 === f.getKeepProps().indexOf(c) && delete f[c];
        });
        this.eventOptions = a;
      };
      a.prototype.drawCrosshair = function (b, f) {
        var d = this.crosshair,
          a = q(d && d.snap, !0),
          e = this.chart,
          h,
          n = this.cross;
        c(this, "drawCrosshair", {
          e: b,
          point: f
        });
        b || (b = this.cross && this.cross.e);
        if (d && !1 !== (D(f) || !a)) {
          a ? D(f) && (h = q("colorAxis" !== this.coll ? f.crosshairPos : null, this.isXAxis ? f.plotX : this.len - f.plotY)) : h = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);
          if (D(h)) {
            var u = {
              value: f && (this.isXAxis ? f.x : q(f.stackY, f.y)),
              translatedValue: h
            };
            e.polar && y(u, {
              isCrosshair: !0,
              chartX: b && b.chartX,
              chartY: b && b.chartY,
              point: f
            });
            u = this.getPlotLinePath(u) || null;
          }
          if (!D(u)) {
            this.hideCrosshair();
            return;
          }
          a = this.categories && !this.isRadial;
          n || (this.cross = n = e.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a ? "category " : "thin ") + (d.className || "")).attr({
            zIndex: q(d.zIndex, 2)
          }).add(), e.styledMode || (n.attr({
            stroke: d.color || (a ? x.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": q(d.width, 1)
          }).css({
            "pointer-events": "none"
          }), d.dashStyle && n.attr({
            dashstyle: d.dashStyle
          })));
          n.show().attr({
            d: u
          });
          a && !d.width && n.attr({
            "stroke-width": this.transA
          });
          this.cross.e = b;
        } else this.hideCrosshair();
        c(this, "afterDrawCrosshair", {
          e: b,
          point: f
        });
      };
      a.prototype.hideCrosshair = function () {
        this.cross && this.cross.hide();
        c(this, "afterHideCrosshair");
      };
      a.prototype.hasVerticalPanning = function () {
        var b = this.chart.options.chart.panning;
        return !!(b && b.enabled && /y/.test(b.type));
      };
      a.prototype.validatePositiveValue = function (b) {
        return f(b) && 0 < b;
      };
      a.prototype.update = function (c, f) {
        var d = this.chart;
        c = b(this.userOptions, c);
        this.destroy(!0);
        this.init(d, c);
        d.isDirtyBox = !0;
        q(f, !0) && d.redraw();
      };
      a.prototype.remove = function (b) {
        for (var c = this.chart, f = this.coll, d = this.series, a = d.length; a--;) d[a] && d[a].remove(!1);
        E(c.axes, this);
        E(c[f], this);
        c[f].forEach(function (b, c) {
          b.options.index = b.userOptions.index = c;
        });
        this.destroy();
        c.isDirtyBox = !0;
        q(b, !0) && c.redraw();
      };
      a.prototype.setTitle = function (b, c) {
        this.update({
          title: b
        }, c);
      };
      a.prototype.setCategories = function (b, c) {
        this.update({
          categories: b
        }, c);
      };
      a.defaultOptions = g.defaultXAxisOptions;
      a.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
      return a;
    }();
    "";
    return a;
  });
  K(g, "Core/Axis/DateTimeAxis.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.addEvent,
      x = a.getMagnitude,
      F = a.normalizeTickInterval,
      C = a.timeUnits,
      B;
    (function (a) {
      function t() {
        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
      }
      function r(d) {
        "datetime" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new e(this));
      }
      var l = [];
      a.compose = function (d) {
        -1 === l.indexOf(d) && (l.push(d), d.keepProps.push("dateTime"), d.prototype.getTimeTicks = t, g(d, "init", r));
        return d;
      };
      var e = function () {
        function d(d) {
          this.axis = d;
        }
        d.prototype.normalizeTimeTickInterval = function (d, a) {
          var e = a || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
          a = e[e.length - 1];
          var h = C[a[0]],
            g = a[1],
            m;
          for (m = 0; m < e.length && !(a = e[m], h = C[a[0]], g = a[1], e[m + 1] && d <= (h * g[g.length - 1] + C[e[m + 1][0]]) / 2); m++);
          h === C.year && d < 5 * h && (g = [1, 2, 5]);
          d = F(d / h, g, "year" === a[0] ? Math.max(x(d / h), 1) : 1);
          return {
            unitRange: h,
            count: d,
            unitName: a[0]
          };
        };
        d.prototype.getXDateFormat = function (d, a) {
          var e = this.axis,
            h = e.chart.time;
          return e.closestPointRange ? h.getDateFormat(e.closestPointRange, d, e.options.startOfWeek, a) || h.resolveDTLFormat(a.year).main : h.resolveDTLFormat(a.day).main;
        };
        return d;
      }();
      a.Additions = e;
    })(B || (B = {}));
    return B;
  });
  K(g, "Core/Axis/LogarithmicAxis.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.addEvent,
      x = a.normalizeTickInterval,
      F = a.pick,
      C;
    (function (a) {
      function A(a) {
        var d = this.logarithmic;
        "logarithmic" !== a.userOptions.type ? this.logarithmic = void 0 : d || (this.logarithmic = new l(this));
      }
      function t() {
        var a = this.logarithmic;
        a && (this.lin2val = function (d) {
          return a.lin2log(d);
        }, this.val2lin = function (d) {
          return a.log2lin(d);
        });
      }
      var r = [];
      a.compose = function (a) {
        -1 === r.indexOf(a) && (r.push(a), a.keepProps.push("logarithmic"), g(a, "init", A), g(a, "afterInit", t));
        return a;
      };
      var l = function () {
        function a(d) {
          this.axis = d;
        }
        a.prototype.getLogTickPositions = function (d, a, e, g) {
          var h = this.axis,
            k = h.len,
            m = h.options,
            l = [];
          g || (this.minorAutoInterval = void 0);
          if (.5 <= d) d = Math.round(d), l = h.getLinearTickPositions(d, a, e);else if (.08 <= d) {
            var r = Math.floor(a),
              y,
              c = m = void 0;
            for (k = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; r < e + 1 && !c; r++) {
              var w = k.length;
              for (y = 0; y < w && !c; y++) {
                var f = this.log2lin(this.lin2log(r) * k[y]);
                f > a && (!g || m <= e) && "undefined" !== typeof m && l.push(m);
                m > e && (c = !0);
                m = f;
              }
            }
          } else a = this.lin2log(a), e = this.lin2log(e), d = g ? h.getMinorTickInterval() : m.tickInterval, d = F("auto" === d ? null : d, this.minorAutoInterval, m.tickPixelInterval / (g ? 5 : 1) * (e - a) / ((g ? k / h.tickPositions.length : k) || 1)), d = x(d), l = h.getLinearTickPositions(d, a, e).map(this.log2lin), g || (this.minorAutoInterval = d / 5);
          g || (h.tickInterval = d);
          return l;
        };
        a.prototype.lin2log = function (d) {
          return Math.pow(10, d);
        };
        a.prototype.log2lin = function (d) {
          return Math.log(d) / Math.LN10;
        };
        return a;
      }();
      a.Additions = l;
    })(C || (C = {}));
    return C;
  });
  K(g, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.erase,
      x = a.extend,
      F = a.isNumber,
      C;
    (function (a) {
      var A = [],
        t;
      a.compose = function (a, e) {
        t || (t = a);
        -1 === A.indexOf(e) && (A.push(e), x(e.prototype, r.prototype));
        return e;
      };
      var r = function () {
        function a() {}
        a.prototype.getPlotBandPath = function (a, d, h) {
          void 0 === h && (h = this.options);
          var e = this.getPlotLinePath({
              value: d,
              force: !0,
              acrossPanes: h.acrossPanes
            }),
            g = [],
            l = this.horiz;
          d = !F(this.min) || !F(this.max) || a < this.min && d < this.min || a > this.max && d > this.max;
          a = this.getPlotLinePath({
            value: a,
            force: !0,
            acrossPanes: h.acrossPanes
          });
          h = 1;
          if (a && e) {
            if (d) {
              var r = a.toString() === e.toString();
              h = 0;
            }
            for (d = 0; d < a.length; d += 2) {
              var t = a[d],
                E = a[d + 1],
                A = e[d],
                y = e[d + 1];
              "M" !== t[0] && "L" !== t[0] || "M" !== E[0] && "L" !== E[0] || "M" !== A[0] && "L" !== A[0] || "M" !== y[0] && "L" !== y[0] || (l && A[1] === t[1] ? (A[1] += h, y[1] += h) : l || A[2] !== t[2] || (A[2] += h, y[2] += h), g.push(["M", t[1], t[2]], ["L", E[1], E[2]], ["L", y[1], y[2]], ["L", A[1], A[2]], ["Z"]));
              g.isFlat = r;
            }
          }
          return g;
        };
        a.prototype.addPlotBand = function (a) {
          return this.addPlotBandOrLine(a, "plotBands");
        };
        a.prototype.addPlotLine = function (a) {
          return this.addPlotBandOrLine(a, "plotLines");
        };
        a.prototype.addPlotBandOrLine = function (a, d) {
          var e = this,
            g = this.userOptions,
            k = new t(this, a);
          this.visible && (k = k.render());
          if (k) {
            this._addedPlotLB || (this._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {
              e.addPlotBandOrLine(a);
            }));
            if (d) {
              var l = g[d] || [];
              l.push(a);
              g[d] = l;
            }
            this.plotLinesAndBands.push(k);
          }
          return k;
        };
        a.prototype.removePlotBandOrLine = function (a) {
          var d = this.plotLinesAndBands,
            e = this.options,
            m = this.userOptions;
          if (d) {
            for (var k = d.length; k--;) d[k].id === a && d[k].destroy();
            [e.plotLines || [], m.plotLines || [], e.plotBands || [], m.plotBands || []].forEach(function (d) {
              for (k = d.length; k--;) (d[k] || {}).id === a && g(d, d[k]);
            });
          }
        };
        a.prototype.removePlotBand = function (a) {
          this.removePlotBandOrLine(a);
        };
        a.prototype.removePlotLine = function (a) {
          this.removePlotBandOrLine(a);
        };
        return a;
      }();
    })(C || (C = {}));
    return C;
  });
  K(g, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [g["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = g.arrayMax,
      F = g.arrayMin,
      C = g.defined,
      B = g.destroyObjectProperties,
      H = g.erase,
      t = g.fireEvent,
      r = g.merge,
      l = g.objectEach,
      e = g.pick;
    g = function () {
      function d(a, d) {
        this.axis = a;
        d && (this.options = d, this.id = d.id);
      }
      d.compose = function (e) {
        return a.compose(d, e);
      };
      d.prototype.render = function () {
        t(this, "render");
        var a = this,
          d = a.axis,
          g = d.horiz,
          p = d.logarithmic,
          D = a.options,
          I = D.color,
          E = e(D.zIndex, 0),
          A = D.events,
          y = {},
          c = d.chart.renderer,
          w = D.label,
          f = a.label,
          n = D.to,
          b = D.from,
          u = D.value,
          z = a.svgElem,
          q = [],
          N = C(b) && C(n);
        q = C(u);
        var J = !z,
          O = {
            "class": "highcharts-plot-" + (N ? "band " : "line ") + (D.className || "")
          },
          Q = N ? "bands" : "lines";
        p && (b = p.log2lin(b), n = p.log2lin(n), u = p.log2lin(u));
        d.chart.styledMode || (q ? (O.stroke = I || "#999999", O["stroke-width"] = e(D.width, 1), D.dashStyle && (O.dashstyle = D.dashStyle)) : N && (O.fill = I || "#e6ebf5", D.borderWidth && (O.stroke = D.borderColor, O["stroke-width"] = D.borderWidth)));
        y.zIndex = E;
        Q += "-" + E;
        (p = d.plotLinesAndBandsGroups[Q]) || (d.plotLinesAndBandsGroups[Q] = p = c.g("plot-" + Q).attr(y).add());
        J && (a.svgElem = z = c.path().attr(O).add(p));
        if (q) q = d.getPlotLinePath({
          value: u,
          lineWidth: z.strokeWidth(),
          acrossPanes: D.acrossPanes
        });else if (N) q = d.getPlotBandPath(b, n, D);else return;
        !a.eventsAdded && A && (l(A, function (b, c) {
          z.on(c, function (b) {
            A[c].apply(a, [b]);
          });
        }), a.eventsAdded = !0);
        (J || !z.d) && q && q.length ? z.attr({
          d: q
        }) : z && (q ? (z.show(), z.animate({
          d: q
        })) : z.d && (z.hide(), f && (a.label = f = f.destroy())));
        w && (C(w.text) || C(w.formatter)) && q && q.length && 0 < d.width && 0 < d.height && !q.isFlat ? (w = r({
          align: g && N && "center",
          x: g ? !N && 4 : 10,
          verticalAlign: !g && N && "middle",
          y: g ? N ? 16 : 10 : N ? 6 : -4,
          rotation: g && !N && 90
        }, w), this.renderLabel(w, q, N, E)) : f && f.hide();
        return a;
      };
      d.prototype.renderLabel = function (a, d, e, g) {
        var h = this.axis,
          k = h.chart.renderer,
          m = this.label;
        m || (this.label = m = k.text(this.getLabelText(a), 0, 0, a.useHTML).attr({
          align: a.textAlign || a.align,
          rotation: a.rotation,
          "class": "highcharts-plot-" + (e ? "band" : "line") + "-label " + (a.className || ""),
          zIndex: g
        }).add(), h.chart.styledMode || m.css(r({
          textOverflow: "ellipsis"
        }, a.style)));
        g = d.xBounds || [d[0][1], d[1][1], e ? d[2][1] : d[0][1]];
        d = d.yBounds || [d[0][2], d[1][2], e ? d[2][2] : d[0][2]];
        e = F(g);
        k = F(d);
        m.align(a, !1, {
          x: e,
          y: k,
          width: A(g) - e,
          height: A(d) - k
        });
        m.alignValue && "left" !== m.alignValue || (a = a.clip ? h.width : h.chart.chartWidth, m.css({
          width: (90 === m.rotation ? h.height - (m.alignAttr.y - h.top) : a - (m.alignAttr.x - h.left)) + "px"
        }));
        m.show(!0);
      };
      d.prototype.getLabelText = function (a) {
        return C(a.formatter) ? a.formatter.call(this) : a.text;
      };
      d.prototype.destroy = function () {
        H(this.axis.plotLinesAndBands, this);
        delete this.axis;
        B(this);
      };
      return d;
    }();
    "";
    "";
    return g;
  });
  K(g, "Core/Tooltip.js", [g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F, C) {
    var A = a.format,
      H = g.doc,
      t = x.distribute,
      r = C.clamp,
      l = C.css,
      e = C.discardElement,
      d = C.extend,
      h = C.fireEvent,
      m = C.isArray,
      k = C.isNumber,
      p = C.isString,
      D = C.merge,
      I = C.pick,
      E = C.splat,
      L = C.syncTimeout;
    a = function () {
      function a(c, a) {
        this.allowShared = !0;
        this.container = void 0;
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = c;
        this.init(c, a);
      }
      a.prototype.applyFilter = function () {
        var c = this.chart;
        c.renderer.definition({
          tagName: "filter",
          attributes: {
            id: "drop-shadow-" + c.index,
            opacity: .5
          },
          children: [{
            tagName: "feGaussianBlur",
            attributes: {
              "in": "SourceAlpha",
              stdDeviation: 1
            }
          }, {
            tagName: "feOffset",
            attributes: {
              dx: 1,
              dy: 1
            }
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              attributes: {
                type: "linear",
                slope: .3
              }
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              attributes: {
                "in": "SourceGraphic"
              }
            }]
          }]
        });
      };
      a.prototype.bodyFormatter = function (c) {
        return c.map(function (c) {
          var f = c.series.tooltipOptions;
          return (f[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, f[(c.point.formatPrefix || "point") + "Format"] || "");
        });
      };
      a.prototype.cleanSplit = function (c) {
        this.chart.series.forEach(function (a) {
          var f = a && a.tt;
          f && (!f.isActive || c ? a.tt = f.destroy() : f.isActive = !1);
        });
      };
      a.prototype.defaultFormatter = function (c) {
        var a = this.points || E(this);
        var f = [c.tooltipFooterHeaderFormatter(a[0])];
        f = f.concat(c.bodyFormatter(a));
        f.push(c.tooltipFooterHeaderFormatter(a[0], !0));
        return f;
      };
      a.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), e(this.container));
        C.clearTimeout(this.hideTimer);
        C.clearTimeout(this.tooltipTimeout);
      };
      a.prototype.getAnchor = function (c, a) {
        var f = this.chart,
          d = f.pointer,
          b = f.inverted,
          e = f.plotTop;
        f = f.plotLeft;
        c = E(c);
        c[0].series && c[0].series.yAxis && !c[0].series.yAxis.options.reversedStacks && (c = c.slice().reverse());
        if (this.followPointer && a) "undefined" === typeof a.chartX && (a = d.normalize(a)), c = [a.chartX - f, a.chartY - e];else if (c[0].tooltipPos) c = c[0].tooltipPos;else {
          var h = 0,
            g = 0;
          c.forEach(function (b) {
            if (b = b.pos(!0)) h += b[0], g += b[1];
          });
          h /= c.length;
          g /= c.length;
          this.shared && 1 < c.length && a && (b ? h = a.chartX : g = a.chartY);
          c = [h - f, g - e];
        }
        return c.map(Math.round);
      };
      a.prototype.getClassName = function (c, a, f) {
        var d = c.series,
          b = d.options;
        return [this.options.className, "highcharts-label", f && "highcharts-tooltip-header", a ? "highcharts-tooltip-box" : "highcharts-tooltip", !f && "highcharts-color-" + I(c.colorIndex, d.colorIndex), b && b.className].filter(p).join(" ");
      };
      a.prototype.getLabel = function () {
        var c = this,
          a = this.chart.styledMode,
          f = this.options,
          d = this.split && this.allowShared,
          b = f.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none"),
          e,
          h = this.chart.renderer;
        if (c.label) {
          var q = !c.label.hasClass("highcharts-label");
          (d && !q || !d && q) && c.destroy();
        }
        if (!this.label) {
          if (this.outside) {
            q = this.chart.options.chart.style;
            var k = F.getRendererType();
            this.container = e = g.doc.createElement("div");
            e.className = "highcharts-tooltip-container";
            l(e, {
              position: "absolute",
              top: "1px",
              pointerEvents: b,
              zIndex: Math.max(this.options.style.zIndex || 0, (q && q.zIndex || 0) + 3)
            });
            g.doc.body.appendChild(e);
            this.renderer = h = new k(e, 0, 0, q, void 0, void 0, h.styledMode);
          }
          d ? this.label = h.g("tooltip") : (this.label = h.label("", 0, 0, f.shape, void 0, void 0, f.useHTML, void 0, "tooltip").attr({
            padding: f.padding,
            r: f.borderRadius
          }), a || this.label.attr({
            fill: f.backgroundColor,
            "stroke-width": f.borderWidth
          }).css(f.style).css({
            pointerEvents: b
          }).shadow(f.shadow));
          a && f.shadow && (this.applyFilter(), this.label.attr({
            filter: "url(#drop-shadow-" + this.chart.index + ")"
          }));
          if (c.outside && !c.split) {
            var m = this.label,
              p = m.xSetter,
              y = m.ySetter;
            m.xSetter = function (b) {
              p.call(m, c.distance);
              e.style.left = b + "px";
            };
            m.ySetter = function (b) {
              y.call(m, c.distance);
              e.style.top = b + "px";
            };
          }
          this.label.attr({
            zIndex: 8
          }).add();
        }
        return this.label;
      };
      a.prototype.getPosition = function (c, a, f) {
        var d = this.chart,
          b = this.distance,
          e = {},
          h = d.inverted && f.h || 0,
          g = this.outside,
          k = g ? H.documentElement.clientWidth - 2 * b : d.chartWidth,
          w = g ? Math.max(H.body.scrollHeight, H.documentElement.scrollHeight, H.body.offsetHeight, H.documentElement.offsetHeight, H.documentElement.clientHeight) : d.chartHeight,
          m = d.pointer.getChartPosition(),
          l = function (e) {
            var h = "x" === e;
            return [e, h ? k : w, h ? c : a].concat(g ? [h ? c * m.scaleX : a * m.scaleY, h ? m.left - b + (f.plotX + d.plotLeft) * m.scaleX : m.top - b + (f.plotY + d.plotTop) * m.scaleY, 0, h ? k : w] : [h ? c : a, h ? f.plotX + d.plotLeft : f.plotY + d.plotTop, h ? d.plotLeft : d.plotTop, h ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);
          },
          p = l("y"),
          y = l("x"),
          v;
        l = !!f.negative;
        !d.polar && d.hoverSeries && d.hoverSeries.yAxis && d.hoverSeries.yAxis.reversed && (l = !l);
        var r = !this.followPointer && I(f.ttBelow, !d.inverted === l),
          t = function (c, f, a, d, n, u, q) {
            var z = g ? "y" === c ? b * m.scaleY : b * m.scaleX : b,
              k = (a - d) / 2,
              w = d < n - b,
              G = n + b + d < f,
              l = n - z - a + k;
            n = n + z - k;
            if (r && G) e[c] = n;else if (!r && w) e[c] = l;else if (w) e[c] = Math.min(q - d, 0 > l - h ? l : l - h);else if (G) e[c] = Math.max(u, n + h + a > f ? n : n + h);else return !1;
          },
          D = function (c, f, a, d, h) {
            var n;
            h < b || h > f - b ? n = !1 : e[c] = h < a / 2 ? 1 : h > f - d / 2 ? f - d - 2 : h - a / 2;
            return n;
          },
          E = function (b) {
            var c = p;
            p = y;
            y = c;
            v = b;
          },
          G = function () {
            !1 !== t.apply(0, p) ? !1 !== D.apply(0, y) || v || (E(!0), G()) : v ? e.x = e.y = 0 : (E(!0), G());
          };
        (d.inverted || 1 < this.len) && E();
        G();
        return e;
      };
      a.prototype.hide = function (c) {
        var a = this;
        C.clearTimeout(this.hideTimer);
        c = I(c, this.options.hideDelay);
        this.isHidden || (this.hideTimer = L(function () {
          a.getLabel().fadeOut(c ? void 0 : c);
          a.isHidden = !0;
        }, c));
      };
      a.prototype.init = function (c, a) {
        this.chart = c;
        this.options = a;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = a.split && !c.inverted && !c.polar;
        this.shared = a.shared || this.split;
        this.outside = I(a.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
      };
      a.prototype.shouldStickOnContact = function (c) {
        return !(this.followPointer || !this.options.stickOnContact || c && !this.chart.pointer.inClass(c.target, "highcharts-tooltip"));
      };
      a.prototype.move = function (c, a, f, e) {
        var b = this,
          h = b.now,
          n = !1 !== b.options.animation && !b.isHidden && (1 < Math.abs(c - h.x) || 1 < Math.abs(a - h.y)),
          g = b.followPointer || 1 < b.len;
        d(h, {
          x: n ? (2 * h.x + c) / 3 : c,
          y: n ? (h.y + a) / 2 : a,
          anchorX: g ? void 0 : n ? (2 * h.anchorX + f) / 3 : f,
          anchorY: g ? void 0 : n ? (h.anchorY + e) / 2 : e
        });
        b.getLabel().attr(h);
        b.drawTracker();
        n && (C.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          b && b.move(c, a, f, e);
        }, 32));
      };
      a.prototype.refresh = function (c, a) {
        var f = this.chart,
          d = this.options,
          b = f.pointer,
          e = E(c),
          g = e[0],
          q = [],
          k = d.formatter || this.defaultFormatter,
          w = this.shared,
          l = f.styledMode,
          p = {};
        if (d.enabled && g.series) {
          C.clearTimeout(this.hideTimer);
          this.allowShared = !(!m(c) && c.series && c.series.noSharedTooltip);
          this.followPointer = !this.split && g.series.tooltipOptions.followPointer;
          c = this.getAnchor(c, a);
          var y = c[0],
            r = c[1];
          w && this.allowShared ? (b.applyInactiveState(e), e.forEach(function (b) {
            b.setState("hover");
            q.push(b.getLabelConfig());
          }), p = {
            x: g.category,
            y: g.y
          }, p.points = q) : p = g.getLabelConfig();
          this.len = q.length;
          k = k.call(p, this);
          w = g.series;
          this.distance = I(w.tooltipOptions.distance, 16);
          if (!1 === k) this.hide();else {
            if (this.split && this.allowShared) this.renderSplit(k, e);else {
              var v = y,
                t = r;
              a && b.isDirectTouch && (v = a.chartX - f.plotLeft, t = a.chartY - f.plotTop);
              if (f.polar || !1 === w.options.clip || e.some(function (c) {
                return b.isDirectTouch || c.series.shouldShowTooltip(v, t);
              })) a = this.getLabel(), d.style.width && !l || a.css({
                width: f.spacingBox.width + "px"
              }), a.attr({
                text: k && k.join ? k.join("") : k
              }), a.addClass(this.getClassName(g), !0), l || a.attr({
                stroke: d.borderColor || g.color || w.color || "#666666"
              }), this.updatePosition({
                plotX: y,
                plotY: r,
                negative: g.negative,
                ttBelow: g.ttBelow,
                h: c[2] || 0
              });else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({
              opacity: 1
            }).show();
            this.isHidden = !1;
          }
          h(this, "refresh");
        }
      };
      a.prototype.renderSplit = function (c, a) {
        function f(b, c, a, f, d) {
          void 0 === d && (d = !0);
          a ? (c = R ? 0 : ba, b = r(b - f / 2, P.left, P.right - f - (e.outside ? V : 0))) : (c -= Z, b = d ? b - f - x : b + x, b = r(b, d ? b : P.left, P.right));
          return {
            x: b,
            y: c
          };
        }
        var e = this,
          b = e.chart,
          h = e.chart,
          g = h.chartWidth,
          q = h.chartHeight,
          k = h.plotHeight,
          w = h.plotLeft,
          m = h.plotTop,
          l = h.pointer,
          y = h.scrollablePixelsY;
        y = void 0 === y ? 0 : y;
        var D = h.scrollablePixelsX,
          v = h.scrollingContainer;
        v = void 0 === v ? {
          scrollLeft: 0,
          scrollTop: 0
        } : v;
        var E = v.scrollLeft;
        v = v.scrollTop;
        var A = h.styledMode,
          x = e.distance,
          L = e.options,
          G = e.options.positioner,
          P = e.outside && "number" !== typeof D ? H.documentElement.getBoundingClientRect() : {
            left: E,
            right: E + g,
            top: v,
            bottom: v + q
          },
          M = e.getLabel(),
          X = this.renderer || b.renderer,
          R = !(!b.xAxis[0] || !b.xAxis[0].opposite);
        b = l.getChartPosition();
        var V = b.left;
        b = b.top;
        var Z = m + v,
          C = 0,
          ba = k - y;
        p(c) && (c = [!1, c]);
        c = c.slice(0, a.length + 1).reduce(function (b, c, d) {
          if (!1 !== c && "" !== c) {
            d = a[d - 1] || {
              isHeader: !0,
              plotX: a[0].plotX,
              plotY: k,
              series: {}
            };
            var h = d.isHeader,
              n = h ? e : d.series;
            c = c.toString();
            var g = n.tt,
              u = d.isHeader;
            var q = d.series;
            g || (g = {
              padding: L.padding,
              r: L.borderRadius
            }, A || (g.fill = L.backgroundColor, g["stroke-width"] = L.borderWidth), g = X.label("", 0, 0, L[u ? "headerShape" : "shape"], void 0, void 0, L.useHTML).addClass(e.getClassName(d, !0, u)).attr(g).add(M));
            g.isActive = !0;
            g.attr({
              text: c
            });
            A || g.css(L.style).shadow(L.shadow).attr({
              stroke: L.borderColor || d.color || q.color || "#333333"
            });
            n = n.tt = g;
            u = n.getBBox();
            c = u.width + n.strokeWidth();
            h && (C = u.height, ba += C, R && (Z -= C));
            q = d.plotX;
            q = void 0 === q ? 0 : q;
            g = d.plotY;
            g = void 0 === g ? 0 : g;
            var z = d.series;
            if (d.isHeader) {
              q = w + q;
              var l = m + k / 2;
            } else {
              var v = z.xAxis,
                p = z.yAxis;
              q = v.pos + r(q, -x, v.len + x);
              z.shouldShowTooltip(0, p.pos - m + g, {
                ignoreX: !0
              }) && (l = p.pos + g);
            }
            q = r(q, P.left - x, P.right + x);
            "number" === typeof l ? (u = u.height + 1, g = G ? G.call(e, c, u, d) : f(q, l, h, c), b.push({
              align: G ? 0 : void 0,
              anchorX: q,
              anchorY: l,
              boxWidth: c,
              point: d,
              rank: I(g.rank, h ? 1 : 0),
              size: u,
              target: g.y,
              tt: n,
              x: g.x
            })) : n.isActive = !1;
          }
          return b;
        }, []);
        !G && c.some(function (b) {
          var c = (e.outside ? V : 0) + b.anchorX;
          return c < P.left && c + b.boxWidth < P.right ? !0 : c < V - P.left + b.boxWidth && P.right - c > c;
        }) && (c = c.map(function (b) {
          var c = f(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return d(b, {
            target: c.y,
            x: c.x
          });
        }));
        e.cleanSplit();
        t(c, ba);
        var B = V,
          F = V;
        c.forEach(function (b) {
          var c = b.x,
            a = b.boxWidth;
          b = b.isHeader;
          b || (e.outside && V + c < B && (B = V + c), !b && e.outside && B + a > F && (F = V + c));
        });
        c.forEach(function (b) {
          var c = b.x,
            a = b.anchorX,
            f = b.pos,
            d = b.point.isHeader;
          f = {
            visibility: "undefined" === typeof f ? "hidden" : "inherit",
            x: c,
            y: (f || 0) + Z,
            anchorX: a,
            anchorY: b.anchorY
          };
          if (e.outside && c < a) {
            var h = V - B;
            0 < h && (d || (f.x = c + h, f.anchorX = a + h), d && (f.x = (F - B) / 2, f.anchorX = a + h));
          }
          b.tt.attr(f);
        });
        c = e.container;
        y = e.renderer;
        e.outside && c && y && (h = M.getBBox(), y.setSize(h.width + h.x, h.height + h.y, !1), c.style.left = B + "px", c.style.top = b + "px");
      };
      a.prototype.drawTracker = function () {
        if (this.shouldStickOnContact()) {
          var c = this.chart,
            a = this.label,
            f = this.shared ? c.hoverPoints : c.hoverPoint;
          if (a && f) {
            var d = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            f = this.getAnchor(f);
            var b = a.getBBox();
            f[0] += c.plotLeft - a.translateX;
            f[1] += c.plotTop - a.translateY;
            d.x = Math.min(0, f[0]);
            d.y = Math.min(0, f[1]);
            d.width = 0 > f[0] ? Math.max(Math.abs(f[0]), b.width - f[0]) : Math.max(Math.abs(f[0]), b.width);
            d.height = 0 > f[1] ? Math.max(Math.abs(f[1]), b.height - Math.abs(f[1])) : Math.max(Math.abs(f[1]), b.height);
            this.tracker ? this.tracker.attr(d) : (this.tracker = a.renderer.rect(d).addClass("highcharts-tracker").add(a), c.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        } else this.tracker && this.tracker.destroy();
      };
      a.prototype.styledModeFormat = function (c) {
        return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
      };
      a.prototype.tooltipFooterHeaderFormatter = function (c, a) {
        var f = c.series,
          d = f.tooltipOptions,
          b = f.xAxis,
          e = b && b.dateTime;
        b = {
          isFooter: a,
          labelConfig: c
        };
        var g = d.xDateFormat,
          q = d[a ? "footerFormat" : "headerFormat"];
        h(this, "headerFormatter", b, function (b) {
          e && !g && k(c.key) && (g = e.getXDateFormat(c.key, d.dateTimeLabelFormats));
          e && g && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (b) {
            q = q.replace("{point." + b + "}", "{point." + b + ":" + g + "}");
          });
          f.chart.styledMode && (q = this.styledModeFormat(q));
          b.text = A(q, {
            point: c,
            series: f
          }, this.chart);
        });
        return b.text;
      };
      a.prototype.update = function (c) {
        this.destroy();
        D(!0, this.chart.options.tooltip.userOptions, c);
        this.init(this.chart, D(!0, this.options, c));
      };
      a.prototype.updatePosition = function (c) {
        var a = this.chart,
          f = this.distance,
          d = this.options,
          b = a.pointer,
          e = this.getLabel(),
          h = b.getChartPosition();
        b = h.left;
        var g = h.top,
          k = h.scaleX;
        h = h.scaleY;
        var m = (d.positioner || this.getPosition).call(this, e.width, e.height, c),
          p = (c.plotX || 0) + a.plotLeft;
        c = (c.plotY || 0) + a.plotTop;
        if (this.outside) {
          d.positioner && (m.x += b - f, m.y += g - f);
          f = d.borderWidth + 2 * f;
          this.renderer.setSize(e.width + f, e.height + f, !1);
          if (1 !== k || 1 !== h) l(this.container, {
            transform: "scale(".concat(k, ", ").concat(h, ")")
          }), p *= k, c *= h;
          p += b - m.x;
          c += g - m.y;
        }
        this.move(Math.round(m.x), Math.round(m.y || 0), p, c);
      };
      return a;
    }();
    "";
    return a;
  });
  K(g, "Core/Series/Point.js", [g["Core/Renderer/HTML/AST.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/Defaults.js"], g["Core/FormatUtilities.js"], g["Core/Utilities.js"]], function (a, g, x, F, C) {
    var A = g.animObject,
      H = x.defaultOptions,
      t = F.format,
      r = C.addEvent,
      l = C.defined,
      e = C.erase,
      d = C.extend,
      h = C.fireEvent,
      m = C.getNestedProperty,
      k = C.isArray,
      p = C.isFunction,
      D = C.isNumber,
      I = C.isObject,
      E = C.merge,
      L = C.objectEach,
      y = C.pick,
      c = C.syncTimeout,
      w = C.removeEvent,
      f = C.uniqueKey;
    g = function () {
      function g() {
        this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.shapeArgs = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }
      g.prototype.animateBeforeDestroy = function () {
        var b = this,
          c = {
            x: b.startXPos,
            opacity: 0
          },
          a = b.getGraphicalProps();
        a.singular.forEach(function (a) {
          b[a] = b[a].animate("dataLabel" === a ? {
            x: b[a].startXPos,
            y: b[a].startYPos,
            opacity: 0
          } : c);
        });
        a.plural.forEach(function (c) {
          b[c].forEach(function (c) {
            c.element && c.animate(d({
              x: b.startXPos
            }, c.startYPos ? {
              x: c.startXPos,
              y: c.startYPos
            } : {}));
          });
        });
      };
      g.prototype.applyOptions = function (b, c) {
        var a = this.series,
          f = a.options.pointValKey || a.pointValKey;
        b = g.prototype.optionsToObject.call(this, b);
        d(this, b);
        this.options = this.options ? d(this.options, b) : b;
        b.group && delete this.group;
        b.dataLabels && delete this.dataLabels;
        f && (this.y = g.prototype.getNestedProperty.call(this, f));
        this.formatPrefix = (this.isNull = this.isValid && !this.isValid()) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof c && a.xAxis && a.xAxis.hasNames && (this.x = a.xAxis.nameToX(this));
        "undefined" === typeof this.x && a ? this.x = "undefined" === typeof c ? a.autoIncrement() : c : D(b.x) && a.options.relativeXValue && (this.x = a.autoIncrement(b.x));
        return this;
      };
      g.prototype.destroy = function () {
        function b() {
          if (a.graphic || a.graphics || a.dataLabel || a.dataLabels) w(a), a.destroyElements();
          for (n in a) a[n] = null;
        }
        var a = this,
          f = a.series,
          d = f.chart;
        f = f.options.dataSorting;
        var h = d.hoverPoints,
          g = A(a.series.chart.renderer.globalAnimation),
          n;
        a.legendItem && d.legend.destroyItem(a);
        h && (a.setState(), e(h, a), h.length || (d.hoverPoints = null));
        if (a === d.hoverPoint) a.onMouseOut();
        f && f.enabled ? (this.animateBeforeDestroy(), c(b, g.duration)) : b();
        d.pointCount--;
      };
      g.prototype.destroyElements = function (b) {
        var c = this;
        b = c.getGraphicalProps(b);
        b.singular.forEach(function (b) {
          c[b] = c[b].destroy();
        });
        b.plural.forEach(function (b) {
          c[b].forEach(function (b) {
            b && b.element && b.destroy();
          });
          delete c[b];
        });
      };
      g.prototype.firePointEvent = function (b, c, a) {
        var f = this,
          d = this.series.options;
        (d.point.events[b] || f.options && f.options.events && f.options.events[b]) && f.importEvents();
        "click" === b && d.allowPointSelect && (a = function (b) {
          f.select && f.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
        });
        h(f, b, c, a);
      };
      g.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };
      g.prototype.getGraphicalProps = function (b) {
        var c = this,
          a = [],
          f = {
            singular: [],
            plural: []
          },
          d;
        b = b || {
          graphic: 1,
          dataLabel: 1
        };
        b.graphic && a.push("graphic", "shadowGroup");
        b.dataLabel && a.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
        for (d = a.length; d--;) {
          var e = a[d];
          c[e] && f.singular.push(e);
        }
        ["graphic", "dataLabel", "connector"].forEach(function (a) {
          var d = a + "s";
          b[a] && c[d] && f.plural.push(d);
        });
        return f;
      };
      g.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };
      g.prototype.getNestedProperty = function (b) {
        if (b) return 0 === b.indexOf("custom.") ? m(b, this.options) : this[b];
      };
      g.prototype.getZone = function () {
        var b = this.series,
          c = b.zones;
        b = b.zoneAxis || "y";
        var a,
          f = 0;
        for (a = c[f]; this[b] >= a.value;) a = c[++f];
        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = a && a.color && !this.options.color ? a.color : this.nonZonedColor;
        return a;
      };
      g.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };
      g.prototype.init = function (b, c, a) {
        this.series = b;
        this.applyOptions(c, a);
        this.id = l(this.id) ? this.id : f();
        this.resolveColor();
        b.chart.pointCount++;
        h(this, "afterInit");
        return this;
      };
      g.prototype.isValid = function () {
        return null !== this.x && D(this.y);
      };
      g.prototype.optionsToObject = function (b) {
        var c = this.series,
          a = c.options.keys,
          f = a || c.pointArrayMap || ["y"],
          d = f.length,
          e = {},
          h = 0,
          n = 0;
        if (D(b) || null === b) e[f[0]] = b;else if (k(b)) for (!a && b.length > d && (c = typeof b[0], "string" === c ? e.name = b[0] : "number" === c && (e.x = b[0]), h++); n < d;) a && "undefined" === typeof b[h] || (0 < f[n].indexOf(".") ? g.prototype.setNestedProperty(e, b[h], f[n]) : e[f[n]] = b[h]), h++, n++;else "object" === typeof b && (e = b, b.dataLabels && (c._hasPointLabels = !0), b.marker && (c._hasPointMarkers = !0));
        return e;
      };
      g.prototype.pos = function (b, c) {
        void 0 === c && (c = this.plotY);
        var a = this.plotX,
          f = this.series,
          d = f.chart,
          e = f.xAxis;
        f = f.yAxis;
        var h = 0,
          g = 0;
        if (D(a) && D(c)) return b && (h = e ? e.pos : d.plotLeft, g = f ? f.pos : d.plotTop), d.inverted && e && f ? [f.len - c + g, e.len - a + h] : [a + h, c + g];
      };
      g.prototype.resolveColor = function () {
        var b = this.series,
          c = b.chart.styledMode;
        var a = b.chart.options.chart.colorCount;
        delete this.nonZonedColor;
        if (b.options.colorByPoint) {
          if (!c) {
            a = b.options.colors || b.chart.options.colors;
            var f = a[b.colorCounter];
            a = a.length;
          }
          c = b.colorCounter;
          b.colorCounter++;
          b.colorCounter === a && (b.colorCounter = 0);
        } else c || (f = b.color), c = b.colorIndex;
        this.colorIndex = y(this.options.colorIndex, c);
        this.color = y(this.options.color, f);
      };
      g.prototype.setNestedProperty = function (b, c, a) {
        a.split(".").reduce(function (b, a, f, d) {
          b[a] = d.length - 1 === f ? c : I(b[a], !0) ? b[a] : {};
          return b[a];
        }, b);
        return b;
      };
      g.prototype.shouldDraw = function () {
        return !this.isNull;
      };
      g.prototype.tooltipFormatter = function (b) {
        var c = this.series,
          a = c.tooltipOptions,
          f = y(a.valueDecimals, ""),
          d = a.valuePrefix || "",
          e = a.valueSuffix || "";
        c.chart.styledMode && (b = c.chart.tooltip.styledModeFormat(b));
        (c.pointArrayMap || ["y"]).forEach(function (c) {
          c = "{point." + c;
          if (d || e) b = b.replace(RegExp(c + "}", "g"), d + c + "}" + e);
          b = b.replace(RegExp(c + "}", "g"), c + ":,." + f + "f}");
        });
        return t(b, {
          point: this,
          series: this.series
        }, c.chart);
      };
      g.prototype.update = function (b, c, a, f) {
        function d() {
          e.applyOptions(b);
          var f = g && e.hasMockGraphic;
          f = null === e.y ? !f : f;
          g && f && (e.graphic = g.destroy(), delete e.hasMockGraphic);
          I(b, !0) && (g && g.element && b && b.marker && "undefined" !== typeof b.marker.symbol && (e.graphic = g.destroy()), b && b.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy()), e.connector && (e.connector = e.connector.destroy()));
          u = e.index;
          h.updateParallelArrays(e, u);
          q.data[u] = I(q.data[u], !0) || I(b, !0) ? e.options : y(b, q.data[u]);
          h.isDirty = h.isDirtyData = !0;
          !h.fixedBox && h.hasCartesianSeries && (n.isDirtyBox = !0);
          "point" === q.legendType && (n.isDirtyLegend = !0);
          c && n.redraw(a);
        }
        var e = this,
          h = e.series,
          g = e.graphic,
          n = h.chart,
          q = h.options,
          u;
        c = y(c, !0);
        !1 === f ? d() : e.firePointEvent("update", {
          options: b
        }, d);
      };
      g.prototype.remove = function (b, c) {
        this.series.removePoint(this.series.data.indexOf(this), b, c);
      };
      g.prototype.select = function (b, c) {
        var a = this,
          f = a.series,
          d = f.chart;
        this.selectedStaging = b = y(b, !a.selected);
        a.firePointEvent(b ? "select" : "unselect", {
          accumulate: c
        }, function () {
          a.selected = a.options.selected = b;
          f.options.data[f.data.indexOf(a)] = a.options;
          a.setState(b && "select");
          c || d.getSelectedPoints().forEach(function (b) {
            var c = b.series;
            b.selected && b !== a && (b.selected = b.options.selected = !1, c.options.data[c.data.indexOf(b)] = b.options, b.setState(d.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), b.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      };
      g.prototype.onMouseOver = function (b) {
        var c = this.series.chart,
          a = c.pointer;
        b = b ? a.normalize(b) : a.getChartCoordinatesFromPoint(this, c.inverted);
        a.runPointActions(b, this);
      };
      g.prototype.onMouseOut = function () {
        var b = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (b.hoverPoints || []).forEach(function (b) {
          b.setState();
        });
        b.hoverPoints = b.hoverPoint = null;
      };
      g.prototype.importEvents = function () {
        if (!this.hasImportedEvents) {
          var b = this,
            c = E(b.series.options.point, b.options).events;
          b.events = c;
          L(c, function (c, a) {
            p(c) && r(b, a, c);
          });
          this.hasImportedEvents = !0;
        }
      };
      g.prototype.setState = function (b, c) {
        var f = this.series,
          e = this.state,
          g = f.options.states[b || "normal"] || {},
          n = H.plotOptions[f.type].marker && f.options.marker,
          u = n && !1 === n.enabled,
          k = n && n.states && n.states[b || "normal"] || {},
          m = !1 === k.enabled,
          w = this.marker || {},
          l = f.chart,
          p = n && f.markerAttribs,
          r = f.halo,
          t,
          E = f.stateMarkerGraphic;
        b = b || "";
        if (!(b === this.state && !c || this.selected && "select" !== b || !1 === g.enabled || b && (m || u && !1 === k.enabled) || b && w.states && w.states[b] && !1 === w.states[b].enabled)) {
          this.state = b;
          p && (t = f.markerAttribs(this, b));
          if (this.graphic && !this.hasMockGraphic) {
            e && this.graphic.removeClass("highcharts-point-" + e);
            b && this.graphic.addClass("highcharts-point-" + b);
            if (!l.styledMode) {
              e = f.pointAttribs(this, b);
              var G = y(l.options.chart.animation, g.animation);
              var P = e.opacity;
              f.options.inactiveOtherPoints && D(P) && ((this.dataLabels || []).forEach(function (b) {
                b && !b.hasClass("highcharts-data-label-hidden") && b.animate({
                  opacity: P
                }, G);
              }), this.connector && this.connector.animate({
                opacity: P
              }, G));
              this.graphic.animate(e, G);
            }
            t && this.graphic.animate(t, y(l.options.chart.animation, k.animation, n.animation));
            E && E.hide();
          } else {
            if (b && k) {
              n = w.symbol || f.symbol;
              E && E.currentSymbol !== n && (E = E.destroy());
              if (t) if (E) E[c ? "animate" : "attr"]({
                x: t.x,
                y: t.y
              });else n && (f.stateMarkerGraphic = E = l.renderer.symbol(n, t.x, t.y, t.width, t.height).add(f.markerGroup), E.currentSymbol = n);
              !l.styledMode && E && "inactive" !== this.state && E.attr(f.pointAttribs(this, b));
            }
            E && (E[b && this.isInside ? "show" : "hide"](), E.element.point = this, E.addClass(this.getClassName(), !0));
          }
          g = g.halo;
          t = (E = this.graphic || E) && E.visibility || "inherit";
          g && g.size && E && "hidden" !== t && !this.isCluster ? (r || (f.halo = r = l.renderer.path().add(E.parentGroup)), r.show()[c ? "animate" : "attr"]({
            d: this.haloPath(g.size)
          }), r.attr({
            "class": "highcharts-halo highcharts-color-" + y(this.colorIndex, f.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: t,
            zIndex: -1
          }), r.point = this, l.styledMode || r.attr(d({
            fill: this.color || f.color,
            "fill-opacity": g.opacity
          }, a.filterUserAttributes(g.attributes || {})))) : r && r.point && r.point.haloPath && r.animate({
            d: r.point.haloPath(0)
          }, null, r.hide);
          h(this, "afterSetState", {
            state: b
          });
        }
      };
      g.prototype.haloPath = function (b) {
        var c = this.pos();
        return c ? this.series.chart.renderer.symbols.circle(Math.floor(c[0]) - b, c[1] - b, 2 * b, 2 * b) : [];
      };
      return g;
    }();
    "";
    return g;
  });
  K(g, "Core/Pointer.js", [g["Core/Color/Color.js"], g["Core/Globals.js"], g["Core/Tooltip.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = a.parse,
      B = g.charts,
      H = g.noop,
      t = F.addEvent,
      r = F.attr,
      l = F.css,
      e = F.defined,
      d = F.extend,
      h = F.find,
      m = F.fireEvent,
      k = F.isNumber,
      p = F.isObject,
      D = F.objectEach,
      I = F.offset,
      E = F.pick,
      L = F.splat;
    a = function () {
      function a(c, a) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.eventsToUnbind = [];
        this.chart = c;
        this.hasDragged = !1;
        this.options = a;
        this.init(c, a);
      }
      a.prototype.applyInactiveState = function (c) {
        var a = [],
          f;
        (c || []).forEach(function (c) {
          f = c.series;
          a.push(f);
          f.linkedParent && a.push(f.linkedParent);
          f.linkedSeries && (a = a.concat(f.linkedSeries));
          f.navigatorSeries && a.push(f.navigatorSeries);
        });
        this.chart.series.forEach(function (c) {
          -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
        });
      };
      a.prototype.destroy = function () {
        var c = this;
        this.eventsToUnbind.forEach(function (c) {
          return c();
        });
        this.eventsToUnbind = [];
        g.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        D(c, function (a, f) {
          c[f] = void 0;
        });
      };
      a.prototype.getSelectionMarkerAttrs = function (c, a) {
        var f = this,
          d = {
            args: {
              chartX: c,
              chartY: a
            },
            attrs: {},
            shapeType: "rect"
          };
        m(this, "getSelectionMarkerAttrs", d, function (b) {
          var d = f.chart,
            e = f.mouseDownX;
          e = void 0 === e ? 0 : e;
          var h = f.mouseDownY;
          h = void 0 === h ? 0 : h;
          var g = f.zoomHor,
            n = f.zoomVert;
          b = b.attrs;
          b.x = d.plotLeft;
          b.y = d.plotTop;
          b.width = g ? 1 : d.plotWidth;
          b.height = n ? 1 : d.plotHeight;
          g && (d = c - e, b.width = Math.abs(d), b.x = (0 < d ? 0 : d) + e);
          n && (d = a - h, b.height = Math.abs(d), b.y = (0 < d ? 0 : d) + h);
        });
        return d;
      };
      a.prototype.drag = function (c) {
        var a = this.chart,
          f = a.options.chart,
          d = a.plotLeft,
          b = a.plotTop,
          e = a.plotWidth,
          h = a.plotHeight,
          g = this.mouseDownX || 0,
          k = this.mouseDownY || 0,
          m = p(f.panning) ? f.panning && f.panning.enabled : f.panning,
          l = f.panKey && c[f.panKey + "Key"],
          y = c.chartX,
          r = c.chartY,
          t = this.selectionMarker;
        t && t.touch || (y < d ? y = d : y > d + e && (y = d + e), r < b ? r = b : r > b + h && (r = b + h), this.hasDragged = Math.sqrt(Math.pow(g - y, 2) + Math.pow(k - r, 2)), 10 < this.hasDragged && (d = a.isInsidePlot(g - d, k - b, {
          visiblePlotOnly: !0
        }), r = this.getSelectionMarkerAttrs(y, r), y = r.shapeType, r = r.attrs, !a.hasCartesianSeries && !a.mapView || !this.zoomX && !this.zoomY || !d || l || t || (this.selectionMarker = t = a.renderer[y](), t.attr({
          "class": "highcharts-selection-marker",
          zIndex: 7
        }).add(), a.styledMode || t.attr({
          fill: f.selectionMarkerFill || A("#335cad").setOpacity(.25).get()
        })), t && t.attr(r), d && !t && m && a.pan(c, f.panning)));
      };
      a.prototype.dragStart = function (c) {
        var a = this.chart;
        a.mouseIsDown = c.type;
        a.cancelClick = !1;
        a.mouseDownX = this.mouseDownX = c.chartX;
        a.mouseDownY = this.mouseDownY = c.chartY;
      };
      a.prototype.getSelectionBox = function (c) {
        var a = {
          args: {
            marker: c
          },
          result: {}
        };
        m(this, "getSelectionBox", a, function (a) {
          a.result = {
            x: c.attr ? +c.attr("x") : c.x,
            y: c.attr ? +c.attr("y") : c.y,
            width: c.attr ? c.attr("width") : c.width,
            height: c.attr ? c.attr("height") : c.height
          };
        });
        return a.result;
      };
      a.prototype.drop = function (c) {
        var a = this,
          f = this.chart,
          h = this.hasPinched;
        if (this.selectionMarker) {
          var b = this.getSelectionBox(this.selectionMarker),
            g = b.x,
            z = b.y,
            q = b.width,
            p = b.height,
            y = {
              originalEvent: c,
              xAxis: [],
              yAxis: [],
              x: g,
              y: z,
              width: q,
              height: p
            },
            r = !!f.mapView;
          if (this.hasDragged || h) f.axes.forEach(function (b) {
            if (b.zoomEnabled && e(b.min) && (h || a[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[b.coll]]) && k(g) && k(z) && k(q) && k(p)) {
              var f = b.horiz,
                d = "touchend" === c.type ? b.minPixelPadding : 0,
                n = b.toValue((f ? g : z) + d);
              f = b.toValue((f ? g + q : z + p) - d);
              y[b.coll].push({
                axis: b,
                min: Math.min(n, f),
                max: Math.max(n, f)
              });
              r = !0;
            }
          }), r && m(f, "selection", y, function (b) {
            f.zoom(d(b, h ? {
              animation: !1
            } : null));
          });
          k(f.index) && (this.selectionMarker = this.selectionMarker.destroy());
          h && this.scaleGroups();
        }
        f && k(f.index) && (l(f.container, {
          cursor: f._cursor
        }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };
      a.prototype.findNearestKDPoint = function (c, a, f) {
        var d;
        c.forEach(function (b) {
          var c = !(b.noSharedTooltip && a) && 0 > b.options.findNearestPointBy.indexOf("y");
          b = b.searchPoint(f, c);
          if ((c = p(b, !0) && b.series) && !(c = !p(d, !0))) {
            c = d.distX - b.distX;
            var e = d.dist - b.dist,
              h = (b.series.group && b.series.group.zIndex) - (d.series.group && d.series.group.zIndex);
            c = 0 < (0 !== c && a ? c : 0 !== e ? e : 0 !== h ? h : d.series.index > b.series.index ? -1 : 1);
          }
          c && (d = b);
        });
        return d;
      };
      a.prototype.getChartCoordinatesFromPoint = function (c, a) {
        var f = c.series,
          d = f.xAxis;
        f = f.yAxis;
        var b = c.shapeArgs;
        if (d && f) {
          var e = E(c.clientX, c.plotX),
            h = c.plotY || 0;
          c.isNode && b && k(b.x) && k(b.y) && (e = b.x, h = b.y);
          return a ? {
            chartX: f.len + f.pos - h,
            chartY: d.len + d.pos - e
          } : {
            chartX: e + d.pos,
            chartY: h + f.pos
          };
        }
        if (b && b.x && b.y) return {
          chartX: b.x,
          chartY: b.y
        };
      };
      a.prototype.getChartPosition = function () {
        if (this.chartPosition) return this.chartPosition;
        var c = this.chart.container,
          a = I(c);
        this.chartPosition = {
          left: a.left,
          top: a.top,
          scaleX: 1,
          scaleY: 1
        };
        var f = c.offsetWidth;
        c = c.offsetHeight;
        2 < f && 2 < c && (this.chartPosition.scaleX = a.width / f, this.chartPosition.scaleY = a.height / c);
        return this.chartPosition;
      };
      a.prototype.getCoordinates = function (c) {
        var a = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (f) {
          a[f.isXAxis ? "xAxis" : "yAxis"].push({
            axis: f,
            value: f.toValue(c[f.horiz ? "chartX" : "chartY"])
          });
        });
        return a;
      };
      a.prototype.getHoverData = function (c, a, f, d, b, e) {
        var g = [];
        d = !(!d || !c);
        var n = function (c) {
            return c.visible && !(!b && c.directTouch) && E(c.options.enableMouseTracking, !0);
          },
          k = {
            chartX: e ? e.chartX : void 0,
            chartY: e ? e.chartY : void 0,
            shared: b
          };
        m(this, "beforeGetHoverData", k);
        var u = a && !a.stickyTracking ? [a] : f.filter(function (b) {
          return b.stickyTracking && (k.filter || n)(b);
        });
        var l = d || !e ? c : this.findNearestKDPoint(u, b, e);
        a = l && l.series;
        l && (b && !a.noSharedTooltip ? (u = f.filter(function (b) {
          return k.filter ? k.filter(b) : n(b) && !b.noSharedTooltip;
        }), u.forEach(function (b) {
          var c = h(b.points, function (b) {
            return b.x === l.x && !b.isNull;
          });
          p(c) && (b.boosted && b.boost && (c = b.boost.getPoint(c)), g.push(c));
        })) : g.push(l));
        k = {
          hoverPoint: l
        };
        m(this, "afterGetHoverData", k);
        return {
          hoverPoint: k.hoverPoint,
          hoverSeries: a,
          hoverPoints: g
        };
      };
      a.prototype.getPointFromEvent = function (c) {
        c = c.target;
        for (var a; c && !a;) a = c.point, c = c.parentNode;
        return a;
      };
      a.prototype.onTrackerMouseOut = function (c) {
        c = c.relatedTarget || c.toElement;
        var a = this.chart.hoverSeries;
        this.isDirectTouch = !1;
        if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
      };
      a.prototype.inClass = function (c, a) {
        for (var f; c;) {
          if (f = r(c, "class")) {
            if (-1 !== f.indexOf(a)) return !0;
            if (-1 !== f.indexOf("highcharts-container")) return !1;
          }
          c = c.parentElement;
        }
      };
      a.prototype.init = function (c, a) {
        this.options = a;
        this.chart = c;
        this.runChartClick = !(!a.chart.events || !a.chart.events.click);
        this.pinchDown = [];
        this.lastValidTouch = {};
        x && (c.tooltip = new x(c, a.tooltip));
        this.setDOMEvents();
      };
      a.prototype.normalize = function (c, a) {
        var f = c.touches,
          e = f ? f.length ? f.item(0) : E(f.changedTouches, c.changedTouches)[0] : c;
        a || (a = this.getChartPosition());
        f = e.pageX - a.left;
        e = e.pageY - a.top;
        f /= a.scaleX;
        e /= a.scaleY;
        return d(c, {
          chartX: Math.round(f),
          chartY: Math.round(e)
        });
      };
      a.prototype.onContainerClick = function (c) {
        var a = this.chart,
          f = a.hoverPoint;
        c = this.normalize(c);
        var e = a.plotLeft,
          b = a.plotTop;
        a.cancelClick || (f && this.inClass(c.target, "highcharts-tracker") ? (m(f.series, "click", d(c, {
          point: f
        })), a.hoverPoint && f.firePointEvent("click", c)) : (d(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - e, c.chartY - b, {
          visiblePlotOnly: !0
        }) && m(a, "click", c)));
      };
      a.prototype.onContainerMouseDown = function (a) {
        var c = 1 === ((a.buttons || a.button) & 1);
        a = this.normalize(a);
        if (g.isFirefox && 0 !== a.button) this.onContainerMouseMove(a);
        if ("undefined" === typeof a.button || c) this.zoomOption(a), c && a.preventDefault && a.preventDefault(), this.dragStart(a);
      };
      a.prototype.onContainerMouseLeave = function (c) {
        var d = B[E(a.hoverChartIndex, -1)],
          f = this.chart.tooltip;
        c = this.normalize(c);
        d && (c.relatedTarget || c.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0);
        f && !f.isHidden && this.reset();
      };
      a.prototype.onContainerMouseEnter = function (a) {
        delete this.chartPosition;
      };
      a.prototype.onContainerMouseMove = function (a) {
        var c = this.chart,
          f = c.tooltip;
        a = this.normalize(a);
        this.setHoverChartIndex();
        a.preventDefault || (a.returnValue = !1);
        ("mousedown" === c.mouseIsDown || this.touchSelect(a)) && this.drag(a);
        c.openMenu || !this.inClass(a.target, "highcharts-tracker") && !c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || f && f.shouldStickOnContact(a) || (this.inClass(a.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(a));
      };
      a.prototype.onDocumentTouchEnd = function (c) {
        var d = B[E(a.hoverChartIndex, -1)];
        d && d.pointer.drop(c);
      };
      a.prototype.onContainerTouchMove = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseMove(a);else this.touch(a);
      };
      a.prototype.onContainerTouchStart = function (a) {
        if (this.touchSelect(a)) this.onContainerMouseDown(a);else this.zoomOption(a), this.touch(a, !0);
      };
      a.prototype.onDocumentMouseMove = function (a) {
        var c = this.chart,
          f = c.tooltip,
          d = this.chartPosition;
        a = this.normalize(a, d);
        !d || c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
          visiblePlotOnly: !0
        }) || f && f.shouldStickOnContact(a) || this.inClass(a.target, "highcharts-tracker") || this.reset();
      };
      a.prototype.onDocumentMouseUp = function (c) {
        var d = B[E(a.hoverChartIndex, -1)];
        d && d.pointer.drop(c);
      };
      a.prototype.pinch = function (a) {
        var c = this,
          f = c.chart,
          e = c.pinchDown,
          b = a.touches || [],
          h = b.length,
          g = c.lastValidTouch,
          k = c.hasZoom,
          l = {},
          p = 1 === h && (c.inClass(a.target, "highcharts-tracker") && f.runTrackerClick || c.runChartClick),
          y = {},
          r = c.chart.tooltip;
        r = 1 === h && E(r && r.options.followTouchMove, !0);
        var t = c.selectionMarker;
        1 < h ? c.initiated = !0 : r && (c.initiated = !1);
        k && c.initiated && !p && !1 !== a.cancelable && a.preventDefault();
        [].map.call(b, function (b) {
          return c.normalize(b);
        });
        "touchstart" === a.type ? ([].forEach.call(b, function (b, a) {
          e[a] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), g.x = [e[0].chartX, e[1] && e[1].chartX], g.y = [e[0].chartY, e[1] && e[1].chartY], f.axes.forEach(function (b) {
          if (b.zoomEnabled) {
            var a = f.bounds[b.horiz ? "h" : "v"],
              c = b.minPixelPadding,
              d = b.toPixels(Math.min(E(b.options.min, b.dataMin), b.dataMin)),
              e = b.toPixels(Math.max(E(b.options.max, b.dataMax), b.dataMax)),
              h = Math.max(d, e);
            a.min = Math.min(b.pos, Math.min(d, e) - c);
            a.max = Math.max(b.pos + b.len, h + c);
          }
        }), c.res = !0) : r ? this.runPointActions(c.normalize(a)) : e.length && (m(f, "touchpan", {
          originalEvent: a
        }, function () {
          t || (c.selectionMarker = t = d({
            destroy: H,
            touch: !0
          }, f.plotBox));
          c.pinchTranslate(e, b, l, t, y, g);
          c.hasPinched = k;
          c.scaleGroups(l, y);
        }), c.res && (c.res = !1, this.reset(!1, 0)));
      };
      a.prototype.pinchTranslate = function (a, d, f, e, b, h) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, d, f, e, b, h);
        this.zoomVert && this.pinchTranslateDirection(!1, a, d, f, e, b, h);
      };
      a.prototype.pinchTranslateDirection = function (a, d, f, e, b, h, g, k) {
        var c = this.chart,
          n = a ? "x" : "y",
          q = a ? "X" : "Y",
          u = "chart" + q,
          m = a ? "width" : "height",
          l = c["plot" + (a ? "Left" : "Top")],
          z = c.inverted,
          p = c.bounds[a ? "h" : "v"],
          w = 1 === d.length,
          y = d[0][u],
          r = !w && d[1][u];
        d = function () {
          "number" === typeof R && 20 < Math.abs(y - r) && (M = k || Math.abs(t - R) / Math.abs(y - r));
          P = (l - t) / M + y;
          G = c["plot" + (a ? "Width" : "Height")] / M;
        };
        var G,
          P,
          M = k || 1,
          t = f[0][u],
          R = !w && f[1][u];
        d();
        f = P;
        if (f < p.min) {
          f = p.min;
          var E = !0;
        } else f + G > p.max && (f = p.max - G, E = !0);
        E ? (t -= .8 * (t - g[n][0]), "number" === typeof R && (R -= .8 * (R - g[n][1])), d()) : g[n] = [t, R];
        z || (h[n] = P - l, h[m] = G);
        h = z ? 1 / M : M;
        b[m] = G;
        b[n] = f;
        e[z ? a ? "scaleY" : "scaleX" : "scale" + q] = M;
        e["translate" + q] = h * l + (t - h * y);
      };
      a.prototype.reset = function (a, d) {
        var c = this.chart,
          e = c.hoverSeries,
          b = c.hoverPoint,
          h = c.hoverPoints,
          g = c.tooltip,
          k = g && g.shared ? h : b;
        a && k && L(k).forEach(function (b) {
          b.series.isCartesian && "undefined" === typeof b.plotX && (a = !1);
        });
        if (a) g && k && L(k).length && (g.refresh(k), g.shared && h ? h.forEach(function (b) {
          b.setState(b.state, !0);
          b.series.isCartesian && (b.series.xAxis.crosshair && b.series.xAxis.drawCrosshair(null, b), b.series.yAxis.crosshair && b.series.yAxis.drawCrosshair(null, b));
        }) : b && (b.setState(b.state, !0), c.axes.forEach(function (a) {
          a.crosshair && b.series[a.coll] === a && a.drawCrosshair(null, b);
        })));else {
          if (b) b.onMouseOut();
          h && h.forEach(function (b) {
            b.setState();
          });
          if (e) e.onMouseOut();
          g && g.hide(d);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          c.axes.forEach(function (b) {
            b.hideCrosshair();
          });
          this.hoverX = c.hoverPoints = c.hoverPoint = null;
        }
      };
      a.prototype.runPointActions = function (c, d, f) {
        var e = this.chart,
          b = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
          g = b ? b.shared : !1,
          k = d || e.hoverPoint,
          q = k && k.series || e.hoverSeries;
        d = this.getHoverData(k, q, e.series, (!c || "touchmove" !== c.type) && (!!d || q && q.directTouch && this.isDirectTouch), g, c);
        k = d.hoverPoint;
        q = d.hoverSeries;
        var m = d.hoverPoints;
        d = q && q.tooltipOptions.followPointer && !q.tooltipOptions.split;
        var l = g && q && !q.noSharedTooltip;
        if (k && (f || k !== e.hoverPoint || b && b.isHidden)) {
          (e.hoverPoints || []).forEach(function (b) {
            -1 === m.indexOf(b) && b.setState();
          });
          if (e.hoverSeries !== q) q.onMouseOver();
          this.applyInactiveState(m);
          (m || []).forEach(function (b) {
            b.setState("hover");
          });
          e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
          if (!k.series) return;
          e.hoverPoints = m;
          e.hoverPoint = k;
          k.firePointEvent("mouseOver", void 0, function () {
            b && k && b.refresh(l ? m : k, c);
          });
        } else d && b && !b.isHidden && (f = b.getAnchor([{}], c), e.isInsidePlot(f[0], f[1], {
          visiblePlotOnly: !0
        }) && b.updatePosition({
          plotX: f[0],
          plotY: f[1]
        }));
        this.unDocMouseMove || (this.unDocMouseMove = t(e.container.ownerDocument, "mousemove", function (b) {
          var c = B[a.hoverChartIndex];
          if (c) c.pointer.onDocumentMouseMove(b);
        }), this.eventsToUnbind.push(this.unDocMouseMove));
        e.axes.forEach(function (b) {
          var a = E((b.crosshair || {}).snap, !0),
            d;
          a && ((d = e.hoverPoint) && d.series[b.coll] === b || (d = h(m, function (a) {
            return a.series && a.series[b.coll] === b;
          })));
          d || !a ? b.drawCrosshair(c, d) : b.hideCrosshair();
        });
      };
      a.prototype.scaleGroups = function (a, d) {
        var c = this.chart;
        c.series.forEach(function (f) {
          var b = a || f.getPlotBox();
          f.group && (f.xAxis && f.xAxis.zoomEnabled || c.mapView) && (f.group.attr(b), f.markerGroup && (f.markerGroup.attr(b), f.markerGroup.clip(d ? c.clipRect : null)), f.dataLabelsGroup && f.dataLabelsGroup.attr(b));
        });
        c.clipRect.attr(d || c.clipBox);
      };
      a.prototype.setDOMEvents = function () {
        var c = this,
          d = this.chart.container,
          f = d.ownerDocument;
        d.onmousedown = this.onContainerMouseDown.bind(this);
        d.onmousemove = this.onContainerMouseMove.bind(this);
        d.onclick = this.onContainerClick.bind(this);
        this.eventsToUnbind.push(t(d, "mouseenter", this.onContainerMouseEnter.bind(this)));
        this.eventsToUnbind.push(t(d, "mouseleave", this.onContainerMouseLeave.bind(this)));
        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = t(f, "mouseup", this.onDocumentMouseUp.bind(this)));
        for (var e = this.chart.renderTo.parentElement; e && "BODY" !== e.tagName;) this.eventsToUnbind.push(t(e, "scroll", function () {
          delete c.chartPosition;
        })), e = e.parentElement;
        g.hasTouch && (this.eventsToUnbind.push(t(d, "touchstart", this.onContainerTouchStart.bind(this), {
          passive: !1
        })), this.eventsToUnbind.push(t(d, "touchmove", this.onContainerTouchMove.bind(this), {
          passive: !1
        })), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = t(f, "touchend", this.onDocumentTouchEnd.bind(this), {
          passive: !1
        })));
      };
      a.prototype.setHoverChartIndex = function () {
        var c = this.chart,
          d = g.charts[E(a.hoverChartIndex, -1)];
        if (d && d !== c) d.pointer.onContainerMouseLeave({
          relatedTarget: c.container
        });
        d && d.mouseIsDown || (a.hoverChartIndex = c.index);
      };
      a.prototype.touch = function (a, d) {
        var c = this.chart,
          e;
        this.setHoverChartIndex();
        if (1 === a.touches.length) {
          if (a = this.normalize(a), (e = c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop, {
            visiblePlotOnly: !0
          })) && !c.openMenu) {
            d && this.runPointActions(a);
            if ("touchmove" === a.type) {
              d = this.pinchDown;
              var b = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - a.chartX, 2) + Math.pow(d[0].chartY - a.chartY, 2)) : !1;
            }
            E(b, !0) && this.pinch(a);
          } else d && this.reset();
        } else 2 === a.touches.length && this.pinch(a);
      };
      a.prototype.touchSelect = function (a) {
        return !(!this.chart.options.chart.zooming.singleTouch || !a.touches || 1 !== a.touches.length);
      };
      a.prototype.zoomOption = function (a) {
        var c = this.chart,
          d = c.options.chart;
        c = c.inverted;
        var e = d.zooming.type || "";
        /touch/.test(a.type) && (e = E(d.zooming.pinchType, e));
        this.zoomX = a = /x/.test(e);
        this.zoomY = d = /y/.test(e);
        this.zoomHor = a && !c || d && c;
        this.zoomVert = d && !c || a && c;
        this.hasZoom = a || d;
      };
      return a;
    }();
    "";
    return a;
  });
  K(g, "Core/MSPointer.js", [g["Core/Globals.js"], g["Core/Pointer.js"], g["Core/Utilities.js"]], function (a, g, x) {
    function A() {
      var a = [];
      a.item = function (a) {
        return this[a];
      };
      h(p, function (d) {
        a.push({
          pageX: d.pageX,
          pageY: d.pageY,
          target: d.target
        });
      });
      return a;
    }
    function C(a, d, e, h) {
      var c = H[g.hoverChartIndex || NaN];
      "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !c || (c = c.pointer, h(a), c[d]({
        type: e,
        target: a.currentTarget,
        preventDefault: r,
        touches: A()
      }));
    }
    var B = this && this.__extends || function () {
        var a = function (d, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var d in c) c.hasOwnProperty(d) && (a[d] = c[d]);
          };
          return a(d, e);
        };
        return function (d, e) {
          function h() {
            this.constructor = d;
          }
          a(d, e);
          d.prototype = null === e ? Object.create(e) : (h.prototype = e.prototype, new h());
        };
      }(),
      H = a.charts,
      t = a.doc,
      r = a.noop,
      l = a.win,
      e = x.addEvent,
      d = x.css,
      h = x.objectEach,
      m = x.pick,
      k = x.removeEvent,
      p = {},
      D = !!l.PointerEvent;
    return function (h) {
      function g() {
        return null !== h && h.apply(this, arguments) || this;
      }
      B(g, h);
      g.isRequired = function () {
        return !(a.hasTouch || !l.PointerEvent && !l.MSPointerEvent);
      };
      g.prototype.batchMSEvents = function (a) {
        a(this.chart.container, D ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        a(this.chart.container, D ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        a(t, D ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };
      g.prototype.destroy = function () {
        this.batchMSEvents(k);
        h.prototype.destroy.call(this);
      };
      g.prototype.init = function (a, e) {
        h.prototype.init.call(this, a, e);
        this.hasZoom && d(a.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };
      g.prototype.onContainerPointerDown = function (a) {
        C(a, "onContainerTouchStart", "touchstart", function (a) {
          p[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY,
            target: a.currentTarget
          };
        });
      };
      g.prototype.onContainerPointerMove = function (a) {
        C(a, "onContainerTouchMove", "touchmove", function (a) {
          p[a.pointerId] = {
            pageX: a.pageX,
            pageY: a.pageY
          };
          p[a.pointerId].target || (p[a.pointerId].target = a.currentTarget);
        });
      };
      g.prototype.onDocumentPointerUp = function (a) {
        C(a, "onDocumentTouchEnd", "touchend", function (a) {
          delete p[a.pointerId];
        });
      };
      g.prototype.setDOMEvents = function () {
        var a = this.chart.tooltip;
        h.prototype.setDOMEvents.call(this);
        (this.hasZoom || m(a && a.options.followTouchMove, !0)) && this.batchMSEvents(e);
      };
      return g;
    }(g);
  });
  K(g, "Core/Legend/Legend.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Globals.js"], g["Core/Series/Point.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B) {
    var A = a.animObject,
      t = a.setAnimation,
      r = g.format,
      l = x.marginNames,
      e = C.distribute,
      d = B.addEvent,
      h = B.createElement,
      m = B.css,
      k = B.defined,
      p = B.discardElement,
      D = B.find,
      I = B.fireEvent,
      E = B.isNumber,
      L = B.merge,
      y = B.pick,
      c = B.relativeLength,
      w = B.stableSort,
      f = B.syncTimeout;
    a = function () {
      function a(b, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = void 0;
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = b;
        this.init(b, a);
      }
      a.prototype.init = function (b, a) {
        this.chart = b;
        this.setOptions(a);
        a.enabled && (this.render(), d(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = d(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };
      a.prototype.setOptions = function (b) {
        var a = y(b.padding, 8);
        this.options = b;
        this.chart.styledMode || (this.itemStyle = b.itemStyle, this.itemHiddenStyle = L(this.itemStyle, b.itemHiddenStyle));
        this.itemMarginTop = b.itemMarginTop || 0;
        this.itemMarginBottom = b.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = y(b.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === b.layout && !this.chart.inverted;
        this.baseline = void 0;
      };
      a.prototype.update = function (b, a) {
        var c = this.chart;
        this.setOptions(L(!0, this.options, b));
        this.destroy();
        c.isDirtyLegend = c.isDirtyBox = !0;
        y(a, !0) && c.redraw();
        I(this, "afterUpdate");
      };
      a.prototype.colorizeItem = function (b, a) {
        var c = b.legendItem || {},
          d = c.group,
          f = c.label,
          e = c.line;
        c = c.symbol;
        if (d) d[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        if (!this.chart.styledMode) {
          var h = this.options;
          d = this.itemHiddenStyle.color;
          h = a ? h.itemStyle.color : d;
          var g = a ? b.color || d : d,
            k = b.options && b.options.marker,
            n = {
              fill: g
            };
          f && f.css({
            fill: h,
            color: h
          });
          e && e.attr({
            stroke: g
          });
          c && (k && c.isMarker && (n = b.pointAttribs(), a || (n.stroke = n.fill = d)), c.attr(n));
        }
        I(this, "afterColorizeItem", {
          item: b,
          visible: a
        });
      };
      a.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };
      a.prototype.positionItem = function (b) {
        var a = this,
          c = b.legendItem || {},
          d = c.group,
          f = c.x;
        f = void 0 === f ? 0 : f;
        c = c.y;
        c = void 0 === c ? 0 : c;
        var e = this.options,
          h = e.symbolPadding,
          g = !e.rtl;
        e = b.checkbox;
        d && d.element && (h = {
          translateX: g ? f : this.legendWidth - f - 2 * h - 4,
          translateY: c
        }, d[k(d.translateY) ? "animate" : "attr"](h, void 0, function () {
          I(a, "afterPositionItem", {
            item: b
          });
        }));
        e && (e.x = f, e.y = c);
      };
      a.prototype.destroyItem = function (b) {
        for (var a = b.checkbox, c = b.legendItem || {}, d = 0, f = ["group", "label", "line", "symbol"]; d < f.length; d++) {
          var e = f[d];
          c[e] && (c[e] = c[e].destroy());
        }
        a && p(a);
        b.legendItem = void 0;
      };
      a.prototype.destroy = function () {
        for (var b = 0, a = this.getAllItems(); b < a.length; b++) this.destroyItem(a[b]);
        b = 0;
        for (a = "clipRect up down pager nav box title group".split(" "); b < a.length; b++) {
          var c = a[b];
          this[c] && (this[c] = this[c].destroy());
        }
        this.display = null;
      };
      a.prototype.positionCheckboxes = function () {
        var b = this.group && this.group.alignAttr,
          a = this.clipHeight || this.legendHeight,
          c = this.titleHeight;
        if (b) {
          var d = b.translateY;
          this.allItems.forEach(function (f) {
            var e = f.checkbox;
            if (e) {
              var h = d + c + e.y + (this.scrollOffset || 0) + 3;
              m(e, {
                left: b.translateX + f.checkboxOffset + e.x - 20 + "px",
                top: h + "px",
                display: this.proximate || h > d - 6 && h < d + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };
      a.prototype.renderTitle = function () {
        var b = this.options,
          a = this.padding,
          c = b.title,
          d = 0;
        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, void 0, void 0, void 0, b.useHTML, void 0, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), b = this.title.getBBox(), d = b.height, this.offsetWidth = b.width, this.contentGroup.attr({
          translateY: d
        }));
        this.titleHeight = d;
      };
      a.prototype.setText = function (b) {
        var a = this.options;
        b.legendItem.label.attr({
          text: a.labelFormat ? r(a.labelFormat, b, this.chart) : a.labelFormatter.call(b)
        });
      };
      a.prototype.renderItem = function (b) {
        var a = b.legendItem = b.legendItem || {},
          c = this.chart,
          d = c.renderer,
          f = this.options,
          e = this.symbolWidth,
          h = f.symbolPadding || 0,
          g = this.itemStyle,
          k = this.itemHiddenStyle,
          n = "horizontal" === f.layout ? y(f.itemDistance, 20) : 0,
          m = !f.rtl,
          l = !b.series,
          p = !l && b.series.drawLegendSymbol ? b.series : b,
          r = p.options,
          w = this.createCheckboxForItem && r && r.showCheckbox,
          G = f.useHTML,
          P = b.options.className,
          M = a.label;
        r = e + h + n + (w ? 20 : 0);
        M || (a.group = d.g("legend-item").addClass("highcharts-" + p.type + "-series highcharts-color-" + b.colorIndex + (P ? " " + P : "") + (l ? " highcharts-series-" + b.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), a.label = M = d.text("", m ? e + h : -h, this.baseline || 0, G), c.styledMode || M.css(L(b.visible ? g : k)), M.attr({
          align: m ? "left" : "right",
          zIndex: 2
        }).add(a.group), this.baseline || (this.fontMetrics = d.fontMetrics(c.styledMode ? 12 : g.fontSize, M), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, M.attr("y", this.baseline), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, f.squareSymbol && (this.symbolWidth = y(f.symbolWidth, Math.max(this.symbolHeight, 16)), r = this.symbolWidth + h + n + (w ? 20 : 0), m && M.attr("x", this.symbolWidth + h))), p.drawLegendSymbol(this, b), this.setItemEvents && this.setItemEvents(b, M, G));
        w && !b.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b);
        this.colorizeItem(b, b.visible);
        !c.styledMode && g.width || M.css({
          width: (f.itemWidth || this.widthOption || c.spacingBox.width) - r + "px"
        });
        this.setText(b);
        c = M.getBBox();
        d = this.fontMetrics && this.fontMetrics.h || 0;
        b.itemWidth = b.checkboxOffset = f.itemWidth || a.labelWidth || c.width + r;
        this.maxItemWidth = Math.max(this.maxItemWidth, b.itemWidth);
        this.totalItemWidth += b.itemWidth;
        this.itemHeight = b.itemHeight = Math.round(a.labelHeight || (c.height > 1.5 * d ? c.height : d));
      };
      a.prototype.layoutItem = function (b) {
        var a = this.options,
          c = this.padding,
          d = "horizontal" === a.layout,
          f = b.itemHeight,
          e = this.itemMarginBottom,
          h = this.itemMarginTop,
          g = d ? y(a.itemDistance, 20) : 0,
          k = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > k ? this.maxItemWidth : b.itemWidth;
        var n = b.legendItem || {};
        d && this.itemX - c + a > k && (this.itemX = c, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + e), this.lastLineHeight = 0);
        this.lastItemY = h + this.itemY + e;
        this.lastLineHeight = Math.max(f, this.lastLineHeight);
        n.x = this.itemX;
        n.y = this.itemY;
        d ? this.itemX += a : (this.itemY += h + f + e, this.lastLineHeight = f);
        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c - (b.checkbox ? 0 : g) : a) + c, this.offsetWidth);
      };
      a.prototype.getAllItems = function () {
        var b = [];
        this.chart.series.forEach(function (a) {
          var c = a && a.options;
          a && y(c.showInLegend, k(c.linkedTo) ? !1 : void 0, !0) && (b = b.concat((a.legendItem || {}).labels || ("point" === c.legendType ? a.data : a)));
        });
        I(this, "afterGetAllItems", {
          allItems: b
        });
        return b;
      };
      a.prototype.getAlignment = function () {
        var b = this.options;
        return this.proximate ? b.align.charAt(0) + "tv" : b.floating ? "" : b.align.charAt(0) + b.verticalAlign.charAt(0) + b.layout.charAt(0);
      };
      a.prototype.adjustMargins = function (b, a) {
        var c = this.chart,
          d = this.options,
          f = this.getAlignment();
        f && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (e, h) {
          e.test(f) && !k(b[h]) && (c[l[h]] = Math.max(c[l[h]], c.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + y(d.margin, 12) + a[h] + (c.titleOffset[h] || 0)));
        });
      };
      a.prototype.proximatePositions = function () {
        var b = this.chart,
          a = [],
          c = "left" === this.options.align;
        this.allItems.forEach(function (d) {
          var f;
          var e = c;
          if (d.yAxis) {
            d.xAxis.options.reversed && (e = !e);
            d.points && (f = D(e ? d.points : d.points.slice(0).reverse(), function (b) {
              return E(b.plotY);
            }));
            e = this.itemMarginTop + d.legendItem.label.getBBox().height + this.itemMarginBottom;
            var h = d.yAxis.top - b.plotTop;
            d.visible ? (f = f ? f.plotY : d.yAxis.height, f += h - .3 * e) : f = h + d.yAxis.height;
            a.push({
              target: f,
              size: e,
              item: d
            });
          }
        }, this);
        for (var d, f = 0, h = e(a, b.plotHeight); f < h.length; f++) {
          var g = h[f];
          d = g.item.legendItem || {};
          E(g.pos) && (d.y = b.plotTop - b.spacing[0] + g.pos);
        }
      };
      a.prototype.render = function () {
        var b = this.chart,
          a = b.renderer,
          d = this.options,
          f = this.padding,
          e = this.getAllItems(),
          h = this.group,
          g = this.box;
        this.itemX = f;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = c(d.width, b.spacingBox.width - f);
        var k = b.spacingBox.width - 2 * f - d.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (k /= 2);
        this.maxLegendWidth = this.widthOption || k;
        h || (this.group = h = a.g("legend").addClass(d.className || "").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(h), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        w(e, function (b, a) {
          return (b.options && b.options.legendIndex || 0) - (a.options && a.options.legendIndex || 0);
        });
        d.reversed && e.reverse();
        this.allItems = e;
        this.display = k = !!e.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        e.forEach(this.renderItem, this);
        e.forEach(this.layoutItem, this);
        e = (this.widthOption || this.offsetWidth) + f;
        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;
        n = this.handleOverflow(n);
        n += f;
        g || (this.box = g = a.rect().addClass("highcharts-legend-box").attr({
          r: d.borderRadius
        }).add(h));
        b.styledMode || g.attr({
          stroke: d.borderColor,
          "stroke-width": d.borderWidth || 0,
          fill: d.backgroundColor || "none"
        }).shadow(d.shadow);
        if (0 < e && 0 < n) g[g.placed ? "animate" : "attr"](g.crisp.call({}, {
          x: 0,
          y: 0,
          width: e,
          height: n
        }, g.strokeWidth()));
        h[k ? "show" : "hide"]();
        b.styledMode && "none" === h.getStyle("display") && (e = n = 0);
        this.legendWidth = e;
        this.legendHeight = n;
        k && this.align();
        this.proximate || this.positionItems();
        I(this, "afterRender");
      };
      a.prototype.align = function (b) {
        void 0 === b && (b = this.chart.spacingBox);
        var a = this.chart,
          c = this.options,
          d = b.y;
        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a.titleOffset[0] ? d += a.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a.titleOffset[2] && (d -= a.titleOffset[2]);
        d !== b.y && (b = L(b, {
          y: d
        }));
        a.hasRendered || (this.group.placed = !1);
        this.group.align(L(c, {
          width: this.legendWidth,
          height: this.legendHeight,
          verticalAlign: this.proximate ? "top" : c.verticalAlign
        }), !0, b);
      };
      a.prototype.handleOverflow = function (b) {
        var a = this,
          c = this.chart,
          d = c.renderer,
          f = this.options,
          e = f.y,
          h = "top" === f.verticalAlign,
          g = this.padding,
          k = f.maxHeight,
          n = f.navigation,
          m = y(n.animation, !0),
          l = n.arrowSize || 12,
          p = this.pages,
          r = this.allItems,
          w = function (b) {
            "number" === typeof b ? D.attr({
              height: b
            }) : D && (a.clipRect = D.destroy(), a.contentGroup.clip());
            a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + g + "px,9999px," + (g + b) + "px,0)" : "auto");
          },
          G = function (b) {
            a[b] = d.circle(0, 0, 1.3 * l).translate(l / 2, l / 2).add(R);
            c.styledMode || a[b].attr("fill", "rgba(0,0,0,0.0001)");
            return a[b];
          },
          P,
          M,
          t;
        e = c.spacingBox.height + (h ? -e : e) - g;
        var R = this.nav,
          D = this.clipRect;
        "horizontal" !== f.layout || "middle" === f.verticalAlign || f.floating || (e /= 2);
        k && (e = Math.min(e, k));
        p.length = 0;
        b && 0 < e && b > e && !1 !== n.enabled ? (this.clipHeight = P = Math.max(e - 20 - this.titleHeight - g, 0), this.currentPage = y(this.currentPage, 1), this.fullHeight = b, r.forEach(function (b, a) {
          t = b.legendItem || {};
          b = t.y || 0;
          var c = Math.round(t.label.getBBox().height),
            d = p.length;
          if (!d || b - p[d - 1] > P && (M || b) !== p[d - 1]) p.push(M || b), d++;
          t.pageIx = d - 1;
          M && ((r[a - 1].legendItem || {}).pageIx = d - 1);
          a === r.length - 1 && b + c - p[d - 1] > P && c <= P && (p.push(b), t.pageIx = d);
          b !== M && (M = b);
        }), D || (D = a.clipRect = d.clipRect(0, g, 9999, 0), a.contentGroup.clip(D)), w(P), R || (this.nav = R = d.g().attr({
          zIndex: 1
        }).add(this.group), this.up = d.symbol("triangle", 0, 0, l, l).add(R), G("upTracker").on("click", function () {
          a.scroll(-1, m);
        }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !c.styledMode && n.style && this.pager.css(n.style), this.pager.add(R), this.down = d.symbol("triangle-down", 0, 0, l, l).add(R), G("downTracker").on("click", function () {
          a.scroll(1, m);
        })), a.scroll(0), b = e) : R && (w(), this.nav = R.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return b;
      };
      a.prototype.scroll = function (b, a) {
        var c = this,
          d = this.chart,
          e = this.pages,
          h = e.length,
          g = this.clipHeight,
          k = this.options.navigation,
          n = this.pager,
          m = this.padding,
          l = this.currentPage + b;
        l > h && (l = h);
        0 < l && ("undefined" !== typeof a && t(a, d), this.nav.attr({
          translateX: m,
          translateY: g + this.padding + 7 + this.titleHeight,
          visibility: "inherit"
        }), [this.up, this.upTracker].forEach(function (b) {
          b.attr({
            "class": 1 === l ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), n.attr({
          text: l + "/" + h
        }), [this.down, this.downTracker].forEach(function (b) {
          b.attr({
            x: 18 + this.pager.getBBox().width,
            "class": l === h ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), d.styledMode || (this.up.attr({
          fill: 1 === l ? k.inactiveColor : k.activeColor
        }), this.upTracker.css({
          cursor: 1 === l ? "default" : "pointer"
        }), this.down.attr({
          fill: l === h ? k.inactiveColor : k.activeColor
        }), this.downTracker.css({
          cursor: l === h ? "default" : "pointer"
        })), this.scrollOffset = -e[l - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = l, this.positionCheckboxes(), b = A(y(a, d.renderer.globalAnimation, !0)), f(function () {
          I(c, "afterScroll", {
            currentPage: l
          });
        }, b.duration));
      };
      a.prototype.setItemEvents = function (b, a, c) {
        var d = this,
          f = b.legendItem || {},
          e = d.chart.renderer.boxWrapper,
          h = b instanceof F,
          g = "highcharts-legend-" + (h ? "point" : "series") + "-active",
          k = d.chart.styledMode,
          n = function (a) {
            d.allItems.forEach(function (c) {
              b !== c && [c].concat(c.linkedSeries || []).forEach(function (b) {
                b.setState(a, !h);
              });
            });
          },
          m = 0;
        for (c = c ? [a, f.symbol] : [f.group]; m < c.length; m++) if (f = c[m]) f.on("mouseover", function () {
          b.visible && n("inactive");
          b.setState("hover");
          b.visible && e.addClass(g);
          k || a.css(d.options.itemHoverStyle);
        }).on("mouseout", function () {
          d.chart.styledMode || a.css(L(b.visible ? d.itemStyle : d.itemHiddenStyle));
          n("");
          e.removeClass(g);
          b.setState();
        }).on("click", function (a) {
          var c = function () {
            b.setVisible && b.setVisible();
            n(b.visible ? "inactive" : "");
          };
          e.removeClass(g);
          a = {
            browserEvent: a
          };
          b.firePointEvent ? b.firePointEvent("legendItemClick", a, c) : I(b, "legendItemClick", a, c);
        });
      };
      a.prototype.createCheckboxForItem = function (b) {
        b.checkbox = h("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: b.selected,
          defaultChecked: b.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        d(b.checkbox, "click", function (a) {
          I(b.series || b, "checkboxClick", {
            checked: a.target.checked,
            item: b
          }, function () {
            b.select();
          });
        });
      };
      return a;
    }();
    "";
    return a;
  });
  K(g, "Core/Series/SeriesRegistry.js", [g["Core/Globals.js"], g["Core/Defaults.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = g.defaultOptions,
      B = F.extendClass,
      H = F.merge,
      t;
    (function (g) {
      function l(a, d) {
        var e = A.plotOptions || {},
          m = d.defaultOptions,
          k = d.prototype;
        k.type = a;
        k.pointClass || (k.pointClass = x);
        m && (e[a] = m);
        g.seriesTypes[a] = d;
      }
      g.seriesTypes = a.seriesTypes;
      g.registerSeriesType = l;
      g.seriesType = function (a, d, h, m, k) {
        var e = A.plotOptions || {};
        d = d || "";
        e[a] = H(e[d], h);
        l(a, B(g.seriesTypes[d] || function () {}, m));
        g.seriesTypes[a].prototype.type = a;
        k && (g.seriesTypes[a].prototype.pointClass = B(x, k));
        return g.seriesTypes[a];
      };
    })(t || (t = {}));
    return t;
  });
  K(g, "Core/Chart/Chart.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Defaults.js"], g["Core/FormatUtilities.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/Legend.js"], g["Core/MSPointer.js"], g["Core/Pointer.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Time.js"], g["Core/Utilities.js"], g["Core/Renderer/HTML/AST.js"]], function (a, g, x, F, C, B, H, t, r, l, e, d, h, m, k) {
    var p = a.animate,
      D = a.animObject,
      A = a.setAnimation,
      E = x.defaultOptions,
      L = x.defaultTime,
      y = F.numberFormat,
      c = C.registerEventOptions,
      w = B.charts,
      f = B.doc,
      n = B.marginNames,
      b = B.svg,
      u = B.win,
      z = e.seriesTypes,
      q = m.addEvent,
      N = m.attr,
      J = m.cleanRecursively,
      O = m.createElement,
      Q = m.css,
      T = m.defined,
      Y = m.discardElement,
      v = m.erase,
      U = m.error,
      K = m.extend,
      ca = m.find,
      S = m.fireEvent,
      G = m.getStyle,
      P = m.isArray,
      M = m.isNumber,
      X = m.isObject,
      R = m.isString,
      V = m.merge,
      Z = m.objectEach,
      W = m.pick,
      ba = m.pInt,
      fa = m.relativeLength,
      ha = m.removeEvent,
      ea = m.splat,
      ia = m.syncTimeout,
      ka = m.uniqueKey;
    a = function () {
      function a(b, a, c) {
        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
        this.sharedClips = {};
        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
        this.getArgs(b, a, c);
      }
      a.chart = function (b, c, d) {
        return new a(b, c, d);
      };
      a.prototype.getArgs = function (b, a, c) {
        R(b) || b.nodeName ? (this.renderTo = b, this.init(a, c)) : this.init(b, a);
      };
      a.prototype.init = function (b, a) {
        var d = b.plotOptions || {};
        S(this, "init", {
          args: arguments
        }, function () {
          var f = V(E, b),
            e = f.chart;
          Z(f.plotOptions, function (b, a) {
            X(b) && (b.tooltip = d[a] && V(d[a].tooltip) || void 0);
          });
          f.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          this.userOptions = b;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = a;
          this.isResizing = 0;
          var g = e.zooming = e.zooming || {};
          b.chart && !b.chart.zooming && (g.resetButton = e.resetZoomButton);
          g.key = W(g.key, e.zoomKey);
          g.pinchType = W(g.pinchType, e.pinchType);
          g.singleTouch = W(g.singleTouch, e.zoomBySingleTouch);
          g.type = W(g.type, e.zoomType);
          this.options = f;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new h(b.time) : B.time;
          this.numberFormatter = e.numberFormatter || y;
          this.styledMode = e.styledMode;
          this.hasCartesianSeries = e.showAxes;
          this.index = w.length;
          w.push(this);
          B.chartCount++;
          c(this, e);
          this.xAxis = [];
          this.yAxis = [];
          this.pointCount = this.colorCounter = this.symbolCounter = 0;
          S(this, "afterInit");
          this.firstRender();
        });
      };
      a.prototype.initSeries = function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var c = z[a];
        c || U(17, !0, this, {
          missingModuleFor: a
        });
        a = new c();
        "function" === typeof a.init && a.init(this, b);
        return a;
      };
      a.prototype.setSeriesData = function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      };
      a.prototype.getSeriesOrderByLinks = function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      };
      a.prototype.orderSeries = function (b) {
        var a = this.series;
        b = b || 0;
        for (var c = a.length; b < c; ++b) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      };
      a.prototype.isInsidePlot = function (b, a, c) {
        void 0 === c && (c = {});
        var d = this.inverted,
          f = this.plotBox,
          e = this.plotLeft,
          h = this.plotTop,
          g = this.scrollablePlotBox,
          k = 0;
        var n = 0;
        c.visiblePlotOnly && this.scrollingContainer && (n = this.scrollingContainer, k = n.scrollLeft, n = n.scrollTop);
        var m = c.series;
        f = c.visiblePlotOnly && g || f;
        g = c.inverted ? a : b;
        a = c.inverted ? b : a;
        b = {
          x: g,
          y: a,
          isInsidePlot: !0,
          options: c
        };
        if (!c.ignoreX) {
          var q = m && (d && !this.polar ? m.yAxis : m.xAxis) || {
            pos: e,
            len: Infinity
          };
          g = c.paneCoordinates ? q.pos + g : e + g;
          g >= Math.max(k + e, q.pos) && g <= Math.min(k + e + f.width, q.pos + q.len) || (b.isInsidePlot = !1);
        }
        !c.ignoreY && b.isInsidePlot && (d = c.axis && !c.axis.isXAxis && c.axis || m && (d ? m.xAxis : m.yAxis) || {
          pos: h,
          len: Infinity
        }, c = c.paneCoordinates ? d.pos + a : h + a, c >= Math.max(n + h, d.pos) && c <= Math.min(n + h + f.height, d.pos + d.len) || (b.isInsidePlot = !1));
        S(this, "afterIsInsidePlot", b);
        return b.isInsidePlot;
      };
      a.prototype.redraw = function (b) {
        S(this, "beforeRedraw");
        var a = this.hasCartesianSeries ? this.axes : this.colorAxis || [],
          c = this.series,
          d = this.pointer,
          f = this.legend,
          e = this.userOptions.legend,
          h = this.renderer,
          g = h.isHidden(),
          k = [],
          n = this.isDirtyBox,
          m = this.isDirtyLegend;
        this.setResponsive && this.setResponsive(!1);
        A(this.hasRendered ? b : !1, this);
        g && this.temporaryDisplay();
        this.layOutTitles();
        for (b = c.length; b--;) {
          var q = c[b];
          if (q.options.stacking || q.options.centerInCategory) {
            var l = !0;
            if (q.isDirty) {
              var G = !0;
              break;
            }
          }
        }
        if (G) for (b = c.length; b--;) q = c[b], q.options.stacking && (q.isDirty = !0);
        c.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? ("function" === typeof b.updateTotals && b.updateTotals(), m = !0) : e && (e.labelFormatter || e.labelFormat) && (m = !0));
          b.isDirtyData && S(b, "updatedData");
        });
        m && f && f.options.enabled && (f.render(), this.isDirtyLegend = !1);
        l && this.getStacks();
        a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        a.forEach(function (b) {
          b.isDirty && (n = !0);
        });
        a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, k.push(function () {
            S(b, "afterSetExtremes", K(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (n || l) && b.redraw();
        });
        n && this.drawChartBox();
        S(this, "predraw");
        c.forEach(function (b) {
          (n || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        d && d.reset(!0);
        h.draw();
        S(this, "redraw");
        S(this, "render");
        g && this.temporaryDisplay(!0);
        k.forEach(function (b) {
          b.call();
        });
      };
      a.prototype.get = function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }
        for (var c = this.series, d = ca(this.axes, a) || ca(this.series, a), f = 0; !d && f < c.length; f++) d = ca(c[f].points || [], a);
        return d;
      };
      a.prototype.getAxes = function () {
        var b = this,
          a = this.options,
          c = a.xAxis = ea(a.xAxis || {});
        a = a.yAxis = ea(a.yAxis || {});
        S(this, "getAxes");
        c.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        a.forEach(function (b, a) {
          b.index = a;
        });
        c.concat(a).forEach(function (a) {
          new g(b, a);
        });
        S(this, "afterGetAxes");
      };
      a.prototype.getSelectedPoints = function () {
        return this.series.reduce(function (b, a) {
          a.getPointsCollection().forEach(function (a) {
            W(a.selectedStaging, a.selected) && b.push(a);
          });
          return b;
        }, []);
      };
      a.prototype.getSelectedSeries = function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      };
      a.prototype.setTitle = function (b, a, c) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(c);
      };
      a.prototype.applyDescription = function (b, a) {
        var c = this,
          d = "title" === b ? {
            color: "#333333",
            fontSize: this.options.isStock ? "16px" : "18px"
          } : {
            color: "#666666"
          };
        d = this.options[b] = V(!this.styledMode && {
          style: d
        }, this.options[b], a);
        var f = this[b];
        f && a && (this[b] = f = f.destroy());
        d && !f && (f = this.renderer.text(d.text, 0, 0, d.useHTML).attr({
          align: d.align,
          "class": "highcharts-" + b,
          zIndex: d.zIndex || 4
        }).add(), f.update = function (a) {
          c[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || f.css(d.style), this[b] = f);
      };
      a.prototype.layOutTitles = function (b) {
        var a = [0, 0, 0],
          c = this.renderer,
          d = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var f = this[b],
            e = this.options[b],
            h = e.verticalAlign || "top";
          b = "title" === b ? "top" === h ? -3 : 0 : "top" === h ? a[0] + 2 : 0;
          var g;
          if (f) {
            this.styledMode || (g = e.style && e.style.fontSize);
            g = c.fontMetrics(g, f).b;
            f.css({
              width: (e.width || d.width + (e.widthAdjust || 0)) + "px"
            });
            var k = Math.round(f.getBBox(e.useHTML).height);
            f.align(K({
              y: "bottom" === h ? g : b + g,
              height: k
            }, e), !1, "spacingBox");
            e.floating || ("top" === h ? a[0] = Math.ceil(a[0] + k) : "bottom" === h && (a[2] = Math.ceil(a[2] + k)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var f = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        S(this, "afterLayOutTitles");
        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && W(b, !0) && this.isDirtyBox && this.redraw());
      };
      a.prototype.getChartSize = function () {
        var b = this.options.chart,
          a = b.width;
        b = b.height;
        var c = this.renderTo;
        T(a) || (this.containerWidth = G(c, "width"));
        T(b) || (this.containerHeight = G(c, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, fa(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      };
      a.prototype.temporaryDisplay = function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (Q(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (f.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          f.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, f.body.appendChild(a));
          if ("none" === G(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), Q(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === f.body) break;
        }
      };
      a.prototype.setClassName = function (b) {
        this.container.className = "highcharts-container " + (b || "");
      };
      a.prototype.getContainer = function () {
        var a = this.options,
          c = a.chart,
          e = ka(),
          h,
          g = this.renderTo;
        g || (this.renderTo = g = c.renderTo);
        R(g) && (this.renderTo = g = f.getElementById(g));
        g || U(13, !0, this);
        var n = ba(N(g, "data-highcharts-chart"));
        M(n) && w[n] && w[n].hasRendered && w[n].destroy();
        N(g, "data-highcharts-chart", this.index);
        g.innerHTML = k.emptyHTML;
        c.skipClone || g.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        n = this.chartWidth;
        var m = this.chartHeight;
        Q(g, {
          overflow: "hidden"
        });
        this.styledMode || (h = K({
          position: "relative",
          overflow: "hidden",
          width: n + "px",
          height: m + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
          userSelect: "none",
          "touch-action": "manipulation",
          outline: "none"
        }, c.style || {}));
        this.container = e = O("div", {
          id: e
        }, h, g);
        this._cursor = e.style.cursor;
        this.renderer = new (c.renderer || !b ? l.getRendererType(c.renderer) : d)(e, n, m, void 0, c.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
        A(void 0, this);
        this.setClassName(c.className);
        if (this.styledMode) for (var q in a.defs) this.renderer.definition(a.defs[q]);else this.renderer.setStyle(c.style);
        this.renderer.chartIndex = this.index;
        S(this, "afterGetContainer");
      };
      a.prototype.getMargins = function (b) {
        var a = this.spacing,
          c = this.margin,
          d = this.titleOffset;
        this.resetMargins();
        d[0] && !T(c[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + a[0]));
        d[2] && !T(c[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(c, a);
        S(this, "getMargins");
        b || this.getAxisMargins();
      };
      a.prototype.getAxisMargins = function () {
        var b = this,
          a = b.axisOffset = [0, 0, 0, 0],
          c = b.colorAxis,
          d = b.margin,
          f = function (b) {
            b.forEach(function (b) {
              b.visible && b.getOffset();
            });
          };
        b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);
        n.forEach(function (c, f) {
          T(d[f]) || (b[c] += a[f]);
        });
        b.setChartSize();
      };
      a.prototype.reflow = function (b) {
        var a = this,
          c = a.options.chart,
          d = a.renderTo,
          e = T(c.width) && T(c.height),
          h = c.width || G(d, "width");
        c = c.height || G(d, "height");
        d = b ? b.target : u;
        delete a.pointer.chartPosition;
        if (!e && !a.isPrinting && h && c && (d === u || d === f)) {
          if (h !== a.containerWidth || c !== a.containerHeight) m.clearTimeout(a.reflowTimeout), a.reflowTimeout = ia(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = h;
          a.containerHeight = c;
        }
      };
      a.prototype.setReflow = function (b) {
        var a = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = q(u, "resize", function (b) {
          a.options && a.reflow(b);
        }), q(this, "destroy", this.unbindReflow));
      };
      a.prototype.setSize = function (b, a, c) {
        var d = this,
          f = d.renderer;
        d.isResizing += 1;
        A(c, d);
        c = f.globalAnimation;
        d.oldChartHeight = d.chartHeight;
        d.oldChartWidth = d.chartWidth;
        "undefined" !== typeof b && (d.options.chart.width = b);
        "undefined" !== typeof a && (d.options.chart.height = a);
        d.getChartSize();
        d.styledMode || (c ? p : Q)(d.container, {
          width: d.chartWidth + "px",
          height: d.chartHeight + "px"
        }, c);
        d.setChartSize(!0);
        f.setSize(d.chartWidth, d.chartHeight, c);
        d.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        d.isDirtyLegend = !0;
        d.isDirtyBox = !0;
        d.layOutTitles();
        d.getMargins();
        d.redraw(c);
        d.oldChartHeight = null;
        S(d, "resize");
        ia(function () {
          d && S(d, "endResize", null, function () {
            --d.isResizing;
          });
        }, D(c).duration);
      };
      a.prototype.setChartSize = function (b) {
        var a = this.inverted,
          c = this.renderer,
          d = this.chartWidth,
          f = this.chartHeight,
          e = this.options.chart,
          h = this.spacing,
          g = this.clipOffset,
          k,
          n,
          m,
          q;
        this.plotLeft = k = Math.round(this.plotLeft);
        this.plotTop = n = Math.round(this.plotTop);
        this.plotWidth = m = Math.max(0, Math.round(d - k - this.marginRight));
        this.plotHeight = q = Math.max(0, Math.round(f - n - this.marginBottom));
        this.plotSizeX = a ? q : m;
        this.plotSizeY = a ? m : q;
        this.plotBorderWidth = e.plotBorderWidth || 0;
        this.spacingBox = c.spacingBox = {
          x: h[3],
          y: h[0],
          width: d - h[3] - h[1],
          height: f - h[0] - h[2]
        };
        this.plotBox = c.plotBox = {
          x: k,
          y: n,
          width: m,
          height: q
        };
        a = 2 * Math.floor(this.plotBorderWidth / 2);
        d = Math.ceil(Math.max(a, g[3]) / 2);
        f = Math.ceil(Math.max(a, g[0]) / 2);
        this.clipBox = {
          x: d,
          y: f,
          width: Math.floor(this.plotSizeX - Math.max(a, g[1]) / 2 - d),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a, g[2]) / 2 - f))
        };
        b || (this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        }), c.alignElements());
        S(this, "afterSetChartSize", {
          skipAxes: b
        });
      };
      a.prototype.resetMargins = function () {
        S(this, "resetMargins");
        var b = this,
          a = b.options.chart;
        ["margin", "spacing"].forEach(function (c) {
          var d = a[c],
            f = X(d) ? d : [d, d, d, d];
          ["Top", "Right", "Bottom", "Left"].forEach(function (d, e) {
            b[c][e] = W(a[c + d], f[e]);
          });
        });
        n.forEach(function (a, c) {
          b[a] = W(b.margin[c], b.spacing[c]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      };
      a.prototype.drawChartBox = function () {
        var b = this.options.chart,
          a = this.renderer,
          c = this.chartWidth,
          d = this.chartHeight,
          f = this.styledMode,
          e = this.plotBGImage,
          h = b.backgroundColor,
          g = b.plotBackgroundColor,
          k = b.plotBackgroundImage,
          n = this.plotLeft,
          m = this.plotTop,
          q = this.plotWidth,
          l = this.plotHeight,
          G = this.plotBox,
          u = this.clipRect,
          p = this.clipBox,
          M = this.chartBackground,
          v = this.plotBackground,
          w = this.plotBorder,
          r,
          z = "animate";
        M || (this.chartBackground = M = a.rect().addClass("highcharts-background").add(), z = "attr");
        if (f) var y = r = M.strokeWidth();else {
          y = b.borderWidth || 0;
          r = y + (b.shadow ? 8 : 0);
          h = {
            fill: h || "none"
          };
          if (y || M["stroke-width"]) h.stroke = b.borderColor, h["stroke-width"] = y;
          M.attr(h).shadow(b.shadow);
        }
        M[z]({
          x: r / 2,
          y: r / 2,
          width: c - r - y % 2,
          height: d - r - y % 2,
          r: b.borderRadius
        });
        z = "animate";
        v || (z = "attr", this.plotBackground = v = a.rect().addClass("highcharts-plot-background").add());
        v[z](G);
        f || (v.attr({
          fill: g || "none"
        }).shadow(b.plotShadow), k && (e ? (k !== e.attr("href") && e.attr("href", k), e.animate(G)) : this.plotBGImage = a.image(k, n, m, q, l).add()));
        u ? u.animate({
          width: p.width,
          height: p.height
        }) : this.clipRect = a.clipRect(p);
        z = "animate";
        w || (z = "attr", this.plotBorder = w = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        f || w.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        w[z](w.crisp({
          x: n,
          y: m,
          width: q,
          height: l
        }, -w.strokeWidth()));
        this.isDirtyBox = !1;
        S(this, "afterDrawChartBox");
      };
      a.prototype.propFromSeries = function () {
        var b = this,
          a = b.options.chart,
          c = b.options.series,
          d,
          f,
          e;
        ["inverted", "angular", "polar"].forEach(function (h) {
          f = z[a.type || a.defaultSeriesType];
          e = a[h] || f && f.prototype[h];
          for (d = c && c.length; !e && d--;) (f = z[c[d].type]) && f.prototype[h] && (e = !0);
          b[h] = e;
        });
      };
      a.prototype.linkSeries = function () {
        var b = this,
          a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var c = a.options.linkedTo;
          R(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = W(a.options.visible, c.options.visible, a.visible));
        });
        S(this, "afterLinkSeries");
      };
      a.prototype.renderSeries = function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      };
      a.prototype.renderLabels = function () {
        var b = this,
          a = b.options.labels;
        a.items && a.items.forEach(function (c) {
          var d = K(a.style, c.style),
            f = ba(d.left) + b.plotLeft,
            e = ba(d.top) + b.plotTop + 12;
          delete d.left;
          delete d.top;
          b.renderer.text(c.html, f, e).attr({
            zIndex: 2
          }).css(d).add();
        });
      };
      a.prototype.render = function () {
        var b = this.axes,
          a = this.colorAxis,
          c = this.renderer,
          d = this.options,
          f = function (b) {
            b.forEach(function (b) {
              b.visible && b.render();
            });
          },
          e = 0;
        this.setTitle();
        this.legend = new H(this, d.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        d = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return e = 21, !0;
        });
        var h = this.plotHeight = Math.max(this.plotHeight - e, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var g = 1.1 < d / this.plotWidth,
          k = 1.05 < h / this.plotHeight;
        if (g || k) b.forEach(function (b) {
          (b.horiz && g || !b.horiz && k) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? f(b) : a && a.length && f(a);
        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      };
      a.prototype.addCredits = function (b) {
        var a = this,
          c = V(!0, this.options.credits, b);
        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          c.href && (u.location.href = c.href);
        }).attr({
          align: c.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      };
      a.prototype.destroy = function () {
        var b = this,
          a = b.axes,
          c = b.series,
          d = b.container,
          f = d && d.parentNode,
          e;
        S(b, "destroy");
        b.renderer.forExport ? v(w, b) : w[b.index] = void 0;
        B.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        ha(b);
        for (e = a.length; e--;) a[e] = a[e].destroy();
        this.scroller && this.scroller.destroy && this.scroller.destroy();
        for (e = c.length; e--;) c[e] = c[e].destroy();
        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        d && (d.innerHTML = k.emptyHTML, ha(d), f && Y(d));
        Z(b, function (a, c) {
          delete b[c];
        });
      };
      a.prototype.firstRender = function () {
        var b = this,
          a = b.options;
        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (P(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          S(b, "beforeRender");
          r && (t.isRequired() ? b.pointer = new t(b, a) : b.pointer = new r(b, a));
          b.render();
          b.pointer.getChartPosition();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      };
      a.prototype.onload = function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        S(this, "load");
        S(this, "render");
        T(this.index) && this.setReflow(this.options.chart.reflow);
        this.warnIfA11yModuleNotLoaded();
        this.hasLoaded = !0;
      };
      a.prototype.warnIfA11yModuleNotLoaded = function () {
        var b = this.options,
          a = this.title;
        b && !this.accessibility && (this.renderer.boxWrapper.attr({
          role: "img",
          "aria-label": (a && a.element.textContent || "").replace(/</g, "&lt;")
        }), b.accessibility && !1 === b.accessibility.enabled || U('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
      };
      a.prototype.addSeries = function (b, a, c) {
        var d = this,
          f;
        b && (a = W(a, !0), S(d, "addSeries", {
          options: b
        }, function () {
          f = d.initSeries(b);
          d.isDirtyLegend = !0;
          d.linkSeries();
          f.enabledDataSorting && f.setData(b.data, !1);
          S(d, "afterAddSeries", {
            series: f
          });
          a && d.redraw(c);
        }));
        return f;
      };
      a.prototype.addAxis = function (b, a, c, d) {
        return this.createAxis(a ? "xAxis" : "yAxis", {
          axis: b,
          redraw: c,
          animation: d
        });
      };
      a.prototype.addColorAxis = function (b, a, c) {
        return this.createAxis("colorAxis", {
          axis: b,
          redraw: a,
          animation: c
        });
      };
      a.prototype.createAxis = function (b, a) {
        b = new g(this, V(a.axis, {
          index: this[b].length,
          isX: "xAxis" === b
        }));
        W(a.redraw, !0) && this.redraw(a.animation);
        return b;
      };
      a.prototype.showLoading = function (b) {
        var a = this,
          c = a.options,
          d = c.loading,
          f = function () {
            e && Q(e, {
              left: a.plotLeft + "px",
              top: a.plotTop + "px",
              width: a.plotWidth + "px",
              height: a.plotHeight + "px"
            });
          },
          e = a.loadingDiv,
          h = a.loadingSpan;
        e || (a.loadingDiv = e = O("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, a.container));
        h || (a.loadingSpan = h = O("span", {
          className: "highcharts-loading-inner"
        }, null, e), q(a, "redraw", f));
        e.className = "highcharts-loading";
        k.setElementHTML(h, W(b, c.lang.loading, ""));
        a.styledMode || (Q(e, K(d.style, {
          zIndex: 10
        })), Q(h, d.labelStyle), a.loadingShown || (Q(e, {
          opacity: 0,
          display: ""
        }), p(e, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        a.loadingShown = !0;
        f();
      };
      a.prototype.hideLoading = function () {
        var b = this.options,
          a = this.loadingDiv;
        a && (a.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || p(a, {
          opacity: 0
        }, {
          duration: b.loading.hideDuration || 100,
          complete: function () {
            Q(a, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      };
      a.prototype.update = function (b, a, d, f) {
        var e = this,
          g = {
            credits: "addCredits",
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          },
          k = b.isResponsiveOptions,
          n = [],
          m,
          q;
        S(e, "update", {
          options: b
        });
        k || e.setResponsive(!1, !0);
        b = J(b, e.options);
        e.userOptions = V(e.userOptions, b);
        var l = b.chart;
        if (l) {
          V(!0, e.options.chart, l);
          "className" in l && e.setClassName(l.className);
          "reflow" in l && e.setReflow(l.reflow);
          if ("inverted" in l || "polar" in l || "type" in l) {
            e.propFromSeries();
            var G = !0;
          }
          "alignTicks" in l && (G = !0);
          "events" in l && c(this, l);
          Z(l, function (b, a) {
            -1 !== e.propsRequireUpdateSeries.indexOf("chart." + a) && (m = !0);
            -1 !== e.propsRequireDirtyBox.indexOf(a) && (e.isDirtyBox = !0);
            -1 !== e.propsRequireReflow.indexOf(a) && (k ? e.isDirtyBox = !0 : q = !0);
          });
          !e.styledMode && l.style && e.renderer.setStyle(e.options.chart.style || {});
        }
        !e.styledMode && b.colors && (this.options.colors = b.colors);
        b.time && (this.time === L && (this.time = new h(b.time)), V(!0, e.options.time, b.time));
        Z(b, function (a, c) {
          if (e[c] && "function" === typeof e[c].update) e[c].update(a, !1);else if ("function" === typeof e[g[c]]) e[g[c]](a);else "colors" !== c && -1 === e.collectionsWithUpdate.indexOf(c) && V(!0, e.options[c], b[c]);
          "chart" !== c && -1 !== e.propsRequireUpdateSeries.indexOf(c) && (m = !0);
        });
        this.collectionsWithUpdate.forEach(function (a) {
          if (b[a]) {
            var c = [];
            e[a].forEach(function (b, a) {
              b.options.isInternal || c.push(W(b.options.index, a));
            });
            ea(b[a]).forEach(function (b, f) {
              var h = T(b.id),
                g;
              h && (g = e.get(b.id));
              !g && e[a] && (g = e[a][c ? c[f] : f]) && h && T(g.options.id) && (g = void 0);
              g && g.coll === a && (g.update(b, !1), d && (g.touched = !0));
              !g && d && e.collectionsWithInit[a] && (e.collectionsWithInit[a][0].apply(e, [b].concat(e.collectionsWithInit[a][1] || []).concat([!1])).touched = !0);
            });
            d && e[a].forEach(function (b) {
              b.touched || b.options.isInternal ? delete b.touched : n.push(b);
            });
          }
        });
        n.forEach(function (b) {
          b.chart && b.remove && b.remove(!1);
        });
        G && e.axes.forEach(function (b) {
          b.update({}, !1);
        });
        m && e.getSeriesOrderByLinks().forEach(function (b) {
          b.chart && b.update({}, !1);
        }, this);
        G = l && l.width;
        l = l && (R(l.height) ? fa(l.height, G || e.chartWidth) : l.height);
        q || M(G) && G !== e.chartWidth || M(l) && l !== e.chartHeight ? e.setSize(G, l, f) : W(a, !0) && e.redraw(f);
        S(e, "afterUpdate", {
          options: b,
          redraw: a,
          animation: f
        });
      };
      a.prototype.setSubtitle = function (b, a) {
        this.applyDescription("subtitle", b);
        this.layOutTitles(a);
      };
      a.prototype.setCaption = function (b, a) {
        this.applyDescription("caption", b);
        this.layOutTitles(a);
      };
      a.prototype.showResetZoom = function () {
        function b() {
          a.zoomOut();
        }
        var a = this,
          c = E.lang,
          d = a.options.chart.zooming.resetButton,
          f = d.theme,
          e = "chart" === d.relativeTo || "spacingBox" === d.relativeTo ? null : "scrollablePlotBox";
        S(this, "beforeShowResetZoom", null, function () {
          a.resetZoomButton = a.renderer.button(c.resetZoom, null, null, b, f).attr({
            align: d.position.align,
            title: c.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(d.position, !1, e);
        });
        S(this, "afterShowResetZoom");
      };
      a.prototype.zoomOut = function () {
        S(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      };
      a.prototype.zoom = function (b) {
        var a = this,
          c = a.pointer,
          d = !1,
          f;
        !b || b.resetSelection ? (a.axes.forEach(function (b) {
          f = b.zoom();
        }), c.initiated = !1) : b.xAxis.concat(b.yAxis).forEach(function (b) {
          var e = b.axis;
          if (c[e.isXAxis ? "zoomX" : "zoomY"] && T(c.mouseDownX) && T(c.mouseDownY) && a.isInsidePlot(c.mouseDownX - a.plotLeft, c.mouseDownY - a.plotTop, {
            axis: e
          }) || !T(a.inverted ? c.mouseDownX : c.mouseDownY)) f = e.zoom(b.min, b.max), e.displayBtn && (d = !0);
        });
        var e = a.resetZoomButton;
        d && !e ? a.showResetZoom() : !d && X(e) && (a.resetZoomButton = e.destroy());
        f && a.redraw(W(a.options.chart.animation, b && b.animation, 100 > a.pointCount));
      };
      a.prototype.pan = function (b, a) {
        var c = this,
          d = c.hoverPoints;
        a = "object" === typeof a ? a : {
          enabled: a,
          type: "x"
        };
        var f = c.options.chart;
        f && f.panning && (f.panning = a);
        var e = a.type,
          h;
        S(this, "pan", {
          originalEvent: b
        }, function () {
          d && d.forEach(function (b) {
            b.setState();
          });
          var a = c.xAxis;
          "xy" === e ? a = a.concat(c.yAxis) : "y" === e && (a = c.yAxis);
          var f = {};
          a.forEach(function (a) {
            if (a.options.panningEnabled && !a.options.isInternal) {
              var d = a.horiz,
                g = b[d ? "chartX" : "chartY"];
              d = d ? "mouseDownX" : "mouseDownY";
              var k = c[d],
                n = a.minPointOffset || 0,
                m = a.reversed && !c.inverted || !a.reversed && c.inverted ? -1 : 1,
                l = a.getExtremes(),
                q = a.toValue(k - g, !0) + n * m,
                G = a.toValue(k + a.len - g, !0) - (n * m || a.isXAxis && a.pointRangePadding || 0),
                u = G < q;
              m = a.hasVerticalPanning();
              k = u ? G : q;
              q = u ? q : G;
              var p = a.panningState;
              !m || a.isXAxis || p && !p.isDirty || a.series.forEach(function (b) {
                var a = b.getProcessedData(!0);
                a = b.getExtremes(a.yData, !0);
                p || (p = {
                  startMin: Number.MAX_VALUE,
                  startMax: -Number.MAX_VALUE
                });
                M(a.dataMin) && M(a.dataMax) && (p.startMin = Math.min(W(b.options.threshold, Infinity), a.dataMin, p.startMin), p.startMax = Math.max(W(b.options.threshold, -Infinity), a.dataMax, p.startMax));
              });
              m = Math.min(W(p && p.startMin, l.dataMin), n ? l.min : a.toValue(a.toPixels(l.min) - a.minPixelPadding));
              G = Math.max(W(p && p.startMax, l.dataMax), n ? l.max : a.toValue(a.toPixels(l.max) + a.minPixelPadding));
              a.panningState = p;
              a.isOrdinal || (n = m - k, 0 < n && (q += n, k = m), n = q - G, 0 < n && (q = G, k -= n), a.series.length && k !== l.min && q !== l.max && k >= m && q <= G && (a.setExtremes(k, q, !1, !1, {
                trigger: "pan"
              }), !c.resetZoomButton && k !== m && q !== G && e.match("y") && (c.showResetZoom(), a.displayBtn = !1), h = !0), f[d] = g);
            }
          });
          Z(f, function (b, a) {
            c[a] = b;
          });
          h && c.redraw(!1);
          Q(c.container, {
            cursor: "move"
          });
        });
      };
      return a;
    }();
    K(a.prototype, {
      callbacks: [],
      collectionsWithInit: {
        xAxis: [a.prototype.addAxis, [!0]],
        yAxis: [a.prototype.addAxis, [!1]],
        series: [a.prototype.addSeries]
      },
      collectionsWithUpdate: ["xAxis", "yAxis", "series"],
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
    });
    "";
    return a;
  });
  K(g, "Core/Legend/LegendSymbol.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.extend,
      x = a.merge,
      F = a.pick,
      C;
    (function (a) {
      a.drawLineMarker = function (a) {
        var t = this.legendItem = this.legendItem || {},
          r = this.options,
          l = a.symbolWidth,
          e = a.symbolHeight,
          d = e / 2,
          h = this.chart.renderer,
          m = t.group;
        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
        var k = {},
          p = r.marker,
          D = 0;
        this.chart.styledMode || (k = {
          "stroke-width": Math.min(r.lineWidth || 0, 24)
        }, r.dashStyle ? k.dashstyle = r.dashStyle : "square" !== r.linecap && (k["stroke-linecap"] = "round"));
        t.line = h.path().addClass("highcharts-graph").attr(k).add(m);
        k["stroke-linecap"] && (D = Math.min(t.line.strokeWidth(), l) / 2);
        t.line.attr({
          d: [["M", D, a], ["L", l - D, a]]
        });
        p && !1 !== p.enabled && l && (r = Math.min(F(p.radius, d), d), 0 === this.symbol.indexOf("url") && (p = x(p, {
          width: e,
          height: e
        }), r = 0), t.symbol = t = h.symbol(this.symbol, l / 2 - r, a - r, 2 * r, 2 * r, g({
          context: "legend"
        }, p)).addClass("highcharts-point").add(m), t.isMarker = !0);
      };
      a.drawRectangle = function (a, g) {
        g = g.legendItem || {};
        var r = a.symbolHeight,
          l = a.options.squareSymbol;
        g.symbol = this.chart.renderer.rect(l ? (a.symbolWidth - r) / 2 : 0, a.baseline - r + 1, l ? r : a.symbolWidth, r, F(a.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(g.group);
      };
    })(C || (C = {}));
    return C;
  });
  K(g, "Core/Series/SeriesDefaults.js", [], function () {
    return {
      lineWidth: 2,
      allowPointSelect: !1,
      crisp: !0,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        animation: {},
        align: "center",
        borderWidth: 0,
        defer: !0,
        formatter: function () {
          var a = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : a(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    };
  });
  K(g, "Core/Series/Series.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Defaults.js"], g["Core/Foundation.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/Point.js"], g["Core/Series/SeriesDefaults.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B, H, t, r, l) {
    var e = a.animObject,
      d = a.setAnimation,
      h = g.defaultOptions,
      m = x.registerEventOptions,
      k = F.hasTouch,
      p = F.svg,
      D = F.win,
      A = t.seriesTypes,
      E = l.arrayMax,
      L = l.arrayMin,
      y = l.clamp,
      c = l.cleanRecursively,
      w = l.correctFloat,
      f = l.defined,
      n = l.erase,
      b = l.error,
      u = l.extend,
      z = l.find,
      q = l.fireEvent,
      N = l.getNestedProperty,
      J = l.isArray,
      O = l.isNumber,
      Q = l.isString,
      T = l.merge,
      Y = l.objectEach,
      v = l.pick,
      U = l.removeEvent,
      K = l.splat,
      ca = l.syncTimeout;
    a = function () {
      function a() {
        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
      }
      a.prototype.init = function (b, a) {
        q(this, "init", {
          options: a
        });
        var c = this,
          d = b.series;
        this.eventsToUnbind = [];
        c.chart = b;
        c.options = c.setOptions(a);
        a = c.options;
        c.linkedSeries = [];
        c.bindAxes();
        u(c, {
          name: a.name,
          state: "",
          visible: !1 !== a.visible,
          selected: !0 === a.selected
        });
        m(this, a);
        var f = a.events;
        if (f && f.click || a.point && a.point.events && a.point.events.click || a.allowPointSelect) b.runTrackerClick = !0;
        c.getColor();
        c.getSymbol();
        c.parallelArrays.forEach(function (b) {
          c[b + "Data"] || (c[b + "Data"] = []);
        });
        c.isCartesian && (b.hasCartesianSeries = !0);
        var e;
        d.length && (e = d[d.length - 1]);
        c._i = v(e && e._i, -1) + 1;
        c.opacity = c.options.opacity;
        b.orderSeries(this.insert(d));
        a.dataSorting && a.dataSorting.enabled ? c.setDataSortingOptions() : c.points || c.data || c.setData(a.data, !1);
        q(this, "afterInit");
      };
      a.prototype.is = function (b) {
        return A[b] && this instanceof A[b];
      };
      a.prototype.insert = function (b) {
        var a = this.options.index,
          c;
        if (O(a)) {
          for (c = b.length; c--;) if (a >= v(b[c].options.index, b[c]._i)) {
            b.splice(c + 1, 0, this);
            break;
          }
          -1 === c && b.unshift(this);
          c += 1;
        } else b.push(this);
        return v(c, b.length - 1);
      };
      a.prototype.bindAxes = function () {
        var a = this,
          c = a.options,
          d = a.chart,
          f;
        q(this, "bindAxes", null, function () {
          (a.axisTypes || []).forEach(function (e) {
            var h = 0;
            d[e].forEach(function (b) {
              f = b.options;
              if (c[e] === h && !f.isInternal || "undefined" !== typeof c[e] && c[e] === f.id || "undefined" === typeof c[e] && 0 === f.index) a.insert(b.series), a[e] = b, b.isDirty = !0;
              f.isInternal || h++;
            });
            a[e] || a.optionalAxis === e || b(18, !0, d);
          });
        });
        q(this, "afterBindAxes");
      };
      a.prototype.updateParallelArrays = function (b, a) {
        var c = b.series,
          d = arguments,
          f = O(a) ? function (d) {
            var f = "y" === d && c.toYData ? c.toYData(b) : b[d];
            c[d + "Data"][a] = f;
          } : function (b) {
            Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(d, 2));
          };
        c.parallelArrays.forEach(f);
      };
      a.prototype.hasData = function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      };
      a.prototype.autoIncrement = function (b) {
        var a = this.options,
          c = a.pointIntervalUnit,
          d = a.relativeXValue,
          f = this.chart.time,
          e = this.xIncrement,
          h;
        e = v(e, a.pointStart, 0);
        this.pointInterval = h = v(this.pointInterval, a.pointInterval, 1);
        d && O(b) && (h *= b);
        c && (a = new f.Date(e), "day" === c ? f.set("Date", a, f.get("Date", a) + h) : "month" === c ? f.set("Month", a, f.get("Month", a) + h) : "year" === c && f.set("FullYear", a, f.get("FullYear", a) + h), h = a.getTime() - e);
        if (d && O(b)) return e + h;
        this.xIncrement = e + h;
        return e;
      };
      a.prototype.setDataSortingOptions = function () {
        var b = this.options;
        u(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        f(b.pointRange) || (b.pointRange = 1);
      };
      a.prototype.setOptions = function (b) {
        var a = this.chart,
          c = a.options,
          d = c.plotOptions,
          e = a.userOptions || {};
        b = T(b);
        a = a.styledMode;
        var g = {
          plotOptions: d,
          userOptions: b
        };
        q(this, "setOptions", g);
        var k = g.plotOptions[this.type],
          n = e.plotOptions || {};
        this.userOptions = g.userOptions;
        e = T(k, d.series, e.plotOptions && e.plotOptions[this.type], b);
        this.tooltipOptions = T(h.tooltip, h.plotOptions.series && h.plotOptions.series.tooltip, h.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, b.tooltip);
        this.stickyTracking = v(b.stickyTracking, n[this.type] && n[this.type].stickyTracking, n.series && n.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);
        null === k.marker && delete e.marker;
        this.zoneAxis = e.zoneAxis;
        d = this.zones = (e.zones || []).slice();
        !e.negativeColor && !e.negativeFillColor || e.zones || (c = {
          value: e[this.zoneAxis + "Threshold"] || e.threshold || 0,
          className: "highcharts-negative"
        }, a || (c.color = e.negativeColor, c.fillColor = e.negativeFillColor), d.push(c));
        d.length && f(d[d.length - 1].value) && d.push(a ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        q(this, "afterSetOptions", {
          options: e
        });
        return e;
      };
      a.prototype.getName = function () {
        return v(this.options.name, "Series " + (this.index + 1));
      };
      a.prototype.getCyclic = function (b, a, c) {
        var d = this.chart,
          e = this.userOptions,
          h = b + "Index",
          g = b + "Counter",
          k = c ? c.length : v(d.options.chart[b + "Count"], d[b + "Count"]);
        if (!a) {
          var n = v(e[h], e["_" + h]);
          f(n) || (d.series.length || (d[g] = 0), e["_" + h] = n = d[g] % k, d[g] += 1);
          c && (a = c[n]);
        }
        "undefined" !== typeof n && (this[h] = n);
        this[b] = a;
      };
      a.prototype.getColor = function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || h.plotOptions[this.type].color, this.chart.options.colors);
      };
      a.prototype.getPointsCollection = function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      };
      a.prototype.getSymbol = function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      };
      a.prototype.findPointIndex = function (b, a) {
        var c = b.id,
          d = b.x,
          f = this.points,
          e = this.options.dataSorting,
          h,
          g;
        if (c) e = this.chart.get(c), e instanceof B && (h = e);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (h = function (a) {
          return !a.touched && a.index === b.index;
        }, e && e.matchByName ? h = function (a) {
          return !a.touched && a.name === b.name;
        } : this.options.relativeXValue && (h = function (a) {
          return !a.touched && a.options.x === b.x;
        }), h = z(f, h), !h) return;
        if (h) {
          var k = h && h.index;
          "undefined" !== typeof k && (g = !0);
        }
        "undefined" === typeof k && O(d) && (k = this.xData.indexOf(d, a));
        -1 !== k && "undefined" !== typeof k && this.cropped && (k = k >= this.cropStart ? k - this.cropStart : k);
        !g && O(k) && f[k] && f[k].touched && (k = void 0);
        return k;
      };
      a.prototype.updateData = function (b, a) {
        var c = this.options,
          d = c.dataSorting,
          e = this.points,
          h = [],
          g = this.requireSorting,
          k = b.length === e.length,
          n,
          m,
          q,
          l = !0;
        this.xIncrement = null;
        b.forEach(function (b, a) {
          var m = f(b) && this.pointClass.prototype.optionsToObject.call({
              series: this
            }, b) || {},
            l = m.x;
          if (m.id || O(l)) {
            if (m = this.findPointIndex(m, q), -1 === m || "undefined" === typeof m ? h.push(b) : e[m] && b !== c.data[m] ? (e[m].update(b, !1, null, !1), e[m].touched = !0, g && (q = m + 1)) : e[m] && (e[m].touched = !0), !k || a !== m || d && d.enabled || this.hasDerivedData) n = !0;
          } else h.push(b);
        }, this);
        if (n) for (b = e.length; b--;) (m = e[b]) && !m.touched && m.remove && m.remove(!1, a);else !k || d && d.enabled ? l = !1 : (b.forEach(function (b, a) {
          b !== e[a].y && e[a].update && e[a].update(b, !1, null, !1);
        }), h.length = 0);
        e.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!l) return !1;
        h.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = E(this.xData), this.autoIncrement());
        return !0;
      };
      a.prototype.setData = function (a, c, d, f) {
        void 0 === c && (c = !0);
        var e = this,
          h = e.points,
          g = h && h.length || 0,
          k = e.options,
          n = e.chart,
          m = k.dataSorting,
          l = e.xAxis,
          q = k.turboThreshold,
          u = this.xData,
          p = this.yData,
          G = e.pointArrayMap;
        G = G && G.length;
        var v = k.keys,
          w,
          r = 0,
          z = 1,
          y = null;
        if (!n.options.chart.allowMutatingData) {
          k.data && delete e.options.data;
          e.userOptions.data && delete e.userOptions.data;
          var M = T(!0, a);
        }
        a = M || a || [];
        M = a.length;
        m && m.enabled && (a = this.sortData(a));
        n.options.chart.allowMutatingData && !1 !== f && M && g && !e.cropped && !e.hasGroupedData && e.visible && !e.boosted && (w = this.updateData(a, d));
        if (!w) {
          e.xIncrement = null;
          e.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            e[b + "Data"].length = 0;
          });
          if (q && M > q) {
            if (y = e.getFirstValidPoint(a), O(y)) for (d = 0; d < M; d++) u[d] = this.autoIncrement(), p[d] = a[d];else if (J(y)) {
              if (G) {
                if (y.length === G) for (d = 0; d < M; d++) u[d] = this.autoIncrement(), p[d] = a[d];else for (d = 0; d < M; d++) f = a[d], u[d] = f[0], p[d] = f.slice(1, G + 1);
              } else if (v && (r = v.indexOf("x"), z = v.indexOf("y"), r = 0 <= r ? r : 0, z = 0 <= z ? z : 1), 1 === y.length && (z = 0), r === z) for (d = 0; d < M; d++) u[d] = this.autoIncrement(), p[d] = a[d][z];else for (d = 0; d < M; d++) f = a[d], u[d] = f[r], p[d] = f[z];
            } else b(12, !1, n);
          } else for (d = 0; d < M; d++) "undefined" !== typeof a[d] && (f = {
            series: e
          }, e.pointClass.prototype.applyOptions.apply(f, [a[d]]), e.updateParallelArrays(f, d));
          p && Q(p[0]) && b(14, !0, n);
          e.data = [];
          e.options.data = e.userOptions.data = a;
          for (d = g; d--;) h[d] && h[d].destroy && h[d].destroy();
          l && (l.minRange = l.userMinRange);
          e.isDirty = n.isDirtyBox = !0;
          e.isDirtyData = !!h;
          d = !1;
        }
        "point" === k.legendType && (this.processData(), this.generatePoints());
        c && n.redraw(d);
      };
      a.prototype.sortData = function (b) {
        var a = this,
          c = a.options.dataSorting.sortKey || "y",
          d = function (b, a) {
            return f(a) && b.pointClass.prototype.optionsToObject.call({
              series: b
            }, a) || {};
          };
        b.forEach(function (c, e) {
          b[e] = d(a, c);
          b[e].index = e;
        }, this);
        b.concat().sort(function (b, a) {
          b = N(c, b);
          a = N(c, a);
          return a < b ? -1 : a > b ? 1 : 0;
        }).forEach(function (b, a) {
          b.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var c = a.options,
            e = c.data;
          c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, f) {
            e[f] = d(a, c);
            b[f] && (e[f].x = b[f].x, e[f].index = f);
          }), a.setData(e, !1));
        });
        return b;
      };
      a.prototype.getProcessedData = function (a) {
        var c = this.xAxis,
          d = this.options,
          e = d.cropThreshold,
          f = a || this.getExtremesFromAll || d.getExtremesFromAll,
          h = this.isCartesian;
        a = c && c.val2lin;
        d = !(!c || !c.logarithmic);
        var g = 0,
          k = this.xData,
          n = this.yData,
          m = this.requireSorting;
        var l = !1;
        var q = k.length;
        if (c) {
          l = c.getExtremes();
          var u = l.min;
          var p = l.max;
          l = !(!c.categories || c.names.length);
        }
        if (h && this.sorted && !f && (!e || q > e || this.forceCrop)) if (k[q - 1] < u || k[0] > p) k = [], n = [];else if (this.yData && (k[0] < u || k[q - 1] > p)) {
          var G = this.cropData(this.xData, this.yData, u, p);
          k = G.xData;
          n = G.yData;
          g = G.start;
          G = !0;
        }
        for (e = k.length || 1; --e;) if (c = d ? a(k[e]) - a(k[e - 1]) : k[e] - k[e - 1], 0 < c && ("undefined" === typeof v || c < v)) var v = c;else 0 > c && m && !l && (b(15, !1, this.chart), m = !1);
        return {
          xData: k,
          yData: n,
          cropped: G,
          cropStart: g,
          closestPointRange: v
        };
      };
      a.prototype.processData = function (b) {
        var a = this.xAxis;
        if (this.isCartesian && !this.isDirty && !a.isDirty && !this.yAxis.isDirty && !b) return !1;
        b = this.getProcessedData();
        this.cropped = b.cropped;
        this.cropStart = b.cropStart;
        this.processedXData = b.xData;
        this.processedYData = b.yData;
        this.closestPointRange = this.basePointRange = b.closestPointRange;
        q(this, "afterProcessData");
      };
      a.prototype.cropData = function (b, a, c, d, e) {
        var f = b.length,
          h,
          g = 0,
          k = f;
        e = v(e, this.cropShoulder);
        for (h = 0; h < f; h++) if (b[h] >= c) {
          g = Math.max(0, h - e);
          break;
        }
        for (c = h; c < f; c++) if (b[c] > d) {
          k = c + e;
          break;
        }
        return {
          xData: b.slice(g, k),
          yData: a.slice(g, k),
          start: g,
          end: k
        };
      };
      a.prototype.generatePoints = function () {
        var b = this.options,
          a = this.processedData || b.data,
          c = this.processedXData,
          d = this.processedYData,
          e = this.pointClass,
          f = c.length,
          h = this.cropStart || 0,
          g = this.hasGroupedData,
          k = b.keys,
          n = [];
        b = b.dataGrouping && b.dataGrouping.groupAll ? h : 0;
        var m,
          l,
          p = this.data;
        if (!p && !g) {
          var v = [];
          v.length = a.length;
          p = this.data = v;
        }
        k && g && (this.options.keys = !1);
        for (l = 0; l < f; l++) {
          v = h + l;
          if (g) {
            var r = new e().init(this, [c[l]].concat(K(d[l])));
            r.dataGroup = this.groupMap[b + l];
            r.dataGroup.options && (r.options = r.dataGroup.options, u(r, r.dataGroup.options), delete r.dataLabels);
          } else (r = p[v]) || "undefined" === typeof a[v] || (p[v] = r = new e().init(this, a[v], c[l]));
          r && (r.index = g ? b + l : v, n[l] = r);
        }
        this.options.keys = k;
        if (p && (f !== (m = p.length) || g)) for (l = 0; l < m; l++) l !== h || g || (l += f), p[l] && (p[l].destroyElements(), p[l].plotX = void 0);
        this.data = p;
        this.points = n;
        q(this, "afterGeneratePoints");
      };
      a.prototype.getXExtremes = function (b) {
        return {
          min: L(b),
          max: E(b)
        };
      };
      a.prototype.getExtremes = function (b, a) {
        var c = this.xAxis,
          d = this.yAxis,
          e = this.processedXData || this.xData,
          f = [],
          h = this.requireSorting ? this.cropShoulder : 0;
        d = d ? d.positiveValuesOnly : !1;
        var g,
          k = 0,
          n = 0,
          m = 0;
        b = b || this.stackedYData || this.processedYData || [];
        var l = b.length;
        if (c) {
          var p = c.getExtremes();
          k = p.min;
          n = p.max;
        }
        for (g = 0; g < l; g++) {
          var u = e[g];
          p = b[g];
          var G = (O(p) || J(p)) && (p.length || 0 < p || !d);
          u = a || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (e[g + h] || u) >= k && (e[g - h] || u) <= n;
          if (G && u) if (G = p.length) for (; G--;) O(p[G]) && (f[m++] = p[G]);else f[m++] = p;
        }
        b = {
          activeYData: f,
          dataMin: L(f),
          dataMax: E(f)
        };
        q(this, "afterGetExtremes", {
          dataExtremes: b
        });
        return b;
      };
      a.prototype.applyExtremes = function () {
        var b = this.getExtremes();
        this.dataMin = b.dataMin;
        this.dataMax = b.dataMax;
        return b;
      };
      a.prototype.getFirstValidPoint = function (b) {
        for (var a = b.length, c = 0, d = null; null === d && c < a;) d = b[c], c++;
        return d;
      };
      a.prototype.translate = function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var b = this.options,
          a = b.stacking,
          c = this.xAxis,
          d = c.categories,
          e = this.enabledDataSorting,
          h = this.yAxis,
          g = this.points,
          k = g.length,
          n = this.pointPlacementToXValue(),
          m = !!n,
          l = b.threshold,
          p = b.startFromThreshold ? l : 0,
          u = this.zoneAxis || "y",
          r,
          z,
          t = Number.MAX_VALUE;
        for (r = 0; r < k; r++) {
          var D = g[r],
            E = D.x,
            A = void 0,
            N = void 0,
            I = D.y,
            x = D.low,
            C = a && h.stacking && h.stacking.stacks[(this.negStacks && I < (p ? 0 : l) ? "-" : "") + this.stackKey];
          if (h.positiveValuesOnly && !h.validatePositiveValue(I) || c.positiveValuesOnly && !c.validatePositiveValue(E)) D.isNull = !0;
          D.plotX = z = w(y(c.translate(E, 0, 0, 0, 1, n, "flags" === this.type), -1E5, 1E5));
          if (a && this.visible && C && C[E]) {
            var L = this.getStackIndicator(L, E, this.index);
            !D.isNull && L.key && (A = C[E], N = A.points[L.key]);
            A && J(N) && (x = N[0], I = N[1], x === p && L.key === C[E].base && (x = v(O(l) ? l : h.min)), h.positiveValuesOnly && f(x) && 0 >= x && (x = void 0), D.total = D.stackTotal = v(A.total), D.percentage = f(D.y) && A.total ? D.y / A.total * 100 : void 0, D.stackY = I, this.irregularWidths || A.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis));
          }
          D.yBottom = f(x) ? y(h.translate(x, 0, 1, 0, 1), -1E5, 1E5) : void 0;
          this.dataModify && (I = this.dataModify.modifyValue(I, r));
          D.plotY = void 0;
          O(I) && (A = h.translate(I, !1, !0, !1, !0), "undefined" !== typeof A && (D.plotY = y(A, -1E5, 1E5)));
          D.isInside = this.isPointInside(D);
          D.clientX = m ? w(c.translate(E, 0, 0, 0, 1, n)) : z;
          D.negative = D[u] < (b[u + "Threshold"] || l || 0);
          D.category = v(d && d[D.x], D.x);
          if (!D.isNull && !1 !== D.visible) {
            "undefined" !== typeof B && (t = Math.min(t, Math.abs(z - B)));
            var B = z;
          }
          D.zone = this.zones.length ? D.getZone() : void 0;
          !D.graphic && this.group && e && (D.isNew = !0);
        }
        this.closestPointRangePx = t;
        q(this, "afterTranslate");
      };
      a.prototype.getValidPoints = function (b, a, c) {
        var d = this.chart;
        return (b || this.points || []).filter(function (b) {
          return a && !d.isInsidePlot(b.plotX, b.plotY, {
            inverted: d.inverted
          }) ? !1 : !1 !== b.visible && (c || !b.isNull);
        });
      };
      a.prototype.getClipBox = function () {
        var b = this.chart,
          a = this.xAxis,
          c = this.yAxis,
          d = T(b.clipBox);
        a && a.len !== b.plotSizeX && (d.width = a.len);
        c && c.len !== b.plotSizeY && (d.height = c.len);
        return d;
      };
      a.prototype.getSharedClipKey = function () {
        return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
      };
      a.prototype.setClip = function () {
        var b = this.chart,
          a = this.group,
          c = this.markerGroup,
          d = b.sharedClips;
        b = b.renderer;
        var e = this.getClipBox(),
          f = this.getSharedClipKey(),
          h = d[f];
        h ? h.animate(e) : d[f] = h = b.clipRect(e);
        a && a.clip(!1 === this.options.clip ? void 0 : h);
        c && c.clip();
      };
      a.prototype.animate = function (b) {
        var a = this.chart,
          c = this.group,
          d = this.markerGroup,
          f = a.inverted,
          h = e(this.options.animation),
          g = [this.getSharedClipKey(), h.duration, h.easing, h.defer].join(),
          k = a.sharedClips[g],
          n = a.sharedClips[g + "m"];
        if (b && c) h = this.getClipBox(), k ? k.attr("height", h.height) : (h.width = 0, f && (h.x = a.plotHeight), k = a.renderer.clipRect(h), a.sharedClips[g] = k, n = a.renderer.clipRect({
          x: -99,
          y: -99,
          width: f ? a.plotWidth + 199 : 99,
          height: f ? 99 : a.plotHeight + 199
        }), a.sharedClips[g + "m"] = n), c.clip(k), d && d.clip(n);else if (k && !k.hasClass("highcharts-animating")) {
          a = this.getClipBox();
          var m = h.step;
          d && d.element.childNodes.length && (h.step = function (b, a) {
            m && m.apply(a, arguments);
            "width" === a.prop && n && n.element && n.attr(f ? "height" : "width", b + 99);
          });
          k.addClass("highcharts-animating").animate(a, h);
        }
      };
      a.prototype.afterAnimate = function () {
        var b = this;
        this.setClip();
        Y(this.chart.sharedClips, function (a, c, d) {
          a && !b.chart.container.querySelector('[clip-path="url(#'.concat(a.id, ')"]')) && (a.destroy(), delete d[c]);
        });
        this.finishedAnimating = !0;
        q(this, "afterAnimate");
      };
      a.prototype.drawPoints = function (b) {
        void 0 === b && (b = this.points);
        var a = this.chart,
          c = a.styledMode,
          d = this.colorAxis,
          e = this.options.marker,
          f = this[this.specialGroup || "markerGroup"],
          h = this.xAxis,
          g = v(e.enabled, !h || h.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius),
          k,
          n;
        if (!1 !== e.enabled || this._hasPointMarkers) for (k = 0; k < b.length; k++) {
          var m = b[k];
          var l = (n = m.graphic) ? "animate" : "attr";
          var q = m.marker || {};
          var p = !!m.marker;
          if ((g && "undefined" === typeof q.enabled || q.enabled) && !m.isNull && !1 !== m.visible) {
            var u = v(q.symbol, this.symbol, "rect");
            var G = this.markerAttribs(m, m.selected && "select");
            this.enabledDataSorting && (m.startXPos = h.reversed ? -(G.width || 0) : h.width);
            var r = !1 !== m.isInside;
            !n && r && (0 < (G.width || 0) || m.hasImage) && (m.graphic = n = a.renderer.symbol(u, G.x, G.y, G.width, G.height, p ? q : e).add(f), this.enabledDataSorting && a.hasRendered && (n.attr({
              x: m.startXPos
            }), l = "animate"));
            n && "animate" === l && n[r ? "show" : "hide"](r).animate(G);
            if (n) if (q = this.pointAttribs(m, c || !m.selected ? void 0 : "select"), c) d && n.css({
              fill: q.fill
            });else n[l](q);
            n && n.addClass(m.getClassName(), !0);
          } else n && (m.graphic = n.destroy());
        }
      };
      a.prototype.markerAttribs = function (b, a) {
        var c = this.options,
          d = c.marker,
          e = b.marker || {},
          f = e.symbol || d.symbol,
          h = {},
          g = v(e.radius, d && d.radius);
        a && (d = d.states[a], a = e.states && e.states[a], g = v(a && a.radius, d && d.radius, g && g + (d && d.radiusPlus || 0)));
        b.hasImage = f && 0 === f.indexOf("url");
        b.hasImage && (g = 0);
        b = b.pos();
        O(g) && b && (h.x = b[0] - g, h.y = b[1] - g, c.crisp && (h.x = Math.floor(h.x)));
        g && (h.width = h.height = 2 * g);
        return h;
      };
      a.prototype.pointAttribs = function (b, a) {
        var c = this.options.marker,
          d = b && b.options,
          e = d && d.marker || {},
          f = d && d.color,
          h = b && b.color,
          g = b && b.zone && b.zone.color,
          k = this.color;
        b = v(e.lineWidth, c.lineWidth);
        d = 1;
        k = f || g || h || k;
        f = e.fillColor || c.fillColor || k;
        h = e.lineColor || c.lineColor || k;
        a = a || "normal";
        c = c.states[a] || {};
        a = e.states && e.states[a] || {};
        b = v(a.lineWidth, c.lineWidth, b + v(a.lineWidthPlus, c.lineWidthPlus, 0));
        f = a.fillColor || c.fillColor || f;
        h = a.lineColor || c.lineColor || h;
        d = v(a.opacity, c.opacity, d);
        return {
          stroke: h,
          "stroke-width": b,
          fill: f,
          opacity: d
        };
      };
      a.prototype.destroy = function (b) {
        var a = this,
          c = a.chart,
          d = /AppleWebKit\/533/.test(D.navigator.userAgent),
          e = a.data || [],
          f,
          h,
          g,
          k;
        q(a, "destroy", {
          keepEventsForUpdate: b
        });
        this.removeEvents(b);
        (a.axisTypes || []).forEach(function (b) {
          (k = a[b]) && k.series && (n(k.series, a), k.isDirty = k.forceRedraw = !0);
        });
        a.legendItem && a.chart.legend.destroyItem(a);
        for (h = e.length; h--;) (g = e[h]) && g.destroy && g.destroy();
        a.clips && a.clips.forEach(function (b) {
          return b.destroy();
        });
        l.clearTimeout(a.animationTimeout);
        Y(a, function (b, a) {
          b instanceof r && !b.survive && (f = d && "group" === a ? "hide" : "destroy", b[f]());
        });
        c.hoverSeries === a && (c.hoverSeries = void 0);
        n(c.series, a);
        c.orderSeries();
        Y(a, function (c, d) {
          b && "hcEvents" === d || delete a[d];
        });
      };
      a.prototype.applyZones = function () {
        var b = this,
          a = this.chart,
          c = a.renderer,
          d = this.zones,
          e = this.clips || [],
          f = this.graph,
          h = this.area,
          g = Math.max(a.plotWidth, a.plotHeight),
          k = this[(this.zoneAxis || "y") + "Axis"],
          n = a.inverted,
          m,
          l,
          q,
          p,
          u,
          r,
          z,
          w,
          t = !1;
        if (d.length && (f || h) && k && "undefined" !== typeof k.min) {
          var D = k.reversed;
          var E = k.horiz;
          f && !this.showLine && f.hide();
          h && h.hide();
          var A = k.getExtremes();
          d.forEach(function (d, G) {
            m = D ? E ? a.plotWidth : 0 : E ? 0 : k.toPixels(A.min) || 0;
            m = y(v(l, m), 0, g);
            l = y(Math.round(k.toPixels(v(d.value, A.max), !0) || 0), 0, g);
            t && (m = l = k.toPixels(A.max));
            p = Math.abs(m - l);
            u = Math.min(m, l);
            r = Math.max(m, l);
            k.isXAxis ? (q = {
              x: n ? r : u,
              y: 0,
              width: p,
              height: g
            }, E || (q.x = a.plotHeight - q.x)) : (q = {
              x: 0,
              y: n ? r : u,
              width: g,
              height: p
            }, E && (q.y = a.plotWidth - q.y));
            n && c.isVML && (q = k.isXAxis ? {
              x: 0,
              y: D ? u : r,
              height: q.width,
              width: a.chartWidth
            } : {
              x: q.y - a.plotLeft - a.spacingBox.x,
              y: 0,
              width: q.height,
              height: a.chartHeight
            });
            e[G] ? e[G].animate(q) : e[G] = c.clipRect(q);
            z = b["zone-area-" + G];
            w = b["zone-graph-" + G];
            f && w && w.clip(e[G]);
            h && z && z.clip(e[G]);
            t = d.value > A.max;
            b.resetZones && 0 === l && (l = void 0);
          });
          this.clips = e;
        } else b.visible && (f && f.show(), h && h.show());
      };
      a.prototype.plotGroup = function (b, a, c, d, e) {
        var h = this[b],
          g = !h;
        c = {
          visibility: c,
          zIndex: d || .1
        };
        "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (c.opacity = this.opacity);
        g && (this[b] = h = this.chart.renderer.g().add(e));
        h.addClass("highcharts-" + a + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (f(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (h.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        h.attr(c)[g ? "attr" : "animate"](this.getPlotBox(a));
        return h;
      };
      a.prototype.getPlotBox = function (b) {
        var a = this.xAxis,
          c = this.yAxis,
          d = this.chart;
        b = d.inverted && !d.polar && a && !1 !== this.invertible && "series" === b;
        d.inverted && (a = c, c = this.xAxis);
        return {
          translateX: a ? a.left : d.plotLeft,
          translateY: c ? c.top : d.plotTop,
          rotation: b ? 90 : 0,
          rotationOriginX: b ? (a.len - c.len) / 2 : 0,
          rotationOriginY: b ? (a.len + c.len) / 2 : 0,
          scaleX: b ? -1 : 1,
          scaleY: 1
        };
      };
      a.prototype.removeEvents = function (b) {
        b || U(this);
        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (b) {
          b();
        }), this.eventsToUnbind.length = 0);
      };
      a.prototype.render = function () {
        var b = this,
          a = b.chart,
          c = b.options,
          d = e(c.animation),
          f = b.visible ? "inherit" : "hidden",
          h = c.zIndex,
          g = b.hasRendered,
          k = a.seriesGroup;
        a = !b.finishedAnimating && a.renderer.isSVG ? d.duration : 0;
        q(this, "render");
        b.plotGroup("group", "series", f, h, k);
        b.markerGroup = b.plotGroup("markerGroup", "markers", f, h, k);
        !1 !== c.clip && b.setClip();
        b.animate && a && b.animate(!0);
        b.drawGraph && (b.drawGraph(), b.applyZones());
        b.visible && b.drawPoints();
        b.drawDataLabels && b.drawDataLabels();
        b.redrawPoints && b.redrawPoints();
        b.drawTracker && !1 !== b.options.enableMouseTracking && b.drawTracker();
        b.animate && a && b.animate();
        g || (a && d.defer && (a += d.defer), b.animationTimeout = ca(function () {
          b.afterAnimate();
        }, a || 0));
        b.isDirty = !1;
        b.hasRendered = !0;
        q(b, "afterRender");
      };
      a.prototype.redraw = function () {
        var b = this.isDirty || this.isDirtyData;
        this.translate();
        this.render();
        b && delete this.kdTree;
      };
      a.prototype.searchPoint = function (b, a) {
        var c = this.xAxis,
          d = this.yAxis,
          e = this.chart.inverted;
        return this.searchKDTree({
          clientX: e ? c.len - b.chartY + c.pos : b.chartX - c.pos,
          plotY: e ? d.len - b.chartX + d.pos : b.chartY - d.pos
        }, a, b);
      };
      a.prototype.buildKDTree = function (b) {
        function a(b, d, e) {
          var f = b && b.length;
          if (f) {
            var h = c.kdAxisArray[d % e];
            b.sort(function (b, a) {
              return b[h] - a[h];
            });
            f = Math.floor(f / 2);
            return {
              point: b[f],
              left: a(b.slice(0, f), d + 1, e),
              right: a(b.slice(f + 1), d + 1, e)
            };
          }
        }
        this.buildingKdTree = !0;
        var c = this,
          d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete c.kdTree;
        ca(function () {
          c.kdTree = a(c.getValidPoints(null, !c.directTouch), d, d);
          c.buildingKdTree = !1;
        }, c.options.kdNow || b && "touchstart" === b.type ? 0 : 1);
      };
      a.prototype.searchKDTree = function (b, a, c) {
        function d(b, a, c, n) {
          var m = a.point,
            l = e.kdAxisArray[c % n],
            q = m,
            p = f(b[h]) && f(m[h]) ? Math.pow(b[h] - m[h], 2) : null;
          var u = f(b[g]) && f(m[g]) ? Math.pow(b[g] - m[g], 2) : null;
          u = (p || 0) + (u || 0);
          m.dist = f(u) ? Math.sqrt(u) : Number.MAX_VALUE;
          m.distX = f(p) ? Math.sqrt(p) : Number.MAX_VALUE;
          l = b[l] - m[l];
          u = 0 > l ? "left" : "right";
          p = 0 > l ? "right" : "left";
          a[u] && (u = d(b, a[u], c + 1, n), q = u[k] < q[k] ? u : m);
          a[p] && Math.sqrt(l * l) < q[k] && (b = d(b, a[p], c + 1, n), q = b[k] < q[k] ? b : q);
          return q;
        }
        var e = this,
          h = this.kdAxisArray[0],
          g = this.kdAxisArray[1],
          k = a ? "distX" : "dist";
        a = -1 < e.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(c);
        if (this.kdTree) return d(b, this.kdTree, a, a);
      };
      a.prototype.pointPlacementToXValue = function () {
        var b = this.options,
          a = b.pointRange,
          c = this.xAxis;
        b = b.pointPlacement;
        "between" === b && (b = c.reversed ? -.5 : .5);
        return O(b) ? b * (a || c.pointRange) : 0;
      };
      a.prototype.isPointInside = function (b) {
        var a = this.chart,
          c = this.xAxis,
          d = this.yAxis;
        return "undefined" !== typeof b.plotY && "undefined" !== typeof b.plotX && 0 <= b.plotY && b.plotY <= (d ? d.len : a.plotHeight) && 0 <= b.plotX && b.plotX <= (c ? c.len : a.plotWidth);
      };
      a.prototype.drawTracker = function () {
        var b = this,
          a = b.options,
          c = a.trackByArea,
          d = [].concat(c ? b.areaPath : b.graphPath),
          e = b.chart,
          f = e.pointer,
          h = e.renderer,
          g = e.options.tooltip.snap,
          n = b.tracker,
          m = function (a) {
            if (e.hoverSeries !== b) b.onMouseOver();
          },
          l = "rgba(192,192,192," + (p ? .0001 : .002) + ")";
        n ? n.attr({
          d: d
        }) : b.graph && (b.tracker = h.path(d).attr({
          visibility: b.visible ? "inherit" : "hidden",
          zIndex: 2
        }).addClass(c ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b.group), e.styledMode || b.tracker.attr({
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          stroke: l,
          fill: c ? l : "none",
          "stroke-width": b.graph.strokeWidth() + (c ? 0 : 2 * g)
        }), [b.tracker, b.markerGroup, b.dataLabelsGroup].forEach(function (b) {
          if (b && (b.addClass("highcharts-tracker").on("mouseover", m).on("mouseout", function (b) {
            f.onTrackerMouseOut(b);
          }), a.cursor && !e.styledMode && b.css({
            cursor: a.cursor
          }), k)) b.on("touchstart", m);
        }));
        q(this, "afterDrawTracker");
      };
      a.prototype.addPoint = function (b, a, c, d, e) {
        var f = this.options,
          h = this.data,
          g = this.chart,
          k = this.xAxis;
        k = k && k.hasNames && k.names;
        var n = f.data,
          m = this.xData,
          l;
        a = v(a, !0);
        var p = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(p, [b]);
        var u = p.x;
        var r = m.length;
        if (this.requireSorting && u < m[r - 1]) for (l = !0; r && m[r - 1] > u;) r--;
        this.updateParallelArrays(p, "splice", r, 0, 0);
        this.updateParallelArrays(p, r);
        k && p.name && (k[u] = p.name);
        n.splice(r, 0, b);
        if (l || this.processedData) this.data.splice(r, 0, null), this.processData();
        "point" === f.legendType && this.generatePoints();
        c && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(p, "shift"), n.shift()));
        !1 !== e && q(this, "addPoint", {
          point: p
        });
        this.isDirtyData = this.isDirty = !0;
        a && g.redraw(d);
      };
      a.prototype.removePoint = function (b, a, c) {
        var e = this,
          f = e.data,
          h = f[b],
          g = e.points,
          k = e.chart,
          n = function () {
            g && g.length === f.length && g.splice(b, 1);
            f.splice(b, 1);
            e.options.data.splice(b, 1);
            e.updateParallelArrays(h || {
              series: e
            }, "splice", b, 1);
            h && h.destroy();
            e.isDirty = !0;
            e.isDirtyData = !0;
            a && k.redraw();
          };
        d(c, k);
        a = v(a, !0);
        h ? h.firePointEvent("remove", null, n) : n();
      };
      a.prototype.remove = function (b, a, c, d) {
        function e() {
          f.destroy(d);
          h.isDirtyLegend = h.isDirtyBox = !0;
          h.linkSeries();
          v(b, !0) && h.redraw(a);
        }
        var f = this,
          h = f.chart;
        !1 !== c ? q(f, "remove", null, e) : e();
      };
      a.prototype.update = function (a, d) {
        a = c(a, this.userOptions);
        q(this, "update", {
          options: a
        });
        var e = this,
          f = e.chart,
          h = e.userOptions,
          g = e.initialType || e.type,
          k = f.options.plotOptions,
          n = A[g].prototype,
          m = e.finishedAnimating && {
            animation: !1
          },
          l = {},
          p = ["eventOptions", "navigatorSeries", "baseSeries"],
          r = a.type || h.type || f.options.chart.type,
          z = !(this.hasDerivedData || r && r !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || "undefined" !== typeof a.relativeXValue || a.joinBy || a.mapData || e.hasOptionChanged("dataGrouping") || e.hasOptionChanged("pointStart") || e.hasOptionChanged("pointInterval") || e.hasOptionChanged("pointIntervalUnit") || e.hasOptionChanged("keys"));
        r = r || g;
        z && (p.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && p.push("area", "graph"), e.parallelArrays.forEach(function (b) {
          p.push(b + "Data");
        }), a.data && (a.dataSorting && u(e.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
        a = T(h, m, {
          index: "undefined" === typeof h.index ? e.index : h.index,
          pointStart: v(k && k.series && k.series.pointStart, h.pointStart, e.xData[0])
        }, !z && {
          data: e.options.data
        }, a);
        z && a.data && (a.data = e.options.data);
        p = ["group", "markerGroup", "dataLabelsGroup", "transformGroup", "shadowGroup"].concat(p);
        p.forEach(function (b) {
          p[b] = e[b];
          delete e[b];
        });
        k = !1;
        if (A[r]) {
          if (k = r !== e.type, e.remove(!1, !1, !1, !0), k) if (Object.setPrototypeOf) Object.setPrototypeOf(e, A[r].prototype);else {
            m = Object.hasOwnProperty.call(e, "hcEvents") && e.hcEvents;
            for (w in n) e[w] = void 0;
            u(e, A[r].prototype);
            m ? e.hcEvents = m : delete e.hcEvents;
          }
        } else b(17, !0, f, {
          missingModuleFor: r
        });
        p.forEach(function (b) {
          e[b] = p[b];
        });
        e.init(f, a);
        if (z && this.points) {
          a = e.options;
          if (!1 === a.visible) l.graphic = 1, l.dataLabel = 1;else if (!e._hasPointLabels) {
            n = a.marker;
            var w = a.dataLabels;
            h = h.marker || {};
            !n || !1 !== n.enabled && h.symbol === n.symbol && h.height === n.height && h.width === n.width || (l.graphic = 1);
            w && !1 === w.enabled && (l.dataLabel = 1);
          }
          h = 0;
          for (n = this.points; h < n.length; h++) (w = n[h]) && w.series && (w.resolveColor(), Object.keys(l).length && w.destroyElements(l), !1 === a.showInLegend && w.legendItem && f.legend.destroyItem(w));
        }
        e.initialType = g;
        f.linkSeries();
        k && e.linkedSeries.length && (e.isDirtyData = !0);
        q(this, "afterUpdate");
        v(d, !0) && f.redraw(z ? void 0 : !1);
      };
      a.prototype.setName = function (b) {
        this.name = this.options.name = this.userOptions.name = b;
        this.chart.isDirtyLegend = !0;
      };
      a.prototype.hasOptionChanged = function (b) {
        var a = this.options[b],
          c = this.chart.options.plotOptions,
          d = this.userOptions[b];
        return d ? a !== d : a !== v(c && c[this.type] && c[this.type][b], c && c.series && c.series[b], a);
      };
      a.prototype.onMouseOver = function () {
        var b = this.chart,
          a = b.hoverSeries;
        b.pointer.setHoverChartIndex();
        if (a && a !== this) a.onMouseOut();
        this.options.events.mouseOver && q(this, "mouseOver");
        this.setState("hover");
        b.hoverSeries = this;
      };
      a.prototype.onMouseOut = function () {
        var b = this.options,
          a = this.chart,
          c = a.tooltip,
          d = a.hoverPoint;
        a.hoverSeries = null;
        if (d) d.onMouseOut();
        this && b.events.mouseOut && q(this, "mouseOut");
        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
        a.series.forEach(function (b) {
          b.setState("", !0);
        });
      };
      a.prototype.setState = function (b, a) {
        var c = this,
          d = c.options,
          e = c.graph,
          f = d.inactiveOtherPoints,
          h = d.states,
          g = v(h[b || "normal"] && h[b || "normal"].animation, c.chart.options.chart.animation),
          k = d.lineWidth,
          n = 0,
          m = d.opacity;
        b = b || "";
        if (c.state !== b && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (a) {
          a && (c.state && a.removeClass("highcharts-series-" + c.state), b && a.addClass("highcharts-series-" + b));
        }), c.state = b, !c.chart.styledMode)) {
          if (h[b] && !1 === h[b].enabled) return;
          b && (k = h[b].lineWidth || k + (h[b].lineWidthPlus || 0), m = v(h[b].opacity, m));
          if (e && !e.dashstyle && O(k)) for (d = {
            "stroke-width": k
          }, e.animate(d, g); c["zone-graph-" + n];) c["zone-graph-" + n].animate(d, g), n += 1;
          f || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (b) {
            b && b.animate({
              opacity: m
            }, g);
          });
        }
        a && f && c.points && c.setAllPointsToState(b || void 0);
      };
      a.prototype.setAllPointsToState = function (b) {
        this.points.forEach(function (a) {
          a.setState && a.setState(b);
        });
      };
      a.prototype.setVisible = function (b, a) {
        var c = this,
          d = c.chart,
          e = d.options.chart.ignoreHiddenSeries,
          f = c.visible,
          h = (c.visible = b = c.options.visible = c.userOptions.visible = "undefined" === typeof b ? !f : b) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (b) {
          if (c[b]) c[b][h]();
        });
        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
        c.legendItem && d.legend.colorizeItem(c, b);
        c.isDirty = !0;
        c.options.stacking && d.series.forEach(function (b) {
          b.options.stacking && b.visible && (b.isDirty = !0);
        });
        c.linkedSeries.forEach(function (a) {
          a.setVisible(b, !1);
        });
        e && (d.isDirtyBox = !0);
        q(c, h);
        !1 !== a && d.redraw();
      };
      a.prototype.show = function () {
        this.setVisible(!0);
      };
      a.prototype.hide = function () {
        this.setVisible(!1);
      };
      a.prototype.select = function (b) {
        this.selected = b = this.options.selected = "undefined" === typeof b ? !this.selected : b;
        this.checkbox && (this.checkbox.checked = b);
        q(this, b ? "select" : "unselect");
      };
      a.prototype.shouldShowTooltip = function (b, a, c) {
        void 0 === c && (c = {});
        c.series = this;
        c.visiblePlotOnly = !0;
        return this.chart.isInsidePlot(b, a, c);
      };
      a.defaultOptions = H;
      a.types = t.seriesTypes;
      a.registerType = t.registerSeriesType;
      return a;
    }();
    u(a.prototype, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      drawLegendSymbol: C.drawLineMarker,
      isCartesian: !0,
      kdAxisArray: ["clientX", "plotY"],
      parallelArrays: ["x", "y"],
      pointClass: B,
      requireSorting: !0,
      sorted: !0
    });
    t.series = a;
    "";
    "";
    return a;
  });
  K(g, "Extensions/ScrollablePlotArea.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Chart/Chart.js"], g["Core/Series/Series.js"], g["Core/Renderer/RendererRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B) {
    var A = a.stop,
      t = B.addEvent,
      r = B.createElement,
      l = B.defined,
      e = B.merge,
      d = B.pick;
    t(x, "afterSetChartSize", function (a) {
      var d = this.options.chart.scrollablePlotArea,
        h = d && d.minWidth;
      d = d && d.minHeight;
      if (!this.renderer.forExport) {
        if (h) {
          if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) {
            this.scrollablePlotBox = this.renderer.scrollablePlotBox = e(this.plotBox);
            this.plotBox.width = this.plotWidth += h;
            this.inverted ? this.clipBox.height += h : this.clipBox.width += h;
            var p = {
              1: {
                name: "right",
                value: h
              }
            };
          }
        } else d && (this.scrollablePixelsY = h = Math.max(0, d - this.chartHeight), l(h) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = e(this.plotBox), this.plotBox.height = this.plotHeight += h, this.inverted ? this.clipBox.width += h : this.clipBox.height += h, p = {
          2: {
            name: "bottom",
            value: h
          }
        }));
        p && !a.skipAxes && this.axes.forEach(function (a) {
          p[a.side] ? a.getPlotLinePath = function () {
            var d = p[a.side].name,
              e = this[d];
            this[d] = e - p[a.side].value;
            var h = g.prototype.getPlotLinePath.apply(this, arguments);
            this[d] = e;
            return h;
          } : (a.setAxisSize(), a.setAxisTranslation());
        });
      }
    });
    t(x, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });
    x.prototype.setUpScrolling = function () {
      var a = this,
        d = {
          WebkitOverflowScrolling: "touch",
          overflowX: "hidden",
          overflowY: "hidden"
        };
      this.scrollablePixelsX && (d.overflowX = "auto");
      this.scrollablePixelsY && (d.overflowY = "auto");
      this.scrollingParent = r("div", {
        className: "highcharts-scrolling-parent"
      }, {
        position: "relative"
      }, this.renderTo);
      this.scrollingContainer = r("div", {
        className: "highcharts-scrolling"
      }, d, this.scrollingParent);
      var e;
      t(this.scrollingContainer, "scroll", function () {
        a.pointer && (delete a.pointer.chartPosition, a.hoverPoint && (e = a.hoverPoint), a.pointer.runPointActions(void 0, e, !0));
      });
      this.innerContainer = r("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };
    x.prototype.moveFixedElements = function () {
      var a = this.container,
        d = this.fixedRenderer,
        e = ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
        g;
      this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
      g && e.push("" + g + ":not(.highcharts-radial-axis)", "" + g + "-labels:not(.highcharts-radial-axis-labels)");
      e.forEach(function (e) {
        [].forEach.call(a.querySelectorAll(e), function (a) {
          (a.namespaceURI === d.SVG_NS ? d.box : d.box.parentNode).appendChild(a);
          a.style.pointerEvents = "auto";
        });
      });
    };
    x.prototype.applyFixed = function () {
      var a = !this.fixedDiv,
        e = this.options.chart,
        g = e.scrollablePlotArea,
        l = C.getRendererType();
      a ? (this.fixedDiv = r("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: (e.style && e.style.zIndex || 0) + 2,
        top: 0
      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = e = new l(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = e.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": d(g.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), t(this, "afterShowResetZoom", this.moveFixedElements), t(this, "afterApplyDrilldown", this.moveFixedElements), t(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      if (this.scrollableDirty || a) this.scrollableDirty = !1, this.moveFixedElements();
      e = this.chartWidth + (this.scrollablePixelsX || 0);
      l = this.chartHeight + (this.scrollablePixelsY || 0);
      A(this.container);
      this.container.style.width = e + "px";
      this.container.style.height = l + "px";
      this.renderer.boxWrapper.attr({
        width: e,
        height: l,
        viewBox: [0, 0, e, l].join(" ")
      });
      this.chartBackground.attr({
        width: e,
        height: l
      });
      this.scrollingContainer.style.height = this.chartHeight + "px";
      a && (g.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * g.scrollPositionX), g.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * g.scrollPositionY));
      l = this.axisOffset;
      a = this.plotTop - l[0] - 1;
      g = this.plotLeft - l[3] - 1;
      e = this.plotTop + this.plotHeight + l[2] + 1;
      l = this.plotLeft + this.plotWidth + l[1] + 1;
      var D = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
        x = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      a = this.scrollablePixelsX ? [["M", 0, a], ["L", this.plotLeft - 1, a], ["L", this.plotLeft - 1, e], ["L", 0, e], ["Z"], ["M", D, a], ["L", this.chartWidth, a], ["L", this.chartWidth, e], ["L", D, e], ["Z"]] : this.scrollablePixelsY ? [["M", g, 0], ["L", g, this.plotTop - 1], ["L", l, this.plotTop - 1], ["L", l, 0], ["Z"], ["M", g, x], ["L", g, this.chartHeight], ["L", l, this.chartHeight], ["L", l, x], ["Z"]] : [["M", 0, 0]];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: a
      });
    };
    t(g, "afterInit", function () {
      this.chart.scrollableDirty = !0;
    });
    t(F, "show", function () {
      this.chart.scrollableDirty = !0;
    });
    "";
  });
  K(g, "Core/Axis/Stacking/StackItem.js", [g["Core/FormatUtilities.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = a.format,
      C = g.series,
      B = x.destroyObjectProperties,
      H = x.pick,
      t = x.isNumber;
    a = function () {
      function a(a, e, d, h, g) {
        var k = a.chart.inverted,
          m = a.reversed;
        this.axis = a;
        a = this.isNegative = !!d !== !!m;
        this.options = e = e || {};
        this.x = h;
        this.cumulative = this.total = null;
        this.points = {};
        this.hasValidPoints = !1;
        this.stack = g;
        this.rightCliff = this.leftCliff = 0;
        this.alignOptions = {
          align: e.align || (k ? a ? "left" : "right" : "center"),
          verticalAlign: e.verticalAlign || (k ? "middle" : a ? "bottom" : "top"),
          y: e.y,
          x: e.x
        };
        this.textAlign = e.textAlign || (k ? a ? "right" : "left" : "center");
      }
      a.prototype.destroy = function () {
        B(this, this.axis);
      };
      a.prototype.render = function (a) {
        var e = this.axis.chart,
          d = this.options,
          h = d.format;
        h = h ? A(h, this, e) : d.formatter.call(this);
        this.label ? this.label.attr({
          text: h,
          visibility: "hidden"
        }) : (this.label = e.renderer.label(h, null, void 0, d.shape, void 0, void 0, d.useHTML, !1, "stack-labels"), h = {
          r: d.borderRadius || 0,
          text: h,
          padding: H(d.padding, 5),
          visibility: "hidden"
        }, e.styledMode || (h.fill = d.backgroundColor, h.stroke = d.borderColor, h["stroke-width"] = d.borderWidth, this.label.css(d.style || {})), this.label.attr(h), this.label.added || this.label.add(a));
        this.label.labelrank = e.plotSizeY;
      };
      a.prototype.setOffset = function (a, e, d, h, g, k) {
        var m = this.alignOptions,
          l = this.axis,
          r = this.label,
          E = this.options,
          A = this.textAlign,
          y = l.chart;
        a = this.getStackBox({
          xOffset: a,
          width: e,
          boxBottom: d,
          boxTop: h,
          defaultX: g,
          xAxis: k
        });
        g = m.verticalAlign;
        r && a && (e = r.getBBox(), d = r.padding, h = "justify" === H(E.overflow, "justify"), m.x = E.x || 0, m.y = E.y || 0, g = this.adjustStackPosition({
          labelBox: e,
          verticalAlign: g,
          textAlign: A
        }), A = g.x, g = g.y, a.x -= A, a.y -= g, r.align(m, !1, a), (A = y.isInsidePlot(r.alignAttr.x + m.x + A, r.alignAttr.y + m.y + g)) || (h = !1), h && C.prototype.justifyDataLabel.call(l, r, m, r.alignAttr, e, a), r.attr({
          x: r.alignAttr.x,
          y: r.alignAttr.y,
          rotation: E.rotation,
          rotationOriginX: e.width / 2,
          rotationOriginY: e.height / 2
        }), H(!h && E.crop, !0) && (A = t(r.x) && t(r.y) && y.isInsidePlot(r.x - d + r.width, r.y) && y.isInsidePlot(r.x + d, r.y)), r[A ? "show" : "hide"]());
      };
      a.prototype.adjustStackPosition = function (a) {
        var e = a.labelBox,
          d = {
            bottom: 0,
            middle: 1,
            top: 2,
            right: 1,
            center: 0,
            left: -1
          };
        return {
          x: e.width / 2 + e.width / 2 * d[a.textAlign],
          y: e.height / 2 * d[a.verticalAlign]
        };
      };
      a.prototype.getStackBox = function (a) {
        var e = this.axis,
          d = e.chart,
          h = a.boxTop,
          g = a.defaultX,
          k = a.xOffset,
          l = a.width,
          r = a.boxBottom;
        h = e.stacking.usePercentage ? 100 : H(h, this.total, 0);
        h = e.toPixels(h);
        a = H(g, (a.xAxis || d.xAxis[0]).toPixels(this.x)) + k;
        e = e.toPixels(r ? r : 0);
        e = Math.abs(h - e);
        r = this.isNegative;
        return d.inverted ? {
          x: (r ? h : h - e) - d.plotLeft,
          y: a - d.plotTop,
          width: e,
          height: l
        } : {
          x: a - d.plotLeft,
          y: (r ? h - e : h) - d.plotTop,
          width: l,
          height: e
        };
      };
      return a;
    }();
    "";
    return a;
  });
  K(g, "Core/Axis/Stacking/StackingAxis.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Axis/Axis.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Axis/Stacking/StackItem.js"], g["Core/Utilities.js"]], function (a, g, x, F, C) {
    function A() {
      var b = this,
        a = b.inverted;
      b.yAxis.forEach(function (b) {
        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);
      });
      b.series.forEach(function (c) {
        var d = c.xAxis && c.xAxis.options || {};
        !c.options.stacking || !0 !== c.visible && !1 !== b.options.chart.ignoreHiddenSeries || (c.stackKey = [c.type, f(c.options.stack, ""), a ? d.top : d.left, a ? d.height : d.width].join());
      });
    }
    function H() {
      var b = this.stacking;
      if (b) {
        var a = b.stacks;
        w(a, function (b, c) {
          E(b);
          a[c] = null;
        });
        b && b.stackTotalGroup && b.stackTotalGroup.destroy();
      }
    }
    function t() {
      "yAxis" !== this.coll || this.stacking || (this.stacking = new n(this));
    }
    function r(b, a, c, d) {
      !I(b) || b.x !== a || d && b.stackKey !== d ? b = {
        x: a,
        index: 0,
        key: d,
        stackKey: d
      } : b.index++;
      b.key = [c, a, b.index].join();
      return b;
    }
    function l() {
      var b = this,
        a = b.stackKey,
        c = b.yAxis.stacking.stacks,
        d = b.processedXData,
        e = b[b.options.stacking + "Stacker"],
        f;
      e && [a, "-" + a].forEach(function (a) {
        for (var h = d.length, g, k; h--;) g = d[h], f = b.getStackIndicator(f, g, b.index, a), (k = (g = c[a] && c[a][g]) && g.points[f.key]) && e.call(b, k, g, h);
      });
    }
    function e(b, a, c) {
      a = a.total ? 100 / a.total : 0;
      b[0] = D(b[0] * a);
      b[1] = D(b[1] * a);
      this.stackedYData[c] = b[1];
    }
    function d() {
      var b = this.yAxis.stacking;
      this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? k.setStackedPoints.call(this, "group") : b && w(b.stacks, function (a, c) {
        "group" === c.slice(-5) && (w(a, function (b) {
          return b.destroy();
        }), delete b.stacks[c]);
      });
    }
    function h(b) {
      var a = this.chart,
        c = b || this.options.stacking;
      if (c && (!0 === this.visible || !1 === a.options.chart.ignoreHiddenSeries)) {
        var d = this.processedXData,
          e = this.processedYData,
          h = [],
          g = e.length,
          k = this.options,
          n = k.threshold,
          m = f(k.startFromThreshold && n, 0);
        k = k.stack;
        b = b ? "" + this.type + ",".concat(c) : this.stackKey;
        var l = "-" + b,
          p = this.negStacks;
        a = "group" === c ? a.yAxis[0] : this.yAxis;
        var u = a.stacking.stacks,
          r = a.stacking.oldStacks,
          w,
          t;
        a.stacking.stacksTouched += 1;
        for (t = 0; t < g; t++) {
          var E = d[t];
          var A = e[t];
          var x = this.getStackIndicator(x, E, this.index);
          var C = x.key;
          var B = (w = p && A < (m ? 0 : n)) ? l : b;
          u[B] || (u[B] = {});
          u[B][E] || (r[B] && r[B][E] ? (u[B][E] = r[B][E], u[B][E].total = null) : u[B][E] = new F(a, a.options.stackLabels, !!w, E, k));
          B = u[B][E];
          null !== A ? (B.points[C] = B.points[this.index] = [f(B.cumulative, m)], I(B.cumulative) || (B.base = C), B.touched = a.stacking.stacksTouched, 0 < x.index && !1 === this.singleStacks && (B.points[C][0] = B.points[this.index + "," + E + ",0"][0])) : B.points[C] = B.points[this.index] = null;
          "percent" === c ? (w = w ? b : l, p && u[w] && u[w][E] ? (w = u[w][E], B.total = w.total = Math.max(w.total, B.total) + Math.abs(A) || 0) : B.total = D(B.total + (Math.abs(A) || 0))) : "group" === c ? (y(A) && (A = A[0]), null !== A && (B.total = (B.total || 0) + 1)) : B.total = D(B.total + (A || 0));
          B.cumulative = "group" === c ? (B.total || 1) - 1 : f(B.cumulative, m) + (A || 0);
          null !== A && (B.points[C].push(B.cumulative), h[t] = B.cumulative, B.hasValidPoints = !0);
        }
        "percent" === c && (a.stacking.usePercentage = !0);
        "group" !== c && (this.stackedYData = h);
        a.stacking.oldStacks = {};
      }
    }
    var m = a.getDeferredAnimation,
      k = x.series.prototype,
      p = C.addEvent,
      D = C.correctFloat,
      I = C.defined,
      E = C.destroyObjectProperties,
      L = C.fireEvent,
      y = C.isArray,
      c = C.isNumber,
      w = C.objectEach,
      f = C.pick,
      n = function () {
        function b(b) {
          this.oldStacks = {};
          this.stacks = {};
          this.stacksTouched = 0;
          this.axis = b;
        }
        b.prototype.buildStacks = function () {
          var b = this.axis,
            a = b.series,
            c = b.options.reversedStacks,
            d = a.length,
            e;
          this.usePercentage = !1;
          for (e = d; e--;) {
            var f = a[c ? e : d - e - 1];
            f.setStackedPoints();
            f.setGroupedPoints();
          }
          for (e = 0; e < d; e++) a[e].modifyStacks();
          L(b, "afterBuildStacks");
        };
        b.prototype.cleanStacks = function () {
          if (this.oldStacks) var b = this.stacks = this.oldStacks;
          w(b, function (b) {
            w(b, function (b) {
              b.cumulative = b.total;
            });
          });
        };
        b.prototype.resetStacks = function () {
          var b = this;
          w(this.stacks, function (a) {
            w(a, function (d, e) {
              c(d.touched) && d.touched < b.stacksTouched ? (d.destroy(), delete a[e]) : (d.total = null, d.cumulative = null);
            });
          });
        };
        b.prototype.renderStackTotals = function () {
          var b = this.axis,
            a = b.chart,
            c = a.renderer,
            d = this.stacks;
          b = m(a, b.options.stackLabels && b.options.stackLabels.animation || !1);
          var e = this.stackTotalGroup = this.stackTotalGroup || c.g("stack-labels").attr({
            zIndex: 6,
            opacity: 0
          }).add();
          e.translate(a.plotLeft, a.plotTop);
          w(d, function (b) {
            w(b, function (b) {
              b.render(e);
            });
          });
          e.animate({
            opacity: 1
          }, b);
        };
        return b;
      }(),
      b;
    (function (b) {
      var a = [];
      b.compose = function (b, c, f) {
        -1 === a.indexOf(b) && (a.push(b), p(b, "init", t), p(b, "destroy", H));
        -1 === a.indexOf(c) && (a.push(c), c.prototype.getStacks = A);
        -1 === a.indexOf(f) && (a.push(f), b = f.prototype, b.getStackIndicator = r, b.modifyStacks = l, b.percentStacker = e, b.setGroupedPoints = d, b.setStackedPoints = h);
      };
    })(b || (b = {}));
    return b;
  });
  K(g, "Series/Line/LineSeries.js", [g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = this && this.__extends || function () {
        var a = function (g, r) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, e) {
            a.__proto__ = e;
          } || function (a, e) {
            for (var d in e) e.hasOwnProperty(d) && (a[d] = e[d]);
          };
          return a(g, r);
        };
        return function (g, r) {
          function l() {
            this.constructor = g;
          }
          a(g, r);
          g.prototype = null === r ? Object.create(r) : (l.prototype = r.prototype, new l());
        };
      }(),
      C = x.defined,
      B = x.merge;
    x = function (g) {
      function t() {
        var a = null !== g && g.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      A(t, g);
      t.prototype.drawGraph = function () {
        var a = this,
          g = this.options,
          e = (this.gappedPath || this.getGraphPath).call(this),
          d = this.chart.styledMode,
          h = [["graph", "highcharts-graph"]];
        d || h[0].push(g.lineColor || this.color || "#cccccc", g.dashStyle);
        h = a.getZonesGraphs(h);
        h.forEach(function (h, k) {
          var m = h[0],
            l = a[m],
            r = l ? "animate" : "attr";
          l ? (l.endX = a.preventGraphAnimation ? null : e.xMap, l.animate({
            d: e
          })) : e.length && (a[m] = l = a.chart.renderer.path(e).addClass(h[1]).attr({
            zIndex: 1
          }).add(a.group));
          l && !d && (m = {
            stroke: h[2],
            "stroke-width": g.lineWidth || 0,
            fill: a.fillGraph && a.color || "none"
          }, h[3] ? m.dashstyle = h[3] : "square" !== g.linecap && (m["stroke-linecap"] = m["stroke-linejoin"] = "round"), l[r](m).shadow(2 > k && g.shadow));
          l && (l.startX = e.xMap, l.isArea = e.isArea);
        });
      };
      t.prototype.getGraphPath = function (a, g, e) {
        var d = this,
          h = d.options,
          m = [],
          k = [],
          l,
          r = h.step;
        a = a || d.points;
        var t = a.reversed;
        t && a.reverse();
        (r = {
          right: 1,
          center: 2
        }[r] || r && 3) && t && (r = 4 - r);
        a = this.getValidPoints(a, !1, !(h.connectNulls && !g && !e));
        a.forEach(function (p, t) {
          var y = p.plotX,
            c = p.plotY,
            w = a[t - 1];
          (p.leftCliff || w && w.rightCliff) && !e && (l = !0);
          p.isNull && !C(g) && 0 < t ? l = !h.connectNulls : p.isNull && !g ? l = !0 : (0 === t || l ? t = [["M", p.plotX, p.plotY]] : d.getPointSpline ? t = [d.getPointSpline(a, p, t)] : r ? (t = 1 === r ? [["L", w.plotX, c]] : 2 === r ? [["L", (w.plotX + y) / 2, w.plotY], ["L", (w.plotX + y) / 2, c]] : [["L", y, w.plotY]], t.push(["L", y, c])) : t = [["L", y, c]], k.push(p.x), r && (k.push(p.x), 2 === r && k.push(p.x)), m.push.apply(m, t), l = !1);
        });
        m.xMap = k;
        return d.graphPath = m;
      };
      t.prototype.getZonesGraphs = function (a) {
        this.zones.forEach(function (g, e) {
          e = ["zone-graph-" + e, "highcharts-graph highcharts-zone-graph-" + e + " " + (g.className || "")];
          this.chart.styledMode || e.push(g.color || this.color, g.dashStyle || this.options.dashStyle);
          a.push(e);
        }, this);
        return a;
      };
      t.defaultOptions = B(a.defaultOptions, {});
      return t;
    }(a);
    g.registerSeriesType("line", x);
    "";
    return x;
  });
  K(g, "Series/Area/AreaSeries.js", [g["Core/Color/Color.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = this && this.__extends || function () {
        var a = function (d, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return a(d, e);
        };
        return function (d, e) {
          function h() {
            this.constructor = d;
          }
          a(d, e);
          d.prototype = null === e ? Object.create(e) : (h.prototype = e.prototype, new h());
        };
      }(),
      B = a.parse,
      H = x.seriesTypes.line;
    a = F.extend;
    var t = F.merge,
      r = F.objectEach,
      l = F.pick;
    F = function (a) {
      function d() {
        var d = null !== a && a.apply(this, arguments) || this;
        d.data = void 0;
        d.options = void 0;
        d.points = void 0;
        return d;
      }
      A(d, a);
      d.prototype.drawGraph = function () {
        this.areaPath = [];
        a.prototype.drawGraph.apply(this);
        var d = this,
          e = this.areaPath,
          g = this.options,
          p = [["area", "highcharts-area", this.color, g.fillColor]];
        this.zones.forEach(function (a, e) {
          p.push(["zone-area-" + e, "highcharts-area highcharts-zone-area-" + e + " " + a.className, a.color || d.color, a.fillColor || g.fillColor]);
        });
        p.forEach(function (a) {
          var h = a[0],
            k = {},
            m = d[h],
            p = m ? "animate" : "attr";
          m ? (m.endX = d.preventGraphAnimation ? null : e.xMap, m.animate({
            d: e
          })) : (k.zIndex = 0, m = d[h] = d.chart.renderer.path(e).addClass(a[1]).add(d.group), m.isArea = !0);
          d.chart.styledMode || (k.fill = l(a[3], B(a[2]).setOpacity(l(g.fillOpacity, .75)).get()));
          m[p](k);
          m.startX = e.xMap;
          m.shiftUnit = g.step ? 2 : 1;
        });
      };
      d.prototype.getGraphPath = function (a) {
        var d = H.prototype.getGraphPath,
          e = this.options,
          h = e.stacking,
          g = this.yAxis,
          r = [],
          t = [],
          A = this.index,
          y = g.stacking.stacks[this.stackKey],
          c = e.threshold,
          w = Math.round(g.getThreshold(e.threshold));
        e = l(e.connectNulls, "percent" === h);
        var f = function (b, d, e) {
          var f = a[b];
          b = h && y[f.x].points[A];
          var n = f[e + "Null"] || 0;
          e = f[e + "Cliff"] || 0;
          f = !0;
          if (e || n) {
            var k = (n ? b[0] : b[1]) + e;
            var m = b[0] + e;
            f = !!n;
          } else !h && a[d] && a[d].isNull && (k = m = c);
          "undefined" !== typeof k && (t.push({
            plotX: z,
            plotY: null === k ? w : g.getThreshold(k),
            isNull: f,
            isCliff: !0
          }), r.push({
            plotX: z,
            plotY: null === m ? w : g.getThreshold(m),
            doCurve: !1
          }));
        };
        a = a || this.points;
        h && (a = this.getStackPoints(a));
        for (var n = 0, b = a.length; n < b; ++n) {
          h || (a[n].leftCliff = a[n].rightCliff = a[n].leftNull = a[n].rightNull = void 0);
          var u = a[n].isNull;
          var z = l(a[n].rectPlotX, a[n].plotX);
          var q = h ? l(a[n].yBottom, w) : w;
          if (!u || e) e || f(n, n - 1, "left"), u && !h && e || (t.push(a[n]), r.push({
            x: n,
            plotX: z,
            plotY: q
          })), e || f(n, n + 1, "right");
        }
        f = d.call(this, t, !0, !0);
        r.reversed = !0;
        u = d.call(this, r, !0, !0);
        (q = u[0]) && "M" === q[0] && (u[0] = ["L", q[1], q[2]]);
        u = f.concat(u);
        u.length && u.push(["Z"]);
        d = d.call(this, t, !1, e);
        u.xMap = f.xMap;
        this.areaPath = u;
        return d;
      };
      d.prototype.getStackPoints = function (a) {
        var d = this,
          e = [],
          h = [],
          g = this.xAxis,
          t = this.yAxis,
          A = t.stacking.stacks[this.stackKey],
          x = {},
          y = t.series,
          c = y.length,
          w = t.options.reversedStacks ? 1 : -1,
          f = y.indexOf(d);
        a = a || this.points;
        if (this.options.stacking) {
          for (var n = 0; n < a.length; n++) a[n].leftNull = a[n].rightNull = void 0, x[a[n].x] = a[n];
          r(A, function (b, a) {
            null !== b.total && h.push(a);
          });
          h.sort(function (b, a) {
            return b - a;
          });
          var b = y.map(function (b) {
            return b.visible;
          });
          h.forEach(function (a, n) {
            var k = 0,
              m,
              p;
            if (x[a] && !x[a].isNull) e.push(x[a]), [-1, 1].forEach(function (e) {
              var g = 1 === e ? "rightNull" : "leftNull",
                k = A[h[n + e]],
                l = 0;
              if (k) for (var q = f; 0 <= q && q < c;) {
                var u = y[q].index;
                m = k.points[u];
                m || (u === d.index ? x[a][g] = !0 : b[q] && (p = A[a].points[u]) && (l -= p[1] - p[0]));
                q += w;
              }
              x[a][1 === e ? "rightCliff" : "leftCliff"] = l;
            });else {
              for (var u = f; 0 <= u && u < c;) {
                if (m = A[a].points[y[u].index]) {
                  k = m[1];
                  break;
                }
                u += w;
              }
              k = l(k, 0);
              k = t.translate(k, 0, 1, 0, 1);
              e.push({
                isNull: !0,
                plotX: g.translate(a, 0, 0, 0, 1),
                x: a,
                plotY: k,
                yBottom: k
              });
            }
          });
        }
        return e;
      };
      d.defaultOptions = t(H.defaultOptions, {
        threshold: 0
      });
      return d;
    }(H);
    a(F.prototype, {
      singleStacks: !1,
      drawLegendSymbol: g.drawRectangle
    });
    x.registerSeriesType("area", F);
    "";
    return F;
  });
  K(g, "Series/Spline/SplineSeries.js", [g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g) {
    var A = this && this.__extends || function () {
        var a = function (g, r) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, e) {
            a.__proto__ = e;
          } || function (a, e) {
            for (var d in e) e.hasOwnProperty(d) && (a[d] = e[d]);
          };
          return a(g, r);
        };
        return function (g, r) {
          function l() {
            this.constructor = g;
          }
          a(g, r);
          g.prototype = null === r ? Object.create(r) : (l.prototype = r.prototype, new l());
        };
      }(),
      F = a.seriesTypes.line,
      C = g.merge,
      B = g.pick;
    g = function (a) {
      function g() {
        var g = null !== a && a.apply(this, arguments) || this;
        g.data = void 0;
        g.options = void 0;
        g.points = void 0;
        return g;
      }
      A(g, a);
      g.prototype.getPointSpline = function (a, g, e) {
        var d = g.plotX || 0,
          h = g.plotY || 0,
          m = a[e - 1];
        e = a[e + 1];
        if (m && !m.isNull && !1 !== m.doCurve && !g.isCliff && e && !e.isNull && !1 !== e.doCurve && !g.isCliff) {
          a = m.plotY || 0;
          var k = e.plotX || 0;
          e = e.plotY || 0;
          var l = 0;
          var r = (1.5 * d + (m.plotX || 0)) / 2.5;
          var t = (1.5 * h + a) / 2.5;
          k = (1.5 * d + k) / 2.5;
          var A = (1.5 * h + e) / 2.5;
          k !== r && (l = (A - t) * (k - d) / (k - r) + h - A);
          t += l;
          A += l;
          t > a && t > h ? (t = Math.max(a, h), A = 2 * h - t) : t < a && t < h && (t = Math.min(a, h), A = 2 * h - t);
          A > e && A > h ? (A = Math.max(e, h), t = 2 * h - A) : A < e && A < h && (A = Math.min(e, h), t = 2 * h - A);
          g.rightContX = k;
          g.rightContY = A;
        }
        g = ["C", B(m.rightContX, m.plotX, 0), B(m.rightContY, m.plotY, 0), B(r, d, 0), B(t, h, 0), d, h];
        m.rightContX = m.rightContY = void 0;
        return g;
      };
      g.defaultOptions = C(F.defaultOptions);
      return g;
    }(F);
    a.registerSeriesType("spline", g);
    "";
    return g;
  });
  K(g, "Series/AreaSpline/AreaSplineSeries.js", [g["Series/Spline/SplineSeries.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F) {
    var A = this && this.__extends || function () {
        var a = function (e, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return a(e, d);
        };
        return function (e, d) {
          function g() {
            this.constructor = e;
          }
          a(e, d);
          e.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
        };
      }(),
      B = x.seriesTypes,
      H = B.area;
    B = B.area.prototype;
    var t = F.extend,
      r = F.merge;
    F = function (g) {
      function e() {
        var a = null !== g && g.apply(this, arguments) || this;
        a.data = void 0;
        a.points = void 0;
        a.options = void 0;
        return a;
      }
      A(e, g);
      e.defaultOptions = r(a.defaultOptions, H.defaultOptions);
      return e;
    }(a);
    t(F.prototype, {
      getGraphPath: B.getGraphPath,
      getStackPoints: B.getStackPoints,
      drawGraph: B.drawGraph,
      drawLegendSymbol: g.drawRectangle
    });
    x.registerSeriesType("areaspline", F);
    "";
    return F;
  });
  K(g, "Series/Column/ColumnSeriesDefaults.js", [], function () {
    "";

    return {
      borderRadius: 0,
      centerInCategory: !1,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1,
          brightness: .1
        },
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      },
      dataLabels: {
        align: void 0,
        verticalAlign: void 0,
        y: void 0
      },
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: "#ffffff"
    };
  });
  K(g, "Series/Column/ColumnSeries.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Color/Color.js"], g["Series/Column/ColumnSeriesDefaults.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B, H, t) {
    var r = this && this.__extends || function () {
        var a = function (c, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(c, d);
        };
        return function (c, d) {
          function e() {
            this.constructor = c;
          }
          a(c, d);
          c.prototype = null === d ? Object.create(d) : (e.prototype = d.prototype, new e());
        };
      }(),
      l = a.animObject,
      e = g.parse,
      d = F.hasTouch;
    a = F.noop;
    var h = t.clamp,
      m = t.defined,
      k = t.extend,
      p = t.fireEvent,
      A = t.isArray,
      I = t.isNumber,
      E = t.merge,
      L = t.pick,
      y = t.objectEach;
    t = function (a) {
      function c() {
        var c = null !== a && a.apply(this, arguments) || this;
        c.borderWidth = void 0;
        c.data = void 0;
        c.group = void 0;
        c.options = void 0;
        c.points = void 0;
        return c;
      }
      r(c, a);
      c.prototype.animate = function (a) {
        var c = this,
          b = this.yAxis,
          d = c.options,
          e = this.chart.inverted,
          f = {},
          g = e ? "translateX" : "translateY";
        if (a) f.scaleY = .001, a = h(b.toPixels(d.threshold), b.pos, b.pos + b.len), e ? f.translateX = a - b.len : f.translateY = a, c.clipBox && c.setClip(), c.group.attr(f);else {
          var m = Number(c.group.attr(g));
          c.group.animate({
            scaleY: 1
          }, k(l(c.options.animation), {
            step: function (a, d) {
              c.group && (f[g] = m + d.pos * (b.pos - m), c.group.attr(f));
            }
          }));
        }
      };
      c.prototype.init = function (c, d) {
        a.prototype.init.apply(this, arguments);
        var b = this;
        c = b.chart;
        c.hasRendered && c.series.forEach(function (a) {
          a.type === b.type && (a.isDirty = !0);
        });
      };
      c.prototype.getColumnMetrics = function () {
        var a = this,
          c = a.options,
          b = a.xAxis,
          d = a.yAxis,
          e = b.options.reversedStacks;
        e = b.reversed && !e || !b.reversed && e;
        var g = {},
          h,
          k = 0;
        !1 === c.grouping ? k = 1 : a.chart.series.forEach(function (b) {
          var c = b.yAxis,
            e = b.options;
          if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === c.len && d.pos === c.pos) {
            if (e.stacking && "group" !== e.stacking) {
              h = b.stackKey;
              "undefined" === typeof g[h] && (g[h] = k++);
              var f = g[h];
            } else !1 !== e.grouping && (f = k++);
            b.columnIndex = f;
          }
        });
        var m = Math.min(Math.abs(b.transA) * (b.ordinal && b.ordinal.slope || c.pointRange || b.closestPointRange || b.tickInterval || 1), b.len),
          l = m * c.groupPadding,
          p = (m - 2 * l) / (k || 1);
        c = Math.min(c.maxPointWidth || b.len, L(c.pointWidth, p * (1 - 2 * c.pointPadding)));
        a.columnMetrics = {
          width: c,
          offset: (p - c) / 2 + (l + ((a.columnIndex || 0) + (e ? 1 : 0)) * p - m / 2) * (e ? -1 : 1),
          paddedWidth: p,
          columnCount: k
        };
        return a.columnMetrics;
      };
      c.prototype.crispCol = function (a, c, b, d) {
        var e = this.chart,
          f = this.borderWidth,
          g = -(f % 2 ? .5 : 0);
        f = f % 2 ? .5 : 1;
        e.inverted && e.renderer.isVML && (f += 1);
        this.options.crisp && (b = Math.round(a + b) + g, a = Math.round(a) + g, b -= a);
        d = Math.round(c + d) + f;
        g = .5 >= Math.abs(c) && .5 < d;
        c = Math.round(c) + f;
        d -= c;
        g && d && (--c, d += 1);
        return {
          x: a,
          y: c,
          width: b,
          height: d
        };
      };
      c.prototype.adjustForMissingColumns = function (a, c, b, d) {
        var e = this,
          f = this.options.stacking;
        if (!b.isNull && 1 < d.columnCount) {
          var g = this.yAxis.options.reversedStacks,
            h = 0,
            k = g ? 0 : -d.columnCount;
          y(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {
            if ("number" === typeof b.x) {
              var c = a[b.x.toString()];
              c && (a = c.points[e.index], f ? (a && (h = k), c.hasValidPoints && (g ? k++ : k--)) : A(a) && (a = Object.keys(c.points).filter(function (b) {
                return !b.match(",") && c.points[b] && 1 < c.points[b].length;
              }).map(parseFloat).sort(function (b, a) {
                return a - b;
              }), h = a.indexOf(e.index), k = a.length));
            }
          });
          a = (b.plotX || 0) + ((k - 1) * d.paddedWidth + c) / 2 - c - h * d.paddedWidth;
        }
        return a;
      };
      c.prototype.translate = function () {
        var a = this,
          c = a.chart,
          b = a.options,
          d = a.dense = 2 > a.closestPointRange * a.xAxis.transA;
        d = a.borderWidth = L(b.borderWidth, d ? 0 : 1);
        var e = a.xAxis,
          g = a.yAxis,
          k = b.threshold,
          l = a.translatedThreshold = g.getThreshold(k),
          p = L(b.minPointLength, 5),
          r = a.getColumnMetrics(),
          w = r.width,
          y = a.pointXOffset = r.offset,
          v = a.dataMin,
          t = a.dataMax,
          A = a.barW = Math.max(w, 1 + 2 * d);
        c.inverted && (l -= .5);
        b.pointPadding && (A = Math.ceil(A));
        B.prototype.translate.apply(a);
        a.points.forEach(function (d) {
          var f = L(d.yBottom, l),
            n = 999 + Math.abs(f),
            q = d.plotX || 0;
          n = h(d.plotY, -n, g.len + n);
          var u = Math.min(n, f),
            z = Math.max(n, f) - u,
            D = w,
            x = q + y,
            E = A;
          p && Math.abs(z) < p && (z = p, q = !g.reversed && !d.negative || g.reversed && d.negative, I(k) && I(t) && d.y === k && t <= k && (g.min || 0) < k && (v !== t || (g.max || 0) <= k) && (q = !q), u = Math.abs(u - l) > p ? f - p : l - (q ? p : 0));
          m(d.options.pointWidth) && (D = E = Math.ceil(d.options.pointWidth), x -= Math.round((D - w) / 2));
          b.centerInCategory && (x = a.adjustForMissingColumns(x, D, d, r));
          d.barX = x;
          d.pointWidth = D;
          d.tooltipPos = c.inverted ? [h(g.len + g.pos - c.plotLeft - n, g.pos - c.plotLeft, g.len + g.pos - c.plotLeft), e.len + e.pos - c.plotTop - x - E / 2, z] : [e.left - c.plotLeft + x + E / 2, h(n + g.pos - c.plotTop, g.pos - c.plotTop, g.len + g.pos - c.plotTop), z];
          d.shapeType = a.pointClass.prototype.shapeType || "rect";
          d.shapeArgs = a.crispCol.apply(a, d.isNull ? [x, l, E, 0] : [x, u, E, z]);
        });
      };
      c.prototype.drawGraph = function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      };
      c.prototype.pointAttribs = function (a, c) {
        var b = this.options,
          d = this.pointAttrToOptions || {},
          f = d.stroke || "borderColor",
          g = d["stroke-width"] || "borderWidth",
          h = a && a.color || this.color,
          k = a && a[f] || b[f] || h;
        d = a && a.options.dashStyle || b.dashStyle;
        var n = a && a[g] || b[g] || this[g] || 0,
          m = L(a && a.opacity, b.opacity, 1);
        if (a && this.zones.length) {
          var l = a.getZone();
          h = a.options.color || l && (l.color || a.nonZonedColor) || this.color;
          l && (k = l.borderColor || k, d = l.dashStyle || d, n = l.borderWidth || n);
        }
        c && a && (a = E(b.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, h = a.color || "undefined" !== typeof c && e(h).brighten(a.brightness).get() || h, k = a[f] || k, n = a[g] || n, d = a.dashStyle || d, m = L(a.opacity, m));
        f = {
          fill: h,
          stroke: k,
          "stroke-width": n,
          opacity: m
        };
        d && (f.dashstyle = d);
        return f;
      };
      c.prototype.drawPoints = function (a) {
        void 0 === a && (a = this.points);
        var c = this,
          b = this.chart,
          d = c.options,
          e = b.renderer,
          f = d.animationLimit || 250,
          g;
        a.forEach(function (a) {
          var h = a.graphic,
            k = !!h,
            n = h && b.pointCount < f ? "animate" : "attr";
          if (I(a.plotY) && null !== a.y) {
            g = a.shapeArgs;
            h && a.hasNewShapeType() && (h = h.destroy());
            c.enabledDataSorting && (a.startXPos = c.xAxis.reversed ? -(g ? g.width || 0 : 0) : c.xAxis.width);
            h || (a.graphic = h = e[a.shapeType](g).add(a.group || c.group)) && c.enabledDataSorting && b.hasRendered && b.pointCount < f && (h.attr({
              x: a.startXPos
            }), k = !0, n = "animate");
            if (h && k) h[n](E(g));
            if (d.borderRadius) h[n]({
              r: d.borderRadius
            });
            b.styledMode || h[n](c.pointAttribs(a, a.selected && "select")).shadow(!1 !== a.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
            h && (h.addClass(a.getClassName(), !0), h.attr({
              visibility: a.visible ? "inherit" : "hidden"
            }));
          } else h && (a.graphic = h.destroy());
        });
      };
      c.prototype.drawTracker = function (a) {
        void 0 === a && (a = this.points);
        var c = this,
          b = c.chart,
          e = b.pointer,
          f = function (a) {
            var b = e.getPointFromEvent(a);
            "undefined" !== typeof b && (e.isDirectTouch = !0, b.onMouseOver(a));
          },
          g;
        a.forEach(function (a) {
          g = A(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
          a.graphic && (a.graphic.element.point = a);
          g.forEach(function (b) {
            b.div ? b.div.point = a : b.element.point = a;
          });
        });
        c._hasTracking || (c.trackerGroups.forEach(function (a) {
          if (c[a]) {
            c[a].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
              e.onTrackerMouseOut(a);
            });
            if (d) c[a].on("touchstart", f);
            !b.styledMode && c.options.cursor && c[a].css({
              cursor: c.options.cursor
            });
          }
        }), c._hasTracking = !0);
        p(this, "afterDrawTracker");
      };
      c.prototype.remove = function () {
        var a = this,
          c = a.chart;
        c.hasRendered && c.series.forEach(function (b) {
          b.type === a.type && (b.isDirty = !0);
        });
        B.prototype.remove.apply(a, arguments);
      };
      c.defaultOptions = E(B.defaultOptions, x);
      return c;
    }(B);
    k(t.prototype, {
      cropShoulder: 0,
      directTouch: !0,
      drawLegendSymbol: C.drawRectangle,
      getSymbol: a,
      negStacks: !0,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    H.registerSeriesType("column", t);
    "";
    return t;
  });
  K(g, "Core/Series/DataLabel.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/FormatUtilities.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = a.getDeferredAnimation,
      C = g.format,
      B = x.defined,
      H = x.extend,
      t = x.fireEvent,
      r = x.isArray,
      l = x.isString,
      e = x.merge,
      d = x.objectEach,
      h = x.pick,
      m = x.splat,
      k;
    (function (a) {
      function g(a, c, b, d, e) {
        var f = this,
          g = this.chart,
          k = this.isCartesian && g.inverted,
          n = this.enabledDataSorting,
          m = a.plotX,
          l = a.plotY,
          p = b.rotation,
          r = b.align,
          u = B(m) && B(l) && g.isInsidePlot(m, Math.round(l), {
            inverted: k,
            paneCoordinates: !0,
            series: f
          });
        l = function (b) {
          n && f.xAxis && !w && f.setDataLabelStartPos(a, c, e, u, b);
        };
        var w = "justify" === h(b.overflow, n ? "none" : "justify");
        m = this.visible && !1 !== a.visible && B(m) && (a.series.forceDL || n && !w || u || h(b.inside, !!this.options.stacking) && d && g.isInsidePlot(m, k ? d.x + 1 : d.y + d.height - 1, {
          inverted: k,
          paneCoordinates: !0,
          series: f
        }));
        k = a.pos();
        if (m && k) {
          p && c.attr({
            align: r
          });
          r = c.getBBox(!0);
          var y = [0, 0];
          var t = g.renderer.fontMetrics(g.styledMode ? void 0 : b.style.fontSize, c).b;
          d = H({
            x: k[0],
            y: Math.round(k[1]),
            width: 0,
            height: 0
          }, d);
          H(b, {
            width: r.width,
            height: r.height
          });
          p ? (w = !1, y = g.renderer.rotCorr(t, p), t = {
            x: d.x + (b.x || 0) + d.width / 2 + y.x,
            y: d.y + (b.y || 0) + {
              top: 0,
              middle: .5,
              bottom: 1
            }[b.verticalAlign] * d.height
          }, y = [r.x - Number(c.attr("x")), r.y - Number(c.attr("y"))], l(t), c[e ? "attr" : "animate"](t)) : (l(d), c.align(b, void 0, d), t = c.alignAttr);
          w && 0 <= d.height ? this.justifyDataLabel(c, b, t, r, d, e) : h(b.crop, !0) && (d = t.x, l = t.y, d += y[0], l += y[1], m = g.isInsidePlot(d, l, {
            paneCoordinates: !0,
            series: f
          }) && g.isInsidePlot(d + r.width, l + r.height, {
            paneCoordinates: !0,
            series: f
          }));
          if (b.shape && !p) c[e ? "attr" : "animate"]({
            anchorX: k[0],
            anchorY: k[1]
          });
        }
        e && n && (c.placed = !1);
        m || n && !w ? c.show() : (c.hide(), c.placed = !1);
      }
      function k(a, c) {
        var b = c.filter;
        return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
      }
      function p(a) {
        void 0 === a && (a = this.points);
        var c = this,
          b = c.chart,
          e = c.options,
          f = c.hasRendered || 0,
          g = b.renderer,
          p = b.options.chart,
          w = p.backgroundColor;
        p = p.plotBackgroundColor;
        var x = g.getContrast(l(p) && p || l(w) && w || "#000000"),
          D = e.dataLabels,
          E;
        w = D.animation;
        w = D.defer ? A(b, w, c) : {
          defer: 0,
          duration: 0
        };
        D = y(y(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[c.type] && b.options.plotOptions[c.type].dataLabels), D);
        t(this, "drawDataLabels");
        if (r(D) || D.enabled || c._hasPointLabels) {
          var F = c.plotGroup("dataLabelsGroup", "data-labels", f ? "inherit" : "hidden", D.zIndex || 6);
          F.attr({
            opacity: +f
          });
          !f && (f = c.dataLabelsGroup) && (c.visible && F.show(), f[e.animation ? "animate" : "attr"]({
            opacity: 1
          }, w));
          a.forEach(function (a) {
            E = m(y(D, a.dlOptions || a.options && a.options.dataLabels));
            E.forEach(function (f, n) {
              var m = f.enabled && (!a.isNull || a.dataLabelOnNull) && k(a, f),
                l = a.connectors ? a.connectors[n] : a.connector,
                p = a.dataLabels ? a.dataLabels[n] : a.dataLabel,
                q = !p,
                r = h(f.distance, a.labelDistance);
              if (m) {
                var u = a.getLabelConfig();
                var w = h(f[a.formatPrefix + "Format"], f.format);
                u = B(w) ? C(w, u, b) : (f[a.formatPrefix + "Formatter"] || f.formatter).call(u, f);
                w = f.style;
                var y = f.rotation;
                b.styledMode || (w.color = h(f.color, w.color, c.color, "#000000"), "contrast" === w.color ? (a.contrastColor = g.getContrast(a.color || c.color), w.color = !B(r) && f.inside || 0 > r || e.stacking ? a.contrastColor : x) : delete a.contrastColor, e.cursor && (w.cursor = e.cursor));
                var t = {
                  r: f.borderRadius || 0,
                  rotation: y,
                  padding: f.padding,
                  zIndex: 1
                };
                if (!b.styledMode) {
                  r = f.backgroundColor;
                  var v = f.borderColor;
                  t.fill = "auto" === r ? a.color : r;
                  t.stroke = "auto" === v ? a.color : v;
                  t["stroke-width"] = f.borderWidth;
                }
                d(t, function (a, b) {
                  "undefined" === typeof a && delete t[b];
                });
              }
              !p || m && B(u) && !!p.div === !!f.useHTML && (p.rotation && f.rotation || p.rotation === f.rotation) || (q = !0, a.dataLabel = p = a.dataLabel && a.dataLabel.destroy(), a.dataLabels && (1 === a.dataLabels.length ? delete a.dataLabels : delete a.dataLabels[n]), n || delete a.dataLabel, l && (a.connector = a.connector.destroy(), a.connectors && (1 === a.connectors.length ? delete a.connectors : delete a.connectors[n])));
              m && B(u) ? (p ? t.text = u : (a.dataLabels = a.dataLabels || [], p = a.dataLabels[n] = y ? g.text(u, 0, 0, f.useHTML).addClass("highcharts-data-label") : g.label(u, 0, 0, f.shape, null, null, f.useHTML, null, "data-label"), n || (a.dataLabel = p), p.addClass(" highcharts-data-label-color-" + a.colorIndex + " " + (f.className || "") + (f.useHTML ? " highcharts-tracker" : ""))), p.options = f, p.attr(t), b.styledMode || p.css(w).shadow(f.shadow), (n = f[a.formatPrefix + "TextPath"] || f.textPath) && !f.useHTML && (p.setTextPath(a.getDataLabelPath && a.getDataLabelPath(p) || a.graphic, n), a.dataLabelPath && !n.enabled && (a.dataLabelPath = a.dataLabelPath.destroy())), p.added || p.add(F), c.alignDataLabel(a, p, f, null, q)) : p && p.hide();
            });
          });
        }
        t(this, "afterDrawDataLabels");
      }
      function x(a, c, b, d, e, g) {
        var f = this.chart,
          h = c.align,
          k = c.verticalAlign,
          n = a.box ? 0 : a.padding || 0,
          m = c.x;
        m = void 0 === m ? 0 : m;
        var l = c.y;
        l = void 0 === l ? 0 : l;
        var p = (b.x || 0) + n;
        if (0 > p) {
          "right" === h && 0 <= m ? (c.align = "left", c.inside = !0) : m -= p;
          var q = !0;
        }
        p = (b.x || 0) + d.width - n;
        p > f.plotWidth && ("left" === h && 0 >= m ? (c.align = "right", c.inside = !0) : m += f.plotWidth - p, q = !0);
        p = b.y + n;
        0 > p && ("bottom" === k && 0 <= l ? (c.verticalAlign = "top", c.inside = !0) : l -= p, q = !0);
        p = (b.y || 0) + d.height - n;
        p > f.plotHeight && ("top" === k && 0 >= l ? (c.verticalAlign = "bottom", c.inside = !0) : l += f.plotHeight - p, q = !0);
        q && (c.x = m, c.y = l, a.placed = !g, a.align(c, void 0, e));
        return q;
      }
      function y(a, c) {
        var b = [],
          d;
        if (r(a) && !r(c)) b = a.map(function (a) {
          return e(a, c);
        });else if (r(c) && !r(a)) b = c.map(function (b) {
          return e(a, b);
        });else if (r(a) || r(c)) for (d = Math.max(a.length, c.length); d--;) b[d] = e(a[d], c[d]);else b = e(a, c);
        return b;
      }
      function c(a, c, b, d, e) {
        var f = this.chart,
          g = f.inverted,
          h = this.xAxis,
          k = h.reversed,
          m = g ? c.height / 2 : c.width / 2;
        a = (a = a.pointWidth) ? a / 2 : 0;
        c.startXPos = g ? e.x : k ? -m - a : h.width - m + a;
        c.startYPos = g ? k ? this.yAxis.height - m + a : -m - a : e.y;
        d ? "hidden" === c.visibility && (c.show(), c.attr({
          opacity: 0
        }).animate({
          opacity: 1
        })) : c.attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, void 0, c.hide);
        f.hasRendered && (b && c.attr({
          x: c.startXPos,
          y: c.startYPos
        }), c.placed = !0);
      }
      var w = [];
      a.compose = function (a) {
        if (-1 === w.indexOf(a)) {
          var d = a.prototype;
          w.push(a);
          d.alignDataLabel = g;
          d.drawDataLabels = p;
          d.justifyDataLabel = x;
          d.setDataLabelStartPos = c;
        }
      };
    })(k || (k = {}));
    "";
    return k;
  });
  K(g, "Series/Column/ColumnDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = g.series,
      C = x.merge,
      B = x.pick,
      H;
    (function (g) {
      function r(a, d, g, m, k) {
        var e = this.chart.inverted,
          h = a.series,
          l = (h.xAxis ? h.xAxis.len : this.chart.plotSizeX) || 0;
        h = (h.yAxis ? h.yAxis.len : this.chart.plotSizeY) || 0;
        var r = a.dlBox || a.shapeArgs,
          t = B(a.below, a.plotY > B(this.translatedThreshold, h)),
          y = B(g.inside, !!this.options.stacking);
        r && (m = C(r), 0 > m.y && (m.height += m.y, m.y = 0), r = m.y + m.height - h, 0 < r && r < m.height && (m.height -= r), e && (m = {
          x: h - m.y - m.height,
          y: l - m.x - m.width,
          width: m.height,
          height: m.width
        }), y || (e ? (m.x += t ? 0 : m.width, m.width = 0) : (m.y += t ? m.height : 0, m.height = 0)));
        g.align = B(g.align, !e || y ? "center" : t ? "right" : "left");
        g.verticalAlign = B(g.verticalAlign, e || y ? "middle" : t ? "top" : "bottom");
        A.prototype.alignDataLabel.call(this, a, d, g, m, k);
        g.inside && a.contrastColor && d.css({
          color: a.contrastColor
        });
      }
      var l = [];
      g.compose = function (e) {
        a.compose(A);
        -1 === l.indexOf(e) && (l.push(e), e.prototype.alignDataLabel = r);
      };
    })(H || (H = {}));
    return H;
  });
  K(g, "Series/Bar/BarSeries.js", [g["Series/Column/ColumnSeries.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = this && this.__extends || function () {
        var a = function (g, r) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, e) {
            a.__proto__ = e;
          } || function (a, e) {
            for (var d in e) e.hasOwnProperty(d) && (a[d] = e[d]);
          };
          return a(g, r);
        };
        return function (g, r) {
          function l() {
            this.constructor = g;
          }
          a(g, r);
          g.prototype = null === r ? Object.create(r) : (l.prototype = r.prototype, new l());
        };
      }(),
      C = x.extend,
      B = x.merge;
    x = function (g) {
      function t() {
        var a = null !== g && g.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      A(t, g);
      t.defaultOptions = B(a.defaultOptions, {});
      return t;
    }(a);
    C(x.prototype, {
      inverted: !0
    });
    g.registerSeriesType("bar", x);
    "";
    return x;
  });
  K(g, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {
    "";

    return {
      lineWidth: 0,
      findNearestPointBy: "xy",
      jitter: {
        x: 0,
        y: 0
      },
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    };
  });
  K(g, "Series/Scatter/ScatterSeries.js", [g["Series/Scatter/ScatterSeriesDefaults.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = this && this.__extends || function () {
        var a = function (e, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return a(e, d);
        };
        return function (e, d) {
          function g() {
            this.constructor = e;
          }
          a(e, d);
          e.prototype = null === d ? Object.create(d) : (g.prototype = d.prototype, new g());
        };
      }(),
      C = g.seriesTypes,
      B = C.column,
      H = C.line;
    C = x.addEvent;
    var t = x.extend,
      r = x.merge;
    x = function (g) {
      function e() {
        var a = null !== g && g.apply(this, arguments) || this;
        a.data = void 0;
        a.options = void 0;
        a.points = void 0;
        return a;
      }
      A(e, g);
      e.prototype.applyJitter = function () {
        var a = this,
          e = this.options.jitter,
          g = this.points.length;
        e && this.points.forEach(function (d, h) {
          ["x", "y"].forEach(function (k, m) {
            var l = "plot" + k.toUpperCase();
            if (e[k] && !d.isNull) {
              var p = a[k + "Axis"];
              var r = e[k] * p.transA;
              if (p && !p.isLog) {
                var c = Math.max(0, d[l] - r);
                p = Math.min(p.len, d[l] + r);
                m = 1E4 * Math.sin(h + m * g);
                d[l] = c + (p - c) * (m - Math.floor(m));
                "x" === k && (d.clientX = d.plotX);
              }
            }
          });
        });
      };
      e.prototype.drawGraph = function () {
        this.options.lineWidth ? g.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
      };
      e.defaultOptions = r(H.defaultOptions, a);
      return e;
    }(H);
    t(x.prototype, {
      drawTracker: B.prototype.drawTracker,
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1
    });
    C(x, "afterTranslate", function () {
      this.applyJitter();
    });
    g.registerSeriesType("scatter", x);
    return x;
  });
  K(g, "Series/CenteredUtilities.js", [g["Core/Globals.js"], g["Core/Series/Series.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = a.deg2rad,
      C = x.fireEvent,
      B = x.isNumber,
      H = x.pick,
      t = x.relativeLength,
      r;
    (function (a) {
      a.getCenter = function () {
        var a = this.options,
          d = this.chart,
          h = 2 * (a.slicedOffset || 0),
          m = d.plotWidth - 2 * h,
          k = d.plotHeight - 2 * h,
          l = a.center,
          r = Math.min(m, k),
          A = a.thickness,
          x = a.size,
          F = a.innerSize || 0;
        "string" === typeof x && (x = parseFloat(x));
        "string" === typeof F && (F = parseFloat(F));
        a = [H(l[0], "50%"), H(l[1], "50%"), H(x && 0 > x ? void 0 : a.size, "100%"), H(F && 0 > F ? void 0 : a.innerSize || 0, "0%")];
        !d.angular || this instanceof g || (a[3] = 0);
        for (l = 0; 4 > l; ++l) x = a[l], d = 2 > l || 2 === l && /%$/.test(x), a[l] = t(x, [m, k, r, a[2]][l]) + (d ? h : 0);
        a[3] > a[2] && (a[3] = a[2]);
        B(A) && 2 * A < a[2] && 0 < A && (a[3] = a[2] - 2 * A);
        C(this, "afterGetCenter", {
          positions: a
        });
        return a;
      };
      a.getStartAndEndRadians = function (a, d) {
        a = B(a) ? a : 0;
        d = B(d) && d > a && 360 > d - a ? d : a + 360;
        return {
          start: A * (a + -90),
          end: A * (d + -90)
        };
      };
    })(r || (r = {}));
    "";
    return r;
  });
  K(g, "Series/Pie/PiePoint.js", [g["Core/Animation/AnimationUtilities.js"], g["Core/Series/Point.js"], g["Core/Utilities.js"]], function (a, g, x) {
    var A = this && this.__extends || function () {
        var a = function (d, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var e in d) d.hasOwnProperty(e) && (a[e] = d[e]);
          };
          return a(d, e);
        };
        return function (d, e) {
          function g() {
            this.constructor = d;
          }
          a(d, e);
          d.prototype = null === e ? Object.create(e) : (g.prototype = e.prototype, new g());
        };
      }(),
      C = a.setAnimation,
      B = x.addEvent,
      H = x.defined;
    a = x.extend;
    var t = x.isNumber,
      r = x.pick,
      l = x.relativeLength;
    g = function (a) {
      function d() {
        var d = null !== a && a.apply(this, arguments) || this;
        d.labelDistance = void 0;
        d.options = void 0;
        d.series = void 0;
        return d;
      }
      A(d, a);
      d.prototype.getConnectorPath = function () {
        var a = this.labelPosition,
          d = this.series.options.dataLabels,
          e = this.connectorShapes,
          g = d.connectorShape;
        e[g] && (g = e[g]);
        return g.call(this, {
          x: a.final.x,
          y: a.final.y,
          alignment: a.alignment
        }, a.connectorPosition, d);
      };
      d.prototype.getTranslate = function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      };
      d.prototype.haloPath = function (a) {
        var d = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + a, d.r + a, {
          innerR: d.r - 1,
          start: d.start,
          end: d.end
        });
      };
      d.prototype.init = function () {
        var d = this;
        a.prototype.init.apply(this, arguments);
        this.name = r(this.name, "Slice");
        var e = function (a) {
          d.slice("select" === a.type);
        };
        B(this, "select", e);
        B(this, "unselect", e);
        return this;
      };
      d.prototype.isValid = function () {
        return t(this.y) && 0 <= this.y;
      };
      d.prototype.setVisible = function (a, d) {
        var e = this,
          g = this.series,
          h = g.chart,
          m = g.options.ignoreHiddenPoint;
        d = r(d, m);
        a !== this.visible && (this.visible = this.options.visible = a = "undefined" === typeof a ? !this.visible : a, g.options.data[g.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (d) {
          if (e[d]) e[d][a ? "show" : "hide"](a);
        }), this.legendItem && h.legend.colorizeItem(this, a), a || "hover" !== this.state || this.setState(""), m && (g.isDirty = !0), d && h.redraw());
      };
      d.prototype.slice = function (a, d, e) {
        var g = this.series;
        C(e, g.chart);
        r(d, !0);
        this.sliced = this.options.sliced = H(a) ? a : !this.sliced;
        g.options.data[g.data.indexOf(this)] = this.options;
        this.graphic && this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      };
      return d;
    }(g);
    a(g.prototype, {
      connectorShapes: {
        fixedOffset: function (a, d, g) {
          var e = d.breakAt;
          d = d.touchingSliceAt;
          return [["M", a.x, a.y], g.softConnector ? ["C", a.x + ("left" === a.alignment ? -5 : 5), a.y, 2 * e.x - d.x, 2 * e.y - d.y, e.x, e.y] : ["L", e.x, e.y], ["L", d.x, d.y]];
        },
        straight: function (a, d) {
          d = d.touchingSliceAt;
          return [["M", a.x, a.y], ["L", d.x, d.y]];
        },
        crookedLine: function (a, d, g) {
          d = d.touchingSliceAt;
          var e = this.series,
            h = e.center[0],
            p = e.chart.plotWidth,
            r = e.chart.plotLeft;
          e = a.alignment;
          var t = this.shapeArgs.r;
          g = l(g.crookDistance, 1);
          p = "left" === e ? h + t + (p + r - h - t) * (1 - g) : r + (h - t) * g;
          g = ["L", p, a.y];
          h = !0;
          if ("left" === e ? p > a.x || p < d.x : p < a.x || p > d.x) h = !1;
          a = [["M", a.x, a.y]];
          h && a.push(g);
          a.push(["L", d.x, d.y]);
          return a;
        }
      }
    });
    return g;
  });
  K(g, "Series/Pie/PieSeriesDefaults.js", [], function () {
    "";

    return {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        allowOverlap: !0,
        connectorPadding: 5,
        connectorShape: "fixedOffset",
        crookDistance: "70%",
        distance: 30,
        enabled: !0,
        formatter: function () {
          return this.point.isNull ? void 0 : this.point.name;
        },
        softConnector: !0,
        x: 0
      },
      fillColor: void 0,
      ignoreHiddenPoint: !0,
      inactiveOtherPoints: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      },
      borderColor: "#ffffff",
      borderWidth: 1,
      lineWidth: void 0,
      states: {
        hover: {
          brightness: .1
        }
      }
    };
  });
  K(g, "Series/Pie/PieSeries.js", [g["Series/CenteredUtilities.js"], g["Series/Column/ColumnSeries.js"], g["Core/Globals.js"], g["Core/Legend/LegendSymbol.js"], g["Series/Pie/PiePoint.js"], g["Series/Pie/PieSeriesDefaults.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Renderer/SVG/Symbols.js"], g["Core/Utilities.js"]], function (a, g, x, F, C, B, H, t, r, l) {
    var e = this && this.__extends || function () {
        var a = function (d, e) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, d) {
            a.__proto__ = d;
          } || function (a, d) {
            for (var c in d) d.hasOwnProperty(c) && (a[c] = d[c]);
          };
          return a(d, e);
        };
        return function (d, e) {
          function c() {
            this.constructor = d;
          }
          a(d, e);
          d.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(),
      d = a.getStartAndEndRadians;
    x = x.noop;
    var h = l.clamp,
      m = l.extend,
      k = l.fireEvent,
      p = l.merge,
      A = l.pick,
      I = l.relativeLength;
    l = function (a) {
      function g() {
        var d = null !== a && a.apply(this, arguments) || this;
        d.center = void 0;
        d.data = void 0;
        d.maxLabelDistance = void 0;
        d.options = void 0;
        d.points = void 0;
        return d;
      }
      e(g, a);
      g.prototype.animate = function (a) {
        var c = this,
          d = c.points,
          e = c.startAngleRad;
        a || d.forEach(function (a) {
          var b = a.graphic,
            d = a.shapeArgs;
          b && d && (b.attr({
            r: A(a.startR, c.center && c.center[3] / 2),
            start: e,
            end: e
          }), b.animate({
            r: d.r,
            start: d.start,
            end: d.end
          }, c.options.animation));
        });
      };
      g.prototype.drawEmpty = function () {
        var a = this.startAngleRad,
          c = this.endAngleRad,
          d = this.options;
        if (0 === this.total && this.center) {
          var e = this.center[0];
          var g = this.center[1];
          this.graph || (this.graph = this.chart.renderer.arc(e, g, this.center[1] / 2, 0, a, c).addClass("highcharts-empty-series").add(this.group));
          this.graph.attr({
            d: r.arc(e, g, this.center[2] / 2, 0, {
              start: a,
              end: c,
              innerR: this.center[3] / 2
            })
          });
          this.chart.styledMode || this.graph.attr({
            "stroke-width": d.borderWidth,
            fill: d.fillColor || "none",
            stroke: d.color || "#cccccc"
          });
        } else this.graph && (this.graph = this.graph.destroy());
      };
      g.prototype.drawPoints = function () {
        var a = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = a[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      };
      g.prototype.generatePoints = function () {
        a.prototype.generatePoints.call(this);
        this.updateTotals();
      };
      g.prototype.getX = function (a, c, d) {
        var e = this.center,
          g = this.radii ? this.radii[d.index] || 0 : e[2] / 2;
        a = Math.asin(h((a - e[1]) / (g + d.labelDistance), -1, 1));
        return e[0] + (c ? -1 : 1) * Math.cos(a) * (g + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
      };
      g.prototype.hasData = function () {
        return !!this.processedXData.length;
      };
      g.prototype.redrawPoints = function () {
        var a = this,
          c = a.chart,
          d = c.renderer,
          e = a.options.shadow,
          g,
          b,
          h,
          k;
        this.drawEmpty();
        !e || a.shadowGroup || c.styledMode || (a.shadowGroup = d.g("shadow").attr({
          zIndex: -1
        }).add(a.group));
        a.points.forEach(function (f) {
          var n = {};
          b = f.graphic;
          if (!f.isNull && b) {
            var l = void 0;
            k = f.shapeArgs;
            g = f.getTranslate();
            c.styledMode || (l = f.shadowGroup, e && !l && (l = f.shadowGroup = d.g("shadow").add(a.shadowGroup)), l && l.attr(g), h = a.pointAttribs(f, f.selected && "select"));
            f.delayedRendering ? (b.setRadialReference(a.center).attr(k).attr(g), c.styledMode || b.attr(h).attr({
              "stroke-linejoin": "round"
            }).shadow(e, l), f.delayedRendering = !1) : (b.setRadialReference(a.center), c.styledMode || p(!0, n, h), p(!0, n, k, g), b.animate(n));
            b.attr({
              visibility: f.visible ? "inherit" : "hidden"
            });
            b.addClass(f.getClassName(), !0);
          } else b && (f.graphic = b.destroy());
        });
      };
      g.prototype.sortByAngle = function (a, c) {
        a.sort(function (a, d) {
          return "undefined" !== typeof a.angle && (d.angle - a.angle) * c;
        });
      };
      g.prototype.translate = function (a) {
        k(this, "translate");
        this.generatePoints();
        var c = this.options,
          e = c.slicedOffset,
          f = e + (c.borderWidth || 0),
          g = d(c.startAngle, c.endAngle),
          b = this.startAngleRad = g.start;
        g = (this.endAngleRad = g.end) - b;
        var h = this.points,
          l = c.dataLabels.distance;
        c = c.ignoreHiddenPoint;
        var m = h.length,
          p,
          r = 0;
        a || (this.center = a = this.getCenter());
        for (p = 0; p < m; p++) {
          var t = h[p];
          var y = b + r * g;
          !t.isValid() || c && !t.visible || (r += t.percentage / 100);
          var x = b + r * g;
          var D = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * y) / 1E3,
            end: Math.round(1E3 * x) / 1E3
          };
          t.shapeType = "arc";
          t.shapeArgs = D;
          t.labelDistance = A(t.options.dataLabels && t.options.dataLabels.distance, l);
          t.labelDistance = I(t.labelDistance, D.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, t.labelDistance);
          x = (x + y) / 2;
          x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);
          t.slicedTranslation = {
            translateX: Math.round(Math.cos(x) * e),
            translateY: Math.round(Math.sin(x) * e)
          };
          D = Math.cos(x) * a[2] / 2;
          var v = Math.sin(x) * a[2] / 2;
          t.tooltipPos = [a[0] + .7 * D, a[1] + .7 * v];
          t.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;
          t.angle = x;
          y = Math.min(f, t.labelDistance / 5);
          t.labelPosition = {
            natural: {
              x: a[0] + D + Math.cos(x) * t.labelDistance,
              y: a[1] + v + Math.sin(x) * t.labelDistance
            },
            "final": {},
            alignment: 0 > t.labelDistance ? "center" : t.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: a[0] + D + Math.cos(x) * y,
                y: a[1] + v + Math.sin(x) * y
              },
              touchingSliceAt: {
                x: a[0] + D,
                y: a[1] + v
              }
            }
          };
        }
        k(this, "afterTranslate");
      };
      g.prototype.updateTotals = function () {
        var a = this.points,
          c = a.length,
          d = this.options.ignoreHiddenPoint,
          e,
          g = 0;
        for (e = 0; e < c; e++) {
          var b = a[e];
          !b.isValid() || d && !b.visible || (g += b.y);
        }
        this.total = g;
        for (e = 0; e < c; e++) b = a[e], b.percentage = 0 < g && (b.visible || !d) ? b.y / g * 100 : 0, b.total = g;
      };
      g.defaultOptions = p(H.defaultOptions, B);
      return g;
    }(H);
    m(l.prototype, {
      axisTypes: [],
      directTouch: !0,
      drawGraph: void 0,
      drawLegendSymbol: F.drawRectangle,
      drawTracker: g.prototype.drawTracker,
      getCenter: a.getCenter,
      getSymbol: x,
      isCartesian: !1,
      noSharedTooltip: !0,
      pointAttribs: g.prototype.pointAttribs,
      pointClass: C,
      requireSorting: !1,
      searchPoint: x,
      trackerGroups: ["group", "dataLabelsGroup"]
    });
    t.registerSeriesType("pie", l);
    return l;
  });
  K(g, "Series/Pie/PieDataLabel.js", [g["Core/Series/DataLabel.js"], g["Core/Globals.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Series/SeriesRegistry.js"], g["Core/Utilities.js"]], function (a, g, x, F, C) {
    var A = g.noop,
      H = x.distribute,
      t = F.series,
      r = C.arrayMax,
      l = C.clamp,
      e = C.defined,
      d = C.merge,
      h = C.pick,
      m = C.relativeLength,
      k;
    (function (g) {
      function k() {
        var a = this,
          g = a.data,
          f = a.chart,
          k = a.options.dataLabels || {},
          b = k.connectorPadding,
          l = f.plotWidth,
          m = f.plotHeight,
          p = f.plotLeft,
          y = Math.round(f.chartWidth / 3),
          A = a.center,
          x = A[2] / 2,
          D = A[1],
          B = [[], []],
          E = [0, 0, 0, 0],
          v = a.dataLabelPositioners,
          C,
          F,
          I,
          L,
          G,
          K,
          M,
          X,
          R,
          V,
          Z,
          W;
        a.visible && (k.enabled || a._hasPointLabels) && (g.forEach(function (a) {
          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
            width: "auto"
          }).css({
            width: "auto",
            textOverflow: "clip"
          }), a.dataLabel.shortened = !1);
        }), t.prototype.drawDataLabels.apply(a), g.forEach(function (a) {
          a.dataLabel && (a.visible ? (B[a.half].push(a), a.dataLabel._pos = null, !e(k.style.width) && !e(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > y && (a.dataLabel.css({
            width: Math.round(.7 * y) + "px"
          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
        }), B.forEach(function (c, d) {
          var g = c.length,
            n = [],
            q;
          if (g) {
            a.sortByAngle(c, d - .5);
            if (0 < a.maxLabelDistance) {
              var r = Math.max(0, D - x - a.maxLabelDistance);
              var t = Math.min(D + x + a.maxLabelDistance, f.plotHeight);
              c.forEach(function (a) {
                0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, D - x - a.labelDistance), a.bottom = Math.min(D + x + a.labelDistance, f.plotHeight), q = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                  target: a.labelPosition.natural.y - a.top + q / 2,
                  size: q,
                  rank: a.y
                }, n.push(a.distributeBox));
              });
              r = t + q - r;
              H(n, r, r / 5);
            }
            for (Z = 0; Z < g; Z++) {
              C = c[Z];
              K = C.labelPosition;
              L = C.dataLabel;
              V = !1 === C.visible ? "hidden" : "inherit";
              R = r = K.natural.y;
              n && e(C.distributeBox) && ("undefined" === typeof C.distributeBox.pos ? V = "hidden" : (M = C.distributeBox.size, R = v.radialDistributionY(C)));
              delete C.positionIndex;
              if (k.justify) X = v.justify(C, x, A);else switch (k.alignTo) {
                case "connectors":
                  X = v.alignToConnectors(c, d, l, p);
                  break;
                case "plotEdges":
                  X = v.alignToPlotEdges(L, d, l, p);
                  break;
                default:
                  X = v.radialDistributionX(a, C, R, r);
              }
              L._attr = {
                visibility: V,
                align: K.alignment
              };
              W = C.options.dataLabels || {};
              L._pos = {
                x: X + h(W.x, k.x) + ({
                  left: b,
                  right: -b
                }[K.alignment] || 0),
                y: R + h(W.y, k.y) - 10
              };
              K.final.x = X;
              K.final.y = R;
              h(k.crop, !0) && (G = L.getBBox().width, r = null, X - G < b && 1 === d ? (r = Math.round(G - X + b), E[3] = Math.max(r, E[3])) : X + G > l - b && 0 === d && (r = Math.round(X + G - l + b), E[1] = Math.max(r, E[1])), 0 > R - M / 2 ? E[0] = Math.max(Math.round(-R + M / 2), E[0]) : R + M / 2 > m && (E[2] = Math.max(Math.round(R + M / 2 - m), E[2])), L.sideOverflow = r);
            }
          }
        }), 0 === r(E) || this.verifyDataLabelOverflow(E)) && (this.placeDataLabels(), this.points.forEach(function (b) {
          W = d(k, b.options.dataLabels);
          if (F = h(W.connectorWidth, 1)) {
            var c;
            I = b.connector;
            if ((L = b.dataLabel) && L._pos && b.visible && 0 < b.labelDistance) {
              V = L._attr.visibility;
              if (c = !I) b.connector = I = f.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + b.colorIndex + (b.className ? " " + b.className : "")).add(a.dataLabelsGroup), f.styledMode || I.attr({
                "stroke-width": F,
                stroke: W.connectorColor || b.color || "#666666"
              });
              I[c ? "attr" : "animate"]({
                d: b.getConnectorPath()
              });
              I.attr("visibility", V);
            } else I && (b.connector = I.destroy());
          }
        }));
      }
      function p() {
        this.points.forEach(function (a) {
          var c = a.dataLabel,
            d;
          c && a.visible && ((d = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
            width: c._attr.width + "px",
            textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
          }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](d), c.moved = !0) : c && c.attr({
            y: -9999
          }));
          delete a.distributeBox;
        }, this);
      }
      function x(a) {
        var c = this.center,
          d = this.options,
          e = d.center,
          b = d.minSize || 80,
          g = null !== d.size;
        if (!g) {
          if (null !== e[0]) var h = Math.max(c[2] - Math.max(a[1], a[3]), b);else h = Math.max(c[2] - a[1] - a[3], b), c[0] += (a[3] - a[1]) / 2;
          null !== e[1] ? h = l(h, b, c[2] - Math.max(a[0], a[2])) : (h = l(h, b, c[2] - a[0] - a[2]), c[1] += (a[0] - a[2]) / 2);
          h < c[2] ? (c[2] = h, c[3] = Math.min(d.thickness ? Math.max(0, h - 2 * d.thickness) : Math.max(0, m(d.innerSize || 0, h)), h), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : g = !0;
        }
        return g;
      }
      var B = [],
        y = {
          radialDistributionY: function (a) {
            return a.top + a.distributeBox.pos;
          },
          radialDistributionX: function (a, d, e, g) {
            return a.getX(e < d.top + 2 || e > d.bottom - 2 ? g : e, d.half, d);
          },
          justify: function (a, d, e) {
            return e[0] + (a.half ? -1 : 1) * (d + a.labelDistance);
          },
          alignToPlotEdges: function (a, d, e, g) {
            a = a.getBBox().width;
            return d ? a + g : e - a - g;
          },
          alignToConnectors: function (a, d, e, g) {
            var b = 0,
              c;
            a.forEach(function (a) {
              c = a.dataLabel.getBBox().width;
              c > b && (b = c);
            });
            return d ? b + g : e - b - g;
          }
        };
      g.compose = function (c) {
        a.compose(t);
        -1 === B.indexOf(c) && (B.push(c), c = c.prototype, c.dataLabelPositioners = y, c.alignDataLabel = A, c.drawDataLabels = k, c.placeDataLabels = p, c.verifyDataLabelOverflow = x);
      };
    })(k || (k = {}));
    return k;
  });
  K(g, "Extensions/OverlappingDataLabels.js", [g["Core/Chart/Chart.js"], g["Core/Utilities.js"]], function (a, g) {
    function A(a, e) {
      var d = !1;
      if (a) {
        var g = a.newOpacity;
        a.oldOpacity !== g && (a.alignAttr && a.placed ? (a[g ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), d = !0, a.alignAttr.opacity = g, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, function () {
          e.styledMode || a.css({
            pointerEvents: g ? "auto" : "none"
          });
        }), C(e, "afterHideOverlappingLabel")) : a.attr({
          opacity: g
        }));
        a.isOld = !0;
      }
      return d;
    }
    var F = g.addEvent,
      C = g.fireEvent,
      B = g.isArray,
      H = g.isNumber,
      t = g.objectEach,
      r = g.pick;
    F(a, "render", function () {
      var a = this,
        e = [];
      (this.labelCollectors || []).forEach(function (a) {
        e = e.concat(a());
      });
      (this.yAxis || []).forEach(function (a) {
        a.stacking && a.options.stackLabels && !a.options.stackLabels.allowOverlap && t(a.stacking.stacks, function (a) {
          t(a, function (a) {
            a.label && e.push(a.label);
          });
        });
      });
      (this.series || []).forEach(function (d) {
        var g = d.options.dataLabels;
        d.visible && (!1 !== g.enabled || d._hasPointLabels) && (g = function (d) {
          return d.forEach(function (d) {
            d.visible && (B(d.dataLabels) ? d.dataLabels : d.dataLabel ? [d.dataLabel] : []).forEach(function (g) {
              var h = g.options;
              g.labelrank = r(h.labelrank, d.labelrank, d.shapeArgs && d.shapeArgs.height);
              h.allowOverlap ? (g.oldOpacity = g.opacity, g.newOpacity = 1, A(g, a)) : e.push(g);
            });
          });
        }, g(d.nodes || []), g(d.points));
      });
      this.hideOverlappingLabels(e);
    });
    a.prototype.hideOverlappingLabels = function (a) {
      var e = this,
        d = a.length,
        g = e.renderer,
        l,
        k,
        p,
        r = !1;
      var t = function (a) {
        var c,
          d = a.box ? 0 : a.padding || 0,
          e = c = 0,
          h;
        if (a && (!a.alignAttr || a.placed)) {
          var b = a.alignAttr || {
            x: a.attr("x"),
            y: a.attr("y")
          };
          var k = a.parentGroup;
          a.width || (c = a.getBBox(), a.width = c.width, a.height = c.height, c = g.fontMetrics(null, a.element).h);
          var l = a.width - 2 * d;
          (h = {
            left: "0",
            center: "0.5",
            right: "1"
          }[a.alignValue]) ? e = +h * l : H(a.x) && Math.round(a.x) !== a.translateX && (e = a.x - a.translateX);
          return {
            x: b.x + (k.translateX || 0) + d - (e || 0),
            y: b.y + (k.translateY || 0) + d - c,
            width: a.width - 2 * d,
            height: a.height - 2 * d
          };
        }
      };
      for (k = 0; k < d; k++) if (l = a[k]) l.oldOpacity = l.opacity, l.newOpacity = 1, l.absoluteBox = t(l);
      a.sort(function (a, c) {
        return (c.labelrank || 0) - (a.labelrank || 0);
      });
      for (k = 0; k < d; k++) {
        var x = (t = a[k]) && t.absoluteBox;
        for (l = k + 1; l < d; ++l) {
          var B = (p = a[l]) && p.absoluteBox;
          !x || !B || t === p || 0 === t.newOpacity || 0 === p.newOpacity || "hidden" === t.visibility || "hidden" === p.visibility || B.x >= x.x + x.width || B.x + B.width <= x.x || B.y >= x.y + x.height || B.y + B.height <= x.y || ((t.labelrank < p.labelrank ? t : p).newOpacity = 0);
        }
      }
      a.forEach(function (a) {
        A(a, e) && (r = !0);
      });
      r && C(e, "afterHideAllOverlappingLabels");
    };
  });
  K(g, "Core/Responsive.js", [g["Core/Utilities.js"]], function (a) {
    var g = a.extend,
      x = a.find,
      F = a.isArray,
      C = a.isObject,
      B = a.merge,
      H = a.objectEach,
      t = a.pick,
      r = a.splat,
      l = a.uniqueKey,
      e;
    (function (a) {
      var d = [];
      a.compose = function (a) {
        -1 === d.indexOf(a) && (d.push(a), g(a.prototype, e.prototype));
        return a;
      };
      var e = function () {
        function a() {}
        a.prototype.currentOptions = function (a) {
          function d(a, g, c, h) {
            var f;
            H(a, function (a, b) {
              if (!h && -1 < e.collectionsWithUpdate.indexOf(b) && g[b]) for (a = r(a), c[b] = [], f = 0; f < Math.max(a.length, g[b].length); f++) g[b][f] && (void 0 === a[f] ? c[b][f] = g[b][f] : (c[b][f] = {}, d(a[f], g[b][f], c[b][f], h + 1)));else C(a) ? (c[b] = F(a) ? [] : {}, d(a, g[b] || {}, c[b], h + 1)) : c[b] = "undefined" === typeof g[b] ? null : g[b];
            });
          }
          var e = this,
            g = {};
          d(a, this.options, g, 0);
          return g;
        };
        a.prototype.matchResponsiveRule = function (a, d) {
          var e = a.condition;
          (e.callback || function () {
            return this.chartWidth <= t(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= t(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= t(e.minWidth, 0) && this.chartHeight >= t(e.minHeight, 0);
          }).call(this) && d.push(a._id);
        };
        a.prototype.setResponsive = function (a, d) {
          var e = this,
            g = this.options.responsive,
            h = this.currentResponsive,
            k = [];
          !d && g && g.rules && g.rules.forEach(function (a) {
            "undefined" === typeof a._id && (a._id = l());
            e.matchResponsiveRule(a, k);
          }, this);
          d = B.apply(void 0, k.map(function (a) {
            return x((g || {}).rules || [], function (c) {
              return c._id === a;
            });
          }).map(function (a) {
            return a && a.chartOptions;
          }));
          d.isResponsiveOptions = !0;
          k = k.toString() || void 0;
          k !== (h && h.ruleIds) && (h && this.update(h.undoOptions, a, !0), k ? (h = this.currentOptions(d), h.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: k,
            mergedOptions: d,
            undoOptions: h
          }, this.update(d, a, !0)) : this.currentResponsive = void 0);
        };
        return a;
      }();
    })(e || (e = {}));
    "";
    "";
    return e;
  });
  K(g, "masters/highcharts.src.js", [g["Core/Globals.js"], g["Core/Utilities.js"], g["Core/Defaults.js"], g["Core/Animation/Fx.js"], g["Core/Animation/AnimationUtilities.js"], g["Core/Renderer/HTML/AST.js"], g["Core/FormatUtilities.js"], g["Core/Renderer/RendererUtilities.js"], g["Core/Renderer/SVG/SVGElement.js"], g["Core/Renderer/SVG/SVGRenderer.js"], g["Core/Renderer/HTML/HTMLElement.js"], g["Core/Renderer/HTML/HTMLRenderer.js"], g["Core/Axis/Axis.js"], g["Core/Axis/DateTimeAxis.js"], g["Core/Axis/LogarithmicAxis.js"], g["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], g["Core/Axis/Tick.js"], g["Core/Tooltip.js"], g["Core/Series/Point.js"], g["Core/Pointer.js"], g["Core/MSPointer.js"], g["Core/Legend/Legend.js"], g["Core/Chart/Chart.js"], g["Core/Axis/Stacking/StackingAxis.js"], g["Core/Axis/Stacking/StackItem.js"], g["Core/Series/Series.js"], g["Core/Series/SeriesRegistry.js"], g["Series/Column/ColumnSeries.js"], g["Series/Column/ColumnDataLabel.js"], g["Series/Pie/PieSeries.js"], g["Series/Pie/PieDataLabel.js"], g["Core/Series/DataLabel.js"], g["Core/Responsive.js"], g["Core/Color/Color.js"], g["Core/Time.js"]], function (a, g, x, F, C, B, H, t, r, l, e, d, h, m, k, p, D, I, E, L, y, c, w, f, n, b, u, z, q, K, J, O, Q, T, Y) {
    a.animate = C.animate;
    a.animObject = C.animObject;
    a.getDeferredAnimation = C.getDeferredAnimation;
    a.setAnimation = C.setAnimation;
    a.stop = C.stop;
    a.timers = F.timers;
    a.AST = B;
    a.Axis = h;
    a.Chart = w;
    a.chart = w.chart;
    a.Fx = F;
    a.Legend = c;
    a.PlotLineOrBand = p;
    a.Point = E;
    a.Pointer = y.isRequired() ? y : L;
    a.Series = b;
    a.StackItem = n;
    a.SVGElement = r;
    a.SVGRenderer = l;
    a.Tick = D;
    a.Time = Y;
    a.Tooltip = I;
    a.Color = T;
    a.color = T.parse;
    d.compose(l);
    e.compose(r);
    a.defaultOptions = x.defaultOptions;
    a.getOptions = x.getOptions;
    a.time = x.defaultTime;
    a.setOptions = x.setOptions;
    a.dateFormat = H.dateFormat;
    a.format = H.format;
    a.numberFormat = H.numberFormat;
    a.addEvent = g.addEvent;
    a.arrayMax = g.arrayMax;
    a.arrayMin = g.arrayMin;
    a.attr = g.attr;
    a.clearTimeout = g.clearTimeout;
    a.correctFloat = g.correctFloat;
    a.createElement = g.createElement;
    a.css = g.css;
    a.defined = g.defined;
    a.destroyObjectProperties = g.destroyObjectProperties;
    a.discardElement = g.discardElement;
    a.distribute = t.distribute;
    a.erase = g.erase;
    a.error = g.error;
    a.extend = g.extend;
    a.extendClass = g.extendClass;
    a.find = g.find;
    a.fireEvent = g.fireEvent;
    a.getMagnitude = g.getMagnitude;
    a.getStyle = g.getStyle;
    a.inArray = g.inArray;
    a.isArray = g.isArray;
    a.isClass = g.isClass;
    a.isDOMElement = g.isDOMElement;
    a.isFunction = g.isFunction;
    a.isNumber = g.isNumber;
    a.isObject = g.isObject;
    a.isString = g.isString;
    a.keys = g.keys;
    a.merge = g.merge;
    a.normalizeTickInterval = g.normalizeTickInterval;
    a.objectEach = g.objectEach;
    a.offset = g.offset;
    a.pad = g.pad;
    a.pick = g.pick;
    a.pInt = g.pInt;
    a.relativeLength = g.relativeLength;
    a.removeEvent = g.removeEvent;
    a.seriesType = u.seriesType;
    a.splat = g.splat;
    a.stableSort = g.stableSort;
    a.syncTimeout = g.syncTimeout;
    a.timeUnits = g.timeUnits;
    a.uniqueKey = g.uniqueKey;
    a.useSerialIds = g.useSerialIds;
    a.wrap = g.wrap;
    q.compose(z);
    O.compose(b);
    m.compose(h);
    k.compose(h);
    J.compose(K);
    p.compose(h);
    Q.compose(w);
    f.compose(h, w, b);
    return a;
  });
  g["masters/highcharts.src.js"]._modules = g;
  return g["masters/highcharts.src.js"];
});

/***/ }),

/***/ 1631:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v10.3.3 (2023-01-20)

 Accessibility module

 (c) 2010-2021 Highsoft AS
 Author: Oystein Moseng

 License: www.highcharts.com/license
*/
(function (a) {
   true && module.exports ? (a["default"] = a, module.exports = a) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7684)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (A) {
    a(A);
    a.Highcharts = A;
    return a;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
})(function (a) {
  function A(a, h, l, x) {
    a.hasOwnProperty(h) || (a[h] = x.apply(null, l), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", {
      detail: {
        path: h,
        module: a[h]
      }
    })));
  }
  a = a ? a._modules : {};
  A(a, "Accessibility/Utils/HTMLUtilities.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, h) {
    function l(a) {
      if ("function" === typeof p.MouseEvent) return new p.MouseEvent(a.type, a);
      if (m.createEvent) {
        var g = m.createEvent("MouseEvent");
        if (g.initMouseEvent) return g.initMouseEvent(a.type, a.bubbles, a.cancelable, a.view || p, a.detail, a.screenX, a.screenY, a.clientX, a.clientY, a.ctrlKey, a.altKey, a.shiftKey, a.metaKey, a.button, a.relatedTarget), g;
      }
      return x(a.type);
    }
    function x(a, k, w) {
      k = k || {
        x: 0,
        y: 0
      };
      return "function" === typeof p.MouseEvent ? new p.MouseEvent(a, {
        bubbles: !0,
        cancelable: !0,
        composed: !0,
        button: 0,
        buttons: 1,
        relatedTarget: w || z,
        view: p,
        detail: "click" === a ? 1 : 0,
        screenX: k.x,
        screenY: k.y,
        clientX: k.x,
        clientY: k.y
      }) : m.createEvent && (w = m.createEvent("MouseEvent"), w.initMouseEvent) ? (w.initMouseEvent(a, !0, !0, p, "click" === a ? 1 : 0, k.x, k.y, k.x, k.y, !1, !1, !1, !1, 0, null), w) : {
        type: a
      };
    }
    var m = a.doc,
      p = a.win,
      u = h.css,
      z = p.EventTarget && new p.EventTarget() || "none";
    return {
      addClass: function (a, k) {
        a.classList ? a.classList.add(k) : 0 > a.className.indexOf(k) && (a.className += " " + k);
      },
      cloneMouseEvent: l,
      cloneTouchEvent: function (a) {
        var g = function (a) {
          for (var f = [], d = 0; d < a.length; ++d) {
            var b = a.item(d);
            b && f.push(b);
          }
          return f;
        };
        if ("function" === typeof p.TouchEvent) return g = new p.TouchEvent(a.type, {
          touches: g(a.touches),
          targetTouches: g(a.targetTouches),
          changedTouches: g(a.changedTouches),
          ctrlKey: a.ctrlKey,
          shiftKey: a.shiftKey,
          altKey: a.altKey,
          metaKey: a.metaKey,
          bubbles: a.bubbles,
          cancelable: a.cancelable,
          composed: a.composed,
          detail: a.detail,
          view: a.view
        }), a.defaultPrevented && g.preventDefault(), g;
        g = l(a);
        g.touches = a.touches;
        g.changedTouches = a.changedTouches;
        g.targetTouches = a.targetTouches;
        return g;
      },
      escapeStringForHTML: function (a) {
        return a.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
      },
      getElement: function (a) {
        return m.getElementById(a);
      },
      getFakeMouseEvent: x,
      getHeadingTagNameForElement: function (a) {
        var g = function (f) {
            f = parseInt(f.slice(1), 10);
            return "h" + Math.min(6, f + 1);
          },
          w = function (f) {
            var d;
            a: {
              for (d = f; d = d.previousSibling;) {
                var b = d.tagName || "";
                if (/H[1-6]/.test(b)) {
                  d = b;
                  break a;
                }
              }
              d = "";
            }
            if (d) return g(d);
            f = f.parentElement;
            if (!f) return "p";
            d = f.tagName;
            return /H[1-6]/.test(d) ? g(d) : w(f);
          };
        return w(a);
      },
      removeChildNodes: function (a) {
        for (; a.lastChild;) a.removeChild(a.lastChild);
      },
      removeClass: function (a, k) {
        a.classList ? a.classList.remove(k) : a.className = a.className.replace(new RegExp(k, "g"), "");
      },
      removeElement: function (a) {
        a && a.parentNode && a.parentNode.removeChild(a);
      },
      reverseChildNodes: function (a) {
        for (var g = a.childNodes.length; g--;) a.appendChild(a.childNodes[g]);
      },
      simulatedEventTarget: z,
      stripHTMLTagsFromString: function (a) {
        return "string" === typeof a ? a.replace(/<\/?[^>]+(>|$)/g, "") : a;
      },
      visuallyHideElement: function (a) {
        u(a, {
          position: "absolute",
          width: "1px",
          height: "1px",
          overflow: "hidden",
          whiteSpace: "nowrap",
          clip: "rect(1px, 1px, 1px, 1px)",
          marginTop: "-3px",
          "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
          filter: "alpha(opacity=1)",
          opacity: .01
        });
      }
    };
  });
  A(a, "Accessibility/A11yI18n.js", [a["Core/FormatUtilities.js"], a["Core/Utilities.js"]], function (a, h) {
    var l = a.format,
      x = h.getNestedProperty,
      m = h.pick,
      p;
    (function (a) {
      function z(a, d) {
        var b = a.indexOf("#each("),
          c = a.indexOf("#plural("),
          e = a.indexOf("["),
          r = a.indexOf("]");
        if (-1 < b) {
          r = a.slice(b).indexOf(")") + b;
          c = a.substring(0, b);
          e = a.substring(r + 1);
          r = a.substring(b + 6, r).split(",");
          b = Number(r[1]);
          a = "";
          if (d = x(r[0], d)) for (b = isNaN(b) ? d.length : b, b = 0 > b ? d.length + b : Math.min(b, d.length), r = 0; r < b; ++r) a += c + d[r] + e;
          return a.length ? a : "";
        }
        if (-1 < c) {
          e = a.slice(c).indexOf(")") + c;
          c = a.substring(c + 8, e).split(",");
          switch (Number(x(c[0], d))) {
            case 0:
              a = m(c[4], c[1]);
              break;
            case 1:
              a = m(c[2], c[1]);
              break;
            case 2:
              a = m(c[3], c[1]);
              break;
            default:
              a = c[1];
          }
          a ? (d = a, d = d.trim && d.trim() || d.replace(/^\s+|\s+$/g, "")) : d = "";
          return d;
        }
        return -1 < e ? (c = a.substring(0, e), e = Number(a.substring(e + 1, r)), a = void 0, d = x(c, d), !isNaN(e) && d && (0 > e ? (a = d[d.length + e], "undefined" === typeof a && (a = d[0])) : (a = d[e], "undefined" === typeof a && (a = d[d.length - 1]))), "undefined" !== typeof a ? a : "") : "{" + a + "}";
      }
      function g(a, d, b) {
        var c = function (c, b) {
            c = c.slice(b || 0);
            var e = c.indexOf("{"),
              d = c.indexOf("}");
            if (-1 < e && d > e) return {
              statement: c.substring(e + 1, d),
              begin: b + e + 1,
              end: b + d
            };
          },
          e = [],
          r = 0;
        do {
          var f = c(a, r);
          var g = a.substring(r, f && f.begin - 1);
          g.length && e.push({
            value: g,
            type: "constant"
          });
          f && e.push({
            value: f.statement,
            type: "statement"
          });
          r = f ? f.end + 1 : r + 1;
        } while (f);
        e.forEach(function (c) {
          "statement" === c.type && (c.value = z(c.value, d));
        });
        return l(e.reduce(function (c, b) {
          return c + b.value;
        }, ""), d, b);
      }
      function k(a, d) {
        a = a.split(".");
        for (var b = this.options.lang, c = 0; c < a.length; ++c) b = b && b[a[c]];
        return "string" === typeof b ? g(b, d, this) : "";
      }
      var w = [];
      a.compose = function (a) {
        -1 === w.indexOf(a) && (w.push(a), a.prototype.langFormat = k);
        return a;
      };
      a.i18nFormat = g;
    })(p || (p = {}));
    return p;
  });
  A(a, "Accessibility/Utils/ChartUtilities.js", [a["Core/Globals.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Core/Utilities.js"]], function (a, h, l) {
    function x(c, e) {
      var d = e.type,
        a = c.hcEvents;
      k.createEvent && (c.dispatchEvent || c.fireEvent) ? c.dispatchEvent ? c.dispatchEvent(e) : c.fireEvent(d, e) : a && a[d] ? b(c, d, e) : c.element && x(c.element, e);
    }
    function m(c) {
      var b = c.chart,
        d = {},
        a = "Seconds";
      d.Seconds = ((c.dataMax || c.max || 0) - (c.dataMin || c.min || 0)) / 1E3;
      d.Minutes = d.Seconds / 60;
      d.Hours = d.Minutes / 60;
      d.Days = d.Hours / 24;
      ["Minutes", "Hours", "Days"].forEach(function (c) {
        2 < d[c] && (a = c);
      });
      var f = d[a].toFixed("Seconds" !== a && "Minutes" !== a ? 1 : 0);
      return b.langFormat("accessibility.axis.timeRange" + a, {
        chart: b,
        axis: c,
        range: f.replace(".0", "")
      });
    }
    function p(c) {
      var b = c.chart,
        d = b.options,
        a = d && d.accessibility && d.accessibility.screenReaderSection.axisRangeDateFormat || "",
        f = {
          min: c.dataMin || c.min || 0,
          max: c.dataMax || c.max || 0
        };
      d = function (e) {
        return c.dateTime ? b.time.dateFormat(a, f[e]) : f[e].toString();
      };
      return b.langFormat("accessibility.axis.rangeFromTo", {
        chart: b,
        axis: c,
        rangeFrom: d("min"),
        rangeTo: d("max")
      });
    }
    function u(c) {
      if (c.points && c.points.length) return (c = d(c.points, function (c) {
        return !!c.graphic;
      })) && c.graphic && c.graphic.element;
    }
    function z(c) {
      var b = u(c);
      return b && b.parentNode || c.graph && c.graph.element || c.group && c.group.element;
    }
    function g(c, b) {
      b.setAttribute("aria-hidden", !1);
      b !== c.renderTo && b.parentNode && b.parentNode !== k.body && (Array.prototype.forEach.call(b.parentNode.childNodes, function (c) {
        c.hasAttribute("aria-hidden") || c.setAttribute("aria-hidden", !0);
      }), g(c, b.parentNode));
    }
    var k = a.doc,
      w = h.stripHTMLTagsFromString,
      f = l.defined,
      d = l.find,
      b = l.fireEvent;
    return {
      fireEventOnWrappedOrUnwrappedElement: x,
      getChartTitle: function (c) {
        return w(c.options.title.text || c.langFormat("accessibility.defaultChartTitle", {
          chart: c
        }));
      },
      getAxisDescription: function (c) {
        return c && (c.userOptions && c.userOptions.accessibility && c.userOptions.accessibility.description || c.axisTitle && c.axisTitle.textStr || c.options.id || c.categories && "categories" || c.dateTime && "Time" || "values");
      },
      getAxisRangeDescription: function (c) {
        var b = c.options || {};
        return b.accessibility && "undefined" !== typeof b.accessibility.rangeDescription ? b.accessibility.rangeDescription : c.categories ? (b = c.chart, c = c.dataMax && c.dataMin ? b.langFormat("accessibility.axis.rangeCategories", {
          chart: b,
          axis: c,
          numCategories: c.dataMax - c.dataMin + 1
        }) : "", c) : !c.dateTime || 0 !== c.min && 0 !== c.dataMin ? p(c) : m(c);
      },
      getPointFromXY: function (c, b, a) {
        for (var e = c.length, r; e--;) if (r = d(c[e].points || [], function (c) {
          return c.x === b && c.y === a;
        })) return r;
      },
      getSeriesFirstPointElement: u,
      getSeriesFromName: function (c, b) {
        return b ? (c.series || []).filter(function (c) {
          return c.name === b;
        }) : c.series;
      },
      getSeriesA11yElement: z,
      unhideChartElementFromAT: g,
      hideSeriesFromAT: function (c) {
        (c = z(c)) && c.setAttribute("aria-hidden", !0);
      },
      scrollToPoint: function (c) {
        var e = c.series.xAxis,
          d = c.series.yAxis,
          a = e && e.scrollbar ? e : d;
        if ((e = a && a.scrollbar) && f(e.to) && f(e.from)) {
          d = e.to - e.from;
          if (f(a.dataMin) && f(a.dataMax)) {
            var g = a.toPixels(a.dataMin),
              k = a.toPixels(a.dataMax);
            c = (a.toPixels(c["xAxis" === a.coll ? "x" : "y"] || 0) - g) / (k - g);
          } else c = 0;
          e.updatePosition(c - d / 2, c + d / 2);
          b(e, "changed", {
            from: e.from,
            to: e.to,
            trigger: "scrollbar",
            DOMEvent: null
          });
        }
      }
    };
  });
  A(a, "Accessibility/Utils/DOMElementProvider.js", [a["Core/Globals.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h) {
    var l = a.doc,
      x = h.removeElement;
    return function () {
      function a() {
        this.elements = [];
      }
      a.prototype.createElement = function () {
        var a = l.createElement.apply(l, arguments);
        this.elements.push(a);
        return a;
      };
      a.prototype.destroyCreatedElements = function () {
        this.elements.forEach(function (a) {
          x(a);
        });
        this.elements = [];
      };
      return a;
    }();
  });
  A(a, "Accessibility/Utils/EventProvider.js", [a["Core/Globals.js"], a["Core/Utilities.js"]], function (a, h) {
    var l = h.addEvent;
    return function () {
      function h() {
        this.eventRemovers = [];
      }
      h.prototype.addEvent = function () {
        var h = l.apply(a, arguments);
        this.eventRemovers.push(h);
        return h;
      };
      h.prototype.removeAddedEvents = function () {
        this.eventRemovers.forEach(function (a) {
          return a();
        });
        this.eventRemovers = [];
      };
      return h;
    }();
  });
  A(a, "Accessibility/AccessibilityComponent.js", [a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/DOMElementProvider.js"], a["Accessibility/Utils/EventProvider.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Core/Utilities.js"]], function (a, h, l, x, m) {
    var p = a.fireEventOnWrappedOrUnwrappedElement,
      u = x.getFakeMouseEvent;
    a = m.extend;
    x = function () {
      function a() {
        this.proxyProvider = this.keyCodes = this.eventProvider = this.domElementProvider = this.chart = void 0;
      }
      a.prototype.initBase = function (a, k) {
        this.chart = a;
        this.eventProvider = new l();
        this.domElementProvider = new h();
        this.proxyProvider = k;
        this.keyCodes = {
          left: 37,
          right: 39,
          up: 38,
          down: 40,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          pageUp: 33,
          pageDown: 34,
          end: 35,
          home: 36
        };
      };
      a.prototype.addEvent = function (a, k, w, f) {
        return this.eventProvider.addEvent(a, k, w, f);
      };
      a.prototype.createElement = function (a, k) {
        return this.domElementProvider.createElement(a, k);
      };
      a.prototype.fakeClickEvent = function (a) {
        var g = u("click");
        p(a, g);
      };
      a.prototype.destroyBase = function () {
        this.domElementProvider.destroyCreatedElements();
        this.eventProvider.removeAddedEvents();
      };
      return a;
    }();
    a(x.prototype, {
      init: function () {},
      getKeyboardNavigation: function () {},
      onChartUpdate: function () {},
      onChartRender: function () {},
      destroy: function () {}
    });
    return x;
  });
  A(a, "Accessibility/KeyboardNavigationHandler.js", [a["Core/Utilities.js"]], function (a) {
    var h = a.find;
    a = function () {
      function a(a, h) {
        this.chart = a;
        this.keyCodeMap = h.keyCodeMap || [];
        this.validate = h.validate;
        this.init = h.init;
        this.terminate = h.terminate;
        this.response = {
          success: 1,
          prev: 2,
          next: 3,
          noHandler: 4,
          fail: 5
        };
      }
      a.prototype.run = function (a) {
        var l = a.which || a.keyCode,
          p = this.response.noHandler,
          u = h(this.keyCodeMap, function (a) {
            return -1 < a[0].indexOf(l);
          });
        u ? p = u[1].call(this, l, a) : 9 === l && (p = this.response[a.shiftKey ? "prev" : "next"]);
        return p;
      };
      return a;
    }();
    "";
    return a;
  });
  A(a, "Accessibility/Components/ContainerComponent.js", [a["Accessibility/AccessibilityComponent.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Core/Globals.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h, l, x, m) {
    var p = this && this.__extends || function () {
        var a = function (f, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (b, c) {
            b.__proto__ = c;
          } || function (b, c) {
            for (var a in c) c.hasOwnProperty(a) && (b[a] = c[a]);
          };
          return a(f, d);
        };
        return function (f, d) {
          function b() {
            this.constructor = f;
          }
          a(f, d);
          f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
        };
      }(),
      u = l.unhideChartElementFromAT,
      z = l.getChartTitle,
      g = x.doc,
      k = m.stripHTMLTagsFromString;
    return function (a) {
      function f() {
        return null !== a && a.apply(this, arguments) || this;
      }
      p(f, a);
      f.prototype.onChartUpdate = function () {
        this.handleSVGTitleElement();
        this.setSVGContainerLabel();
        this.setGraphicContainerAttrs();
        this.setRenderToAttrs();
        this.makeCreditsAccessible();
      };
      f.prototype.handleSVGTitleElement = function () {
        var a = this.chart,
          b = "highcharts-title-" + a.index,
          c = k(a.langFormat("accessibility.svgContainerTitle", {
            chartTitle: z(a)
          }));
        if (c.length) {
          var e = this.svgTitleElement = this.svgTitleElement || g.createElementNS("http://www.w3.org/2000/svg", "title");
          e.textContent = c;
          e.id = b;
          a.renderTo.insertBefore(e, a.renderTo.firstChild);
        }
      };
      f.prototype.setSVGContainerLabel = function () {
        var a = this.chart,
          b = a.langFormat("accessibility.svgContainerLabel", {
            chartTitle: z(a)
          });
        a.renderer.box && b.length && a.renderer.box.setAttribute("aria-label", b);
      };
      f.prototype.setGraphicContainerAttrs = function () {
        var a = this.chart,
          b = a.langFormat("accessibility.graphicContainerLabel", {
            chartTitle: z(a)
          });
        b.length && a.container.setAttribute("aria-label", b);
      };
      f.prototype.setRenderToAttrs = function () {
        var a = this.chart,
          b = "disabled" !== a.options.accessibility.landmarkVerbosity,
          c = a.langFormat("accessibility.chartContainerLabel", {
            title: z(a),
            chart: a
          });
        c && (a.renderTo.setAttribute("role", b ? "region" : "group"), a.renderTo.setAttribute("aria-label", c));
      };
      f.prototype.makeCreditsAccessible = function () {
        var a = this.chart,
          b = a.credits;
        b && (b.textStr && b.element.setAttribute("aria-label", a.langFormat("accessibility.credits", {
          creditsStr: k(b.textStr)
        })), u(a, b.element));
      };
      f.prototype.getKeyboardNavigation = function () {
        var a = this.chart;
        return new h(a, {
          keyCodeMap: [],
          validate: function () {
            return !0;
          },
          init: function () {
            var b = a.accessibility;
            b && b.keyboardNavigation.tabindexContainer.focus();
          }
        });
      };
      f.prototype.destroy = function () {
        this.chart.renderTo.setAttribute("aria-hidden", !0);
      };
      return f;
    }(a);
  });
  A(a, "Accessibility/FocusBorder.js", [a["Core/Renderer/SVG/SVGLabel.js"], a["Core/Utilities.js"]], function (a, h) {
    var l = h.addEvent,
      u = h.pick,
      m;
    (function (h) {
      function p() {
        var c = this.focusElement,
          b = this.options.accessibility.keyboardNavigation.focusBorder;
        c && (c.removeFocusBorder(), b.enabled && c.addFocusBorder(b.margin, {
          stroke: b.style.color,
          strokeWidth: b.style.lineWidth,
          r: b.style.borderRadius
        }));
      }
      function z(c, b) {
        var a = this.options.accessibility.keyboardNavigation.focusBorder;
        (b = b || c.element) && b.focus && (b.hcEvents && b.hcEvents.focusin || l(b, "focusin", function () {}), b.focus(), a.hideBrowserFocusOutline && (b.style.outline = "none"));
        this.focusElement && this.focusElement.removeFocusBorder();
        this.focusElement = c;
        this.renderFocusBorder();
      }
      function g(b) {
        if (!b.focusBorderDestroyHook) {
          var c = b.destroy;
          b.destroy = function () {
            b.focusBorder && b.focusBorder.destroy && b.focusBorder.destroy();
            return c.apply(b, arguments);
          };
          b.focusBorderDestroyHook = c;
        }
      }
      function k(b, c) {
        this.focusBorder && this.removeFocusBorder();
        var e = this.getBBox(),
          d = u(b, 3),
          r = this.parentGroup,
          f = this.scaleX || r && r.scaleX,
          k = this.scaleY || r && r.scaleY;
        f = (f ? !k : k) ? Math.abs(f || k || 1) : (Math.abs(f || 1) + Math.abs(k || 1)) / 2;
        e.x += this.translateX ? this.translateX : 0;
        e.y += this.translateY ? this.translateY : 0;
        k = e.x - d;
        var h = e.y - d,
          v = e.width + 2 * d,
          n = e.height + 2 * d,
          q = this instanceof a;
        if ("text" === this.element.nodeName || q) {
          var D = !!this.rotation;
          if (q) var y = {
            x: D ? 1 : 0,
            y: 0
          };else {
            var F = y = 0;
            "middle" === this.attr("text-anchor") ? y = F = .5 : this.rotation ? y = .25 : F = .75;
            y = {
              x: y,
              y: F
            };
          }
          F = +this.attr("x");
          var t = +this.attr("y");
          isNaN(F) || (k = F - e.width * y.x - d);
          isNaN(t) || (h = t - e.height * y.y - d);
          q && D && (q = v, v = n, n = q, isNaN(F) || (k = F - e.height * y.x - d), isNaN(t) || (h = t - e.width * y.y - d));
        }
        this.focusBorder = this.renderer.rect(k, h, v, n, parseInt((c && c.r || 0).toString(), 10) / f).addClass("highcharts-focus-border").attr({
          zIndex: 99
        }).add(r);
        this.renderer.styledMode || this.focusBorder.attr({
          stroke: c && c.stroke,
          "stroke-width": (c && c.strokeWidth || 0) / f
        });
        w(this, b, c);
        g(this);
      }
      function w(b) {
        for (var a = [], e = 1; e < arguments.length; e++) a[e - 1] = arguments[e];
        b.focusBorderUpdateHooks || (b.focusBorderUpdateHooks = {}, c.forEach(function (c) {
          c += "Setter";
          var e = b[c] || b._defaultSetter;
          b.focusBorderUpdateHooks[c] = e;
          b[c] = function () {
            var c = e.apply(b, arguments);
            b.addFocusBorder.apply(b, a);
            return c;
          };
        }));
      }
      function f() {
        d(this);
        this.focusBorderDestroyHook && (this.destroy = this.focusBorderDestroyHook, delete this.focusBorderDestroyHook);
        this.focusBorder && (this.focusBorder.destroy(), delete this.focusBorder);
      }
      function d(b) {
        b.focusBorderUpdateHooks && (Object.keys(b.focusBorderUpdateHooks).forEach(function (c) {
          var a = b.focusBorderUpdateHooks[c];
          a === b._defaultSetter ? delete b[c] : b[c] = a;
        }), delete b.focusBorderUpdateHooks);
      }
      var b = [],
        c = "x y transform width height r d stroke-width".split(" ");
      h.compose = function (c, a) {
        -1 === b.indexOf(c) && (b.push(c), c = c.prototype, c.renderFocusBorder = p, c.setFocusToElement = z);
        -1 === b.indexOf(a) && (b.push(a), a = a.prototype, a.addFocusBorder = k, a.removeFocusBorder = f);
      };
    })(m || (m = {}));
    return m;
  });
  A(a, "Accessibility/Utils/Announcer.js", [a["Core/Renderer/HTML/AST.js"], a["Accessibility/Utils/DOMElementProvider.js"], a["Core/Globals.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Core/Utilities.js"]], function (a, h, l, x, m) {
    var p = l.doc,
      u = x.addClass,
      z = x.visuallyHideElement,
      g = m.attr;
    return function () {
      function k(a, f) {
        this.chart = a;
        this.domElementProvider = new h();
        this.announceRegion = this.addAnnounceRegion(f);
      }
      k.prototype.destroy = function () {
        this.domElementProvider.destroyCreatedElements();
      };
      k.prototype.announce = function (g) {
        var f = this;
        a.setElementHTML(this.announceRegion, g);
        this.clearAnnouncementRegionTimer && clearTimeout(this.clearAnnouncementRegionTimer);
        this.clearAnnouncementRegionTimer = setTimeout(function () {
          f.announceRegion.innerHTML = a.emptyHTML;
          delete f.clearAnnouncementRegionTimer;
        }, 1E3);
      };
      k.prototype.addAnnounceRegion = function (a) {
        var f = this.chart.announcerContainer || this.createAnnouncerContainer(),
          d = this.domElementProvider.createElement("div");
        g(d, {
          "aria-hidden": !1,
          "aria-live": a
        });
        this.chart.styledMode ? u(d, "highcharts-visually-hidden") : z(d);
        f.appendChild(d);
        return d;
      };
      k.prototype.createAnnouncerContainer = function () {
        var a = this.chart,
          f = p.createElement("div");
        g(f, {
          "aria-hidden": !1,
          "class": "highcharts-announcer-container"
        });
        f.style.position = "relative";
        a.renderTo.insertBefore(f, a.renderTo.firstChild);
        return a.announcerContainer = f;
      };
      return k;
    }();
  });
  A(a, "Accessibility/Components/AnnotationsA11y.js", [a["Accessibility/Utils/HTMLUtilities.js"]], function (a) {
    function h(a) {
      return (a.annotations || []).reduce(function (a, k) {
        k.options && !1 !== k.options.visible && (a = a.concat(k.labels));
        return a;
      }, []);
    }
    function l(a) {
      return a.options && a.options.accessibility && a.options.accessibility.description || a.graphic && a.graphic.text && a.graphic.text.textStr || "";
    }
    function u(a) {
      var g = a.options && a.options.accessibility && a.options.accessibility.description;
      if (g) return g;
      g = a.chart;
      var k = l(a),
        h = a.points.filter(function (b) {
          return !!b.graphic;
        }).map(function (b) {
          var c = b.accessibility && b.accessibility.valueDescription || b.graphic && b.graphic.element && b.graphic.element.getAttribute("aria-label") || "";
          b = b && b.series.name || "";
          return (b ? b + ", " : "") + "data point " + c;
        }).filter(function (b) {
          return !!b;
        }),
        f = h.length,
        d = "accessibility.screenReaderSection.annotations.description" + (1 < f ? "MultiplePoints" : f ? "SinglePoint" : "NoPoints");
      a = {
        annotationText: k,
        annotation: a,
        numPoints: f,
        annotationPoint: h[0],
        additionalAnnotationPoints: h.slice(1)
      };
      return g.langFormat(d, a);
    }
    function m(a) {
      return h(a).map(function (a) {
        return (a = p(K(u(a)))) ? "<li>".concat(a, "</li>") : "";
      });
    }
    var p = a.escapeStringForHTML,
      K = a.stripHTMLTagsFromString;
    return {
      getAnnotationsInfoHTML: function (a) {
        var g = a.annotations;
        if (!g || !g.length) return "";
        a = m(a);
        return '<ul style="list-style-type: none">'.concat(a.join(" "), "</ul>");
      },
      getAnnotationLabelDescription: u,
      getAnnotationListItems: m,
      getPointAnnotationTexts: function (a) {
        var g = h(a.series.chart).filter(function (k) {
          return -1 < k.points.indexOf(a);
        });
        return g.length ? g.map(function (a) {
          return "".concat(l(a));
        }) : [];
      }
    };
  });
  A(a, "Accessibility/Components/InfoRegionsComponent.js", [a["Accessibility/A11yI18n.js"], a["Accessibility/AccessibilityComponent.js"], a["Accessibility/Utils/Announcer.js"], a["Accessibility/Components/AnnotationsA11y.js"], a["Core/Renderer/HTML/AST.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Core/FormatUtilities.js"], a["Core/Globals.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Core/Utilities.js"]], function (a, h, l, x, m, p, K, z, g, k) {
    function w(a, b) {
      var c = b[0],
        e = a.series && a.series[0] || {};
      e = {
        numSeries: a.series.length,
        numPoints: e.points && e.points.length,
        chart: a,
        mapTitle: a.mapView && a.mapView.geoMap && a.mapView.geoMap.title
      };
      if (!c) return a.langFormat("accessibility.chartTypes.emptyChart", e);
      if ("map" === c) return e.mapTitle ? a.langFormat("accessibility.chartTypes.mapTypeDescription", e) : a.langFormat("accessibility.chartTypes.unknownMap", e);
      if (1 < a.types.length) return a.langFormat("accessibility.chartTypes.combinationChart", e);
      b = b[0];
      c = a.langFormat("accessibility.seriesTypeDescriptions." + b, e);
      var d = a.series && 2 > a.series.length ? "Single" : "Multiple";
      return (a.langFormat("accessibility.chartTypes." + b + d, e) || a.langFormat("accessibility.chartTypes.default" + d, e)) + (c ? " " + c : "");
    }
    var f = this && this.__extends || function () {
        var a = function (b, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(b, c);
        };
        return function (b, c) {
          function e() {
            this.constructor = b;
          }
          a(b, c);
          b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
        };
      }(),
      d = x.getAnnotationsInfoHTML,
      b = p.getAxisDescription,
      c = p.getAxisRangeDescription,
      e = p.getChartTitle,
      r = p.unhideChartElementFromAT,
      E = K.format,
      I = z.doc,
      u = g.addClass,
      B = g.getElement,
      H = g.getHeadingTagNameForElement,
      C = g.stripHTMLTagsFromString,
      v = g.visuallyHideElement,
      n = k.attr,
      q = k.pick;
    return function (D) {
      function y() {
        var a = null !== D && D.apply(this, arguments) || this;
        a.announcer = void 0;
        a.screenReaderSections = {};
        return a;
      }
      f(y, D);
      y.prototype.init = function () {
        var a = this.chart,
          b = this;
        this.initRegionsDefinitions();
        this.addEvent(a, "aftergetTableAST", function (a) {
          b.onDataTableCreated(a);
        });
        this.addEvent(a, "afterViewData", function (a) {
          a.wasHidden && (b.dataTableDiv = a.element, setTimeout(function () {
            b.focusDataTable();
          }, 300));
        });
        this.announcer = new l(a, "assertive");
      };
      y.prototype.initRegionsDefinitions = function () {
        var a = this;
        this.screenReaderSections = {
          before: {
            element: null,
            buildContent: function (b) {
              var c = b.options.accessibility.screenReaderSection.beforeChartFormatter;
              return c ? c(b) : a.defaultBeforeChartFormatter(b);
            },
            insertIntoDOM: function (a, b) {
              b.renderTo.insertBefore(a, b.renderTo.firstChild);
            },
            afterInserted: function () {
              "undefined" !== typeof a.sonifyButtonId && a.initSonifyButton(a.sonifyButtonId);
              "undefined" !== typeof a.dataTableButtonId && a.initDataTableButton(a.dataTableButtonId);
            }
          },
          after: {
            element: null,
            buildContent: function (b) {
              var c = b.options.accessibility.screenReaderSection.afterChartFormatter;
              return c ? c(b) : a.defaultAfterChartFormatter();
            },
            insertIntoDOM: function (a, b) {
              b.renderTo.insertBefore(a, b.container.nextSibling);
            },
            afterInserted: function () {
              a.chart.accessibility && a.chart.accessibility.keyboardNavigation.updateExitAnchor();
            }
          }
        };
      };
      y.prototype.onChartRender = function () {
        var a = this;
        this.linkedDescriptionElement = this.getLinkedDescriptionElement();
        this.setLinkedDescriptionAttrs();
        Object.keys(this.screenReaderSections).forEach(function (b) {
          a.updateScreenReaderSection(b);
        });
      };
      y.prototype.getLinkedDescriptionElement = function () {
        var a = this.chart.options.accessibility.linkedDescription;
        if (a) {
          if ("string" !== typeof a) return a;
          a = E(a, this.chart);
          a = I.querySelectorAll(a);
          if (1 === a.length) return a[0];
        }
      };
      y.prototype.setLinkedDescriptionAttrs = function () {
        var a = this.linkedDescriptionElement;
        a && (a.setAttribute("aria-hidden", "true"), u(a, "highcharts-linked-description"));
      };
      y.prototype.updateScreenReaderSection = function (a) {
        var b = this.chart,
          c = this.screenReaderSections[a],
          e = c.buildContent(b),
          d = c.element = c.element || this.createElement("div"),
          n = d.firstChild || this.createElement("div");
        e ? (this.setScreenReaderSectionAttribs(d, a), m.setElementHTML(n, e), d.appendChild(n), c.insertIntoDOM(d, b), b.styledMode ? u(n, "highcharts-visually-hidden") : v(n), r(b, n), c.afterInserted && c.afterInserted()) : (d.parentNode && d.parentNode.removeChild(d), c.element = null);
      };
      y.prototype.setScreenReaderSectionAttribs = function (a, b) {
        var c = this.chart,
          d = c.langFormat("accessibility.screenReaderSection." + b + "RegionLabel", {
            chart: c,
            chartTitle: e(c)
          });
        b = "highcharts-screen-reader-region-".concat(b, "-").concat(c.index);
        n(a, {
          id: b,
          "aria-label": d || void 0
        });
        a.style.position = "relative";
        d && a.setAttribute("role", "all" === c.options.accessibility.landmarkVerbosity ? "region" : "group");
      };
      y.prototype.defaultBeforeChartFormatter = function () {
        var b = this.chart,
          c = b.options.accessibility.screenReaderSection.beforeChartFormat;
        if (!c) return "";
        var n = this.getAxesDescription(),
          q = b.sonify && b.options.sonification && b.options.sonification.enabled,
          y = "highcharts-a11y-sonify-data-btn-" + b.index,
          f = "hc-linkto-highcharts-data-table-" + b.index,
          r = d(b),
          v = b.langFormat("accessibility.screenReaderSection.annotations.heading", {
            chart: b
          });
        n = {
          headingTagName: H(b.renderTo),
          chartTitle: e(b),
          typeDescription: this.getTypeDescriptionText(),
          chartSubtitle: this.getSubtitleText(),
          chartLongdesc: this.getLongdescText(),
          xAxisDescription: n.xAxis,
          yAxisDescription: n.yAxis,
          playAsSoundButton: q ? this.getSonifyButtonText(y) : "",
          viewTableButton: b.getCSV ? this.getDataTableButtonText(f) : "",
          annotationsTitle: r ? v : "",
          annotationsList: r
        };
        b = a.i18nFormat(c, n, b);
        this.dataTableButtonId = f;
        this.sonifyButtonId = y;
        return b.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
      };
      y.prototype.defaultAfterChartFormatter = function () {
        var b = this.chart,
          c = b.options.accessibility.screenReaderSection.afterChartFormat;
        if (!c) return "";
        var e = {
          endOfChartMarker: this.getEndOfChartMarkerText()
        };
        return a.i18nFormat(c, e, b).replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
      };
      y.prototype.getLinkedDescription = function () {
        var a = this.linkedDescriptionElement;
        return C(a && a.innerHTML || "");
      };
      y.prototype.getLongdescText = function () {
        var a = this.chart.options,
          b = a.caption;
        b = b && b.text;
        var c = this.getLinkedDescription();
        return a.accessibility.description || c || b || "";
      };
      y.prototype.getTypeDescriptionText = function () {
        var a = this.chart;
        return a.types ? a.options.accessibility.typeDescription || w(a, a.types) : "";
      };
      y.prototype.getDataTableButtonText = function (a) {
        var b = this.chart;
        b = b.langFormat("accessibility.table.viewAsDataTableButtonText", {
          chart: b,
          chartTitle: e(b)
        });
        return '<button id="' + a + '">' + b + "</button>";
      };
      y.prototype.getSonifyButtonText = function (a) {
        var b = this.chart;
        if (b.options.sonification && !1 === b.options.sonification.enabled) return "";
        b = b.langFormat("accessibility.sonification.playAsSoundButtonText", {
          chart: b,
          chartTitle: e(b)
        });
        return '<button id="' + a + '">' + b + "</button>";
      };
      y.prototype.getSubtitleText = function () {
        var a = this.chart.options.subtitle;
        return C(a && a.text || "");
      };
      y.prototype.getEndOfChartMarkerText = function () {
        var a = this.chart,
          b = a.langFormat("accessibility.screenReaderSection.endOfChartMarker", {
            chart: a
          });
        return '<div id="highcharts-end-of-chart-marker-' + a.index + '">' + b + "</div>";
      };
      y.prototype.onDataTableCreated = function (a) {
        var b = this.chart;
        if (b.options.accessibility.enabled) {
          this.viewDataTableButton && this.viewDataTableButton.setAttribute("aria-expanded", "true");
          var c = a.tree.attributes || {};
          c.tabindex = -1;
          c.summary = b.langFormat("accessibility.table.tableSummary", {
            chart: b
          });
          a.tree.attributes = c;
        }
      };
      y.prototype.focusDataTable = function () {
        var a = this.dataTableDiv;
        (a = a && a.getElementsByTagName("table")[0]) && a.focus && a.focus();
      };
      y.prototype.initSonifyButton = function (a) {
        var b = this,
          c = this.sonifyButton = B(a),
          e = this.chart,
          d = function (a) {
            c && (c.setAttribute("aria-hidden", "true"), c.setAttribute("aria-label", ""));
            a.preventDefault();
            a.stopPropagation();
            a = e.langFormat("accessibility.sonification.playAsSoundClickAnnouncement", {
              chart: e
            });
            b.announcer.announce(a);
            setTimeout(function () {
              c && (c.removeAttribute("aria-hidden"), c.removeAttribute("aria-label"));
              e.sonify && e.sonify();
            }, 1E3);
          };
        c && e && (c.setAttribute("tabindex", -1), c.onclick = function (a) {
          (e.options.accessibility && e.options.accessibility.screenReaderSection.onPlayAsSoundClick || d).call(this, a, e);
        });
      };
      y.prototype.initDataTableButton = function (a) {
        var b = this.viewDataTableButton = B(a),
          c = this.chart;
        a = a.replace("hc-linkto-", "");
        b && (n(b, {
          tabindex: -1,
          "aria-expanded": !!B(a)
        }), b.onclick = c.options.accessibility.screenReaderSection.onViewDataTableClick || function () {
          c.viewData();
        });
      };
      y.prototype.getAxesDescription = function () {
        var a = this.chart,
          b = function (b, c) {
            b = a[b];
            return 1 < b.length || b[0] && q(b[0].options.accessibility && b[0].options.accessibility.enabled, c);
          },
          c = !!a.types && 0 > a.types.indexOf("map") && 0 > a.types.indexOf("treemap") && 0 > a.types.indexOf("tilemap"),
          e = !!a.hasCartesianSeries,
          d = b("xAxis", !a.angular && e && c);
        b = b("yAxis", e && c);
        c = {};
        d && (c.xAxis = this.getAxisDescriptionText("xAxis"));
        b && (c.yAxis = this.getAxisDescriptionText("yAxis"));
        return c;
      };
      y.prototype.getAxisDescriptionText = function (a) {
        var e = this.chart,
          d = e[a];
        return e.langFormat("accessibility.axis." + a + "Description" + (1 < d.length ? "Plural" : "Singular"), {
          chart: e,
          names: d.map(function (a) {
            return b(a);
          }),
          ranges: d.map(function (a) {
            return c(a);
          }),
          numAxes: d.length
        });
      };
      y.prototype.destroy = function () {
        this.announcer && this.announcer.destroy();
      };
      return y;
    }(h);
  });
  A(a, "Accessibility/Components/MenuComponent.js", [a["Core/Chart/Chart.js"], a["Core/Utilities.js"], a["Accessibility/AccessibilityComponent.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h, l, x, m, p) {
    var u = this && this.__extends || function () {
        var a = function (d, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(d, b);
        };
        return function (d, b) {
          function c() {
            this.constructor = d;
          }
          a(d, b);
          d.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());
        };
      }(),
      z = h.attr,
      g = m.getChartTitle,
      k = m.unhideChartElementFromAT,
      w = p.getFakeMouseEvent;
    h = function (a) {
      function d() {
        return null !== a && a.apply(this, arguments) || this;
      }
      u(d, a);
      d.prototype.init = function () {
        var a = this.chart,
          c = this;
        this.addEvent(a, "exportMenuShown", function () {
          c.onMenuShown();
        });
        this.addEvent(a, "exportMenuHidden", function () {
          c.onMenuHidden();
        });
        this.createProxyGroup();
      };
      d.prototype.onMenuHidden = function () {
        var a = this.chart.exportContextMenu;
        a && a.setAttribute("aria-hidden", "true");
        this.setExportButtonExpandedState("false");
      };
      d.prototype.onMenuShown = function () {
        var a = this.chart,
          c = a.exportContextMenu;
        c && (this.addAccessibleContextMenuAttribs(), k(a, c));
        this.setExportButtonExpandedState("true");
      };
      d.prototype.setExportButtonExpandedState = function (a) {
        this.exportButtonProxy && this.exportButtonProxy.buttonElement.setAttribute("aria-expanded", a);
      };
      d.prototype.onChartRender = function () {
        var a = this.chart,
          c = a.focusElement,
          e = a.accessibility;
        this.proxyProvider.clearGroup("chartMenu");
        this.proxyMenuButton();
        this.exportButtonProxy && c && c === a.exportingGroup && (c.focusBorder ? a.setFocusToElement(c, this.exportButtonProxy.buttonElement) : e && e.keyboardNavigation.tabindexContainer.focus());
      };
      d.prototype.proxyMenuButton = function () {
        var a = this.chart,
          c = this.proxyProvider,
          e = a.exportSVGElements && a.exportSVGElements[0],
          d = a.options.exporting,
          f = a.exportSVGElements && a.exportSVGElements[0];
        d && !1 !== d.enabled && d.accessibility && d.accessibility.enabled && f && f.element && e && (this.exportButtonProxy = c.addProxyElement("chartMenu", {
          click: e
        }, {
          "aria-label": a.langFormat("accessibility.exporting.menuButtonLabel", {
            chart: a,
            chartTitle: g(a)
          }),
          "aria-expanded": !1,
          title: a.options.lang.contextButtonTitle || null
        }));
      };
      d.prototype.createProxyGroup = function () {
        this.chart && this.proxyProvider && this.proxyProvider.addGroup("chartMenu", "div");
      };
      d.prototype.addAccessibleContextMenuAttribs = function () {
        var a = this.chart,
          c = a.exportDivElements;
        c && c.length && (c.forEach(function (a) {
          a && ("LI" !== a.tagName || a.children && a.children.length ? a.setAttribute("aria-hidden", "true") : a.setAttribute("tabindex", -1));
        }), (c = c[0] && c[0].parentNode) && z(c, {
          "aria-hidden": void 0,
          "aria-label": a.langFormat("accessibility.exporting.chartMenuLabel", {
            chart: a
          }),
          role: "list"
        }));
      };
      d.prototype.getKeyboardNavigation = function () {
        var a = this.keyCodes,
          c = this.chart,
          e = this;
        return new x(c, {
          keyCodeMap: [[[a.left, a.up], function () {
            return e.onKbdPrevious(this);
          }], [[a.right, a.down], function () {
            return e.onKbdNext(this);
          }], [[a.enter, a.space], function () {
            return e.onKbdClick(this);
          }]],
          validate: function () {
            return !!c.exporting && !1 !== c.options.exporting.enabled && !1 !== c.options.exporting.accessibility.enabled;
          },
          init: function () {
            var a = e.exportButtonProxy,
              b = e.chart.exportingGroup;
            a && b && c.setFocusToElement(b, a.buttonElement);
          },
          terminate: function () {
            c.hideExportMenu();
          }
        });
      };
      d.prototype.onKbdPrevious = function (a) {
        var b = this.chart,
          e = b.options.accessibility;
        a = a.response;
        for (var d = b.highlightedExportItemIx || 0; d--;) if (b.highlightExportItem(d)) return a.success;
        return e.keyboardNavigation.wrapAround ? (b.highlightLastExportItem(), a.success) : a.prev;
      };
      d.prototype.onKbdNext = function (a) {
        var b = this.chart,
          e = b.options.accessibility;
        a = a.response;
        for (var d = (b.highlightedExportItemIx || 0) + 1; d < b.exportDivElements.length; ++d) if (b.highlightExportItem(d)) return a.success;
        return e.keyboardNavigation.wrapAround ? (b.highlightExportItem(0), a.success) : a.next;
      };
      d.prototype.onKbdClick = function (a) {
        var b = this.chart,
          e = b.exportDivElements[b.highlightedExportItemIx],
          d = (b.exportSVGElements && b.exportSVGElements[0]).element;
        b.openMenu ? this.fakeClickEvent(e) : (this.fakeClickEvent(d), b.highlightExportItem(0));
        return a.response.success;
      };
      return d;
    }(l);
    (function (f) {
      function d() {
        var a = this.exportSVGElements && this.exportSVGElements[0];
        if (a && (a = a.element, a.onclick)) a.onclick(w("click"));
      }
      function b() {
        var a = this.exportDivElements;
        a && this.exportContextMenu && this.openMenu && (a.forEach(function (a) {
          if (a && "highcharts-menu-item" === a.className && a.onmouseout) a.onmouseout(w("mouseout"));
        }), this.highlightedExportItemIx = 0, this.exportContextMenu.hideMenu(), this.container.focus());
      }
      function c(a) {
        var b = this.exportDivElements && this.exportDivElements[a],
          c = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx];
        if (b && "LI" === b.tagName && (!b.children || !b.children.length)) {
          var e = !!(this.renderTo.getElementsByTagName("g")[0] || {}).focus;
          b.focus && e && b.focus();
          if (c && c.onmouseout) c.onmouseout(w("mouseout"));
          if (b.onmouseover) b.onmouseover(w("mouseover"));
          this.highlightedExportItemIx = a;
          return !0;
        }
        return !1;
      }
      function e() {
        if (this.exportDivElements) for (var a = this.exportDivElements.length; a--;) if (this.highlightExportItem(a)) return !0;
        return !1;
      }
      var r = [];
      f.compose = function (f) {
        -1 === r.indexOf(f) && (r.push(f), f = a.prototype, f.hideExportMenu = b, f.highlightExportItem = c, f.highlightLastExportItem = e, f.showExportMenu = d);
      };
    })(h || (h = {}));
    return h;
  });
  A(a, "Accessibility/KeyboardNavigation.js", [a["Core/Globals.js"], a["Accessibility/Components/MenuComponent.js"], a["Core/Utilities.js"], a["Accessibility/Utils/EventProvider.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h, l, x, m) {
    var p = a.doc,
      u = a.win,
      z = l.addEvent,
      g = l.fireEvent,
      k = m.getElement,
      w = m.simulatedEventTarget;
    l = function () {
      function a(a, b) {
        this.components = this.chart = void 0;
        this.currentModuleIx = NaN;
        this.exitAnchor = this.eventProvider = void 0;
        this.modules = [];
        this.tabindexContainer = void 0;
        this.init(a, b);
      }
      a.prototype.init = function (a, b) {
        var c = this,
          e = this.eventProvider = new x();
        this.chart = a;
        this.components = b;
        this.modules = [];
        this.currentModuleIx = 0;
        this.update();
        e.addEvent(this.tabindexContainer, "keydown", function (a) {
          return c.onKeydown(a);
        });
        e.addEvent(this.tabindexContainer, "focus", function (a) {
          return c.onFocus(a);
        });
        ["mouseup", "touchend"].forEach(function (a) {
          return e.addEvent(p, a, function (a) {
            return c.onMouseUp(a);
          });
        });
        ["mousedown", "touchstart"].forEach(function (b) {
          return e.addEvent(a.renderTo, b, function () {
            c.isClickingChart = !0;
          });
        });
        e.addEvent(a.renderTo, "mouseover", function () {
          c.pointerIsOverChart = !0;
        });
        e.addEvent(a.renderTo, "mouseout", function () {
          c.pointerIsOverChart = !1;
        });
      };
      a.prototype.update = function (a) {
        var b = this.chart.options.accessibility;
        b = b && b.keyboardNavigation;
        var c = this.components;
        this.updateContainerTabindex();
        b && b.enabled && a && a.length ? (this.modules = a.reduce(function (a, b) {
          b = c[b].getKeyboardNavigation();
          return a.concat(b);
        }, []), this.updateExitAnchor()) : (this.modules = [], this.currentModuleIx = 0, this.removeExitAnchor());
      };
      a.prototype.updateExitAnchor = function () {
        var a = "highcharts-end-of-chart-marker-".concat(this.chart.index);
        a = k(a);
        this.removeExitAnchor();
        a ? (this.makeElementAnExitAnchor(a), this.exitAnchor = a) : this.createExitAnchor();
      };
      a.prototype.move = function (a) {
        var b = this.modules && this.modules[this.currentModuleIx];
        b && b.terminate && b.terminate(a);
        this.chart.focusElement && this.chart.focusElement.removeFocusBorder();
        this.currentModuleIx += a;
        if (b = this.modules && this.modules[this.currentModuleIx]) {
          if (b.validate && !b.validate()) return this.move(a);
          if (b.init) return b.init(a), !0;
        }
        this.currentModuleIx = 0;
        this.exiting = !0;
        0 < a ? this.exitAnchor && this.exitAnchor.focus() : this.tabindexContainer.focus();
        return !1;
      };
      a.prototype.onFocus = function (a) {
        var b = this.chart;
        a = a.relatedTarget && b.container.contains(a.relatedTarget);
        this.exiting || this.tabbingInBackwards || this.isClickingChart || a || (a = this.getFirstValidModuleIx(), null !== a && (this.currentModuleIx = a, this.modules[a].init(1)));
        this.exiting = !1;
      };
      a.prototype.onMouseUp = function (a) {
        delete this.isClickingChart;
        if (!this.keyboardReset && a.relatedTarget !== w) {
          a = this.chart;
          if (!this.pointerIsOverChart) {
            var b = this.modules && this.modules[this.currentModuleIx || 0];
            b && b.terminate && b.terminate();
            this.currentModuleIx = 0;
          }
          a.focusElement && (a.focusElement.removeFocusBorder(), delete a.focusElement);
          this.keyboardReset = !0;
        }
      };
      a.prototype.onKeydown = function (a) {
        a = a || u.event;
        var b = this.modules && this.modules.length && this.modules[this.currentModuleIx],
          c;
        this.exiting = this.keyboardReset = !1;
        if (b) {
          var e = b.run(a);
          e === b.response.success ? c = !0 : e === b.response.prev ? c = this.move(-1) : e === b.response.next && (c = this.move(1));
          c && (a.preventDefault(), a.stopPropagation());
        }
      };
      a.prototype.updateContainerTabindex = function () {
        var a = this.chart.options.accessibility;
        a = a && a.keyboardNavigation;
        a = !(a && !1 === a.enabled);
        var b = this.chart,
          c = b.container;
        b.renderTo.hasAttribute("tabindex") && (c.removeAttribute("tabindex"), c = b.renderTo);
        this.tabindexContainer = c;
        var e = c.getAttribute("tabindex");
        a && !e ? c.setAttribute("tabindex", "0") : a || b.container.removeAttribute("tabindex");
      };
      a.prototype.createExitAnchor = function () {
        var a = this.chart,
          b = this.exitAnchor = p.createElement("div");
        a.renderTo.appendChild(b);
        this.makeElementAnExitAnchor(b);
      };
      a.prototype.makeElementAnExitAnchor = function (a) {
        var b = this.tabindexContainer.getAttribute("tabindex") || 0;
        a.setAttribute("class", "highcharts-exit-anchor");
        a.setAttribute("tabindex", b);
        a.setAttribute("aria-hidden", !1);
        this.addExitAnchorEventsToEl(a);
      };
      a.prototype.removeExitAnchor = function () {
        this.exitAnchor && this.exitAnchor.parentNode && (this.exitAnchor.parentNode.removeChild(this.exitAnchor), delete this.exitAnchor);
      };
      a.prototype.addExitAnchorEventsToEl = function (a) {
        var b = this.chart,
          c = this;
        this.eventProvider.addEvent(a, "focus", function (a) {
          a = a || u.event;
          var e = !(a.relatedTarget && b.container.contains(a.relatedTarget) || c.exiting);
          b.focusElement && delete b.focusElement;
          e ? (c.tabbingInBackwards = !0, c.tabindexContainer.focus(), delete c.tabbingInBackwards, a.preventDefault(), c.modules && c.modules.length && (c.currentModuleIx = c.modules.length - 1, (a = c.modules[c.currentModuleIx]) && a.validate && !a.validate() ? c.move(-1) : a && a.init(-1))) : c.exiting = !1;
        });
      };
      a.prototype.getFirstValidModuleIx = function () {
        for (var a = this.modules.length, b = 0; b < a; ++b) {
          var c = this.modules[b];
          if (!c.validate || c.validate()) return b;
        }
        return null;
      };
      a.prototype.destroy = function () {
        this.removeExitAnchor();
        this.eventProvider.removeAddedEvents();
        this.chart.container.removeAttribute("tabindex");
      };
      return a;
    }();
    (function (f) {
      function d() {
        var a = this;
        g(this, "dismissPopupContent", {}, function () {
          a.tooltip && a.tooltip.hide(0);
          a.hideExportMenu();
        });
      }
      function b(b) {
        27 === (b.which || b.keyCode) && a.charts && a.charts.forEach(function (a) {
          a && a.dismissPopupContent && a.dismissPopupContent();
        });
      }
      var c = [];
      f.compose = function (a) {
        h.compose(a);
        -1 === c.indexOf(a) && (c.push(a), a.prototype.dismissPopupContent = d);
        -1 === c.indexOf(p) && (c.push(p), z(p, "keydown", b));
        return a;
      };
    })(l || (l = {}));
    return l;
  });
  A(a, "Accessibility/Components/LegendComponent.js", [a["Core/Animation/AnimationUtilities.js"], a["Core/Globals.js"], a["Core/Legend/Legend.js"], a["Core/Utilities.js"], a["Accessibility/AccessibilityComponent.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h, l, x, m, p, K, z) {
    function g(a) {
      var b = a.legend && a.legend.allItems,
        c = a.options.legend.accessibility || {};
      a = a.colorAxis && a.colorAxis.some(function (a) {
        return !a.dataClasses || !a.dataClasses.length;
      });
      return !(!b || !b.length || a || !1 === c.enabled);
    }
    function k(a, b) {
      var e = b.legendItem || {};
      b.setState(a ? "hover" : "", !0);
      b = 0;
      for (var d = ["group", "label", "symbol"]; b < d.length; b++) {
        var f = e[d[b]];
        (f = f && f.element || f) && c(f, a ? "mouseover" : "mouseout");
      }
    }
    var w = this && this.__extends || function () {
        var a = function (b, c) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(b, c);
        };
        return function (b, c) {
          function e() {
            this.constructor = b;
          }
          a(b, c);
          b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());
        };
      }(),
      f = a.animObject,
      d = h.doc,
      b = x.addEvent,
      c = x.fireEvent,
      e = x.isNumber,
      r = x.pick,
      E = x.syncTimeout,
      u = K.getChartTitle,
      J = z.stripHTMLTagsFromString,
      B = z.addClass,
      H = z.removeClass;
    a = function (a) {
      function b() {
        var b = null !== a && a.apply(this, arguments) || this;
        b.highlightedLegendItemIx = NaN;
        b.proxyGroup = null;
        return b;
      }
      w(b, a);
      b.prototype.init = function () {
        var a = this;
        this.recreateProxies();
        this.addEvent(l, "afterScroll", function () {
          this.chart === a.chart && (a.proxyProvider.updateGroupProxyElementPositions("legend"), a.updateLegendItemProxyVisibility(), -1 < a.highlightedLegendItemIx && this.chart.highlightLegendItem(a.highlightedLegendItemIx));
        });
        this.addEvent(l, "afterPositionItem", function (b) {
          this.chart === a.chart && this.chart.renderer && a.updateProxyPositionForItem(b.item);
        });
        this.addEvent(l, "afterRender", function () {
          this.chart === a.chart && this.chart.renderer && a.recreateProxies() && E(function () {
            return a.proxyProvider.updateGroupProxyElementPositions("legend");
          }, f(r(this.chart.renderer.globalAnimation, !0)).duration);
        });
      };
      b.prototype.updateLegendItemProxyVisibility = function () {
        var a = this.chart,
          b = a.legend,
          c = b.currentPage || 1,
          e = b.clipHeight || 0,
          d;
        (b.allItems || []).forEach(function (n) {
          if (n.a11yProxyElement) {
            var t = b.pages && b.pages.length,
              y = n.a11yProxyElement.element,
              q = !1;
            d = n.legendItem || {};
            t && (n = d.pageIx || 0, t = d.y || 0, q = d.label ? Math.round(d.label.getBBox().height) : 0, q = t + q - b.pages[n] > e || n !== c - 1);
            q ? a.styledMode ? B(y, "highcharts-a11y-invisible") : y.style.visibility = "hidden" : (H(y, "highcharts-a11y-invisible"), y.style.visibility = "");
          }
        });
      };
      b.prototype.onChartRender = function () {
        g(this.chart) || this.removeProxies();
      };
      b.prototype.highlightAdjacentLegendPage = function (a) {
        var b = this.chart,
          c = b.legend;
        a = (c.currentPage || 1) + a;
        var e = c.pages || [];
        if (0 < a && a <= e.length) for (var d = e = 0, n = c.allItems; d < n.length; d++) ((n[d].legendItem || {}).pageIx || 0) + 1 === a && (c = b.highlightLegendItem(e)) && (this.highlightedLegendItemIx = e), ++e;
      };
      b.prototype.updateProxyPositionForItem = function (a) {
        a.a11yProxyElement && a.a11yProxyElement.refreshPosition();
      };
      b.prototype.recreateProxies = function () {
        var a = d.activeElement,
          b = this.proxyGroup;
        a = a && b && b.contains(a);
        this.removeProxies();
        return g(this.chart) ? (this.addLegendProxyGroup(), this.proxyLegendItems(), this.updateLegendItemProxyVisibility(), this.updateLegendTitle(), a && this.chart.highlightLegendItem(this.highlightedLegendItemIx), !0) : !1;
      };
      b.prototype.removeProxies = function () {
        this.proxyProvider.removeGroup("legend");
      };
      b.prototype.updateLegendTitle = function () {
        var a = this.chart,
          b = J((a.legend && a.legend.options.title && a.legend.options.title.text || "").replace(/<br ?\/?>/g, " "));
        a = a.langFormat("accessibility.legend.legendLabel" + (b ? "" : "NoTitle"), {
          chart: a,
          legendTitle: b,
          chartTitle: u(a)
        });
        this.proxyProvider.updateGroupAttrs("legend", {
          "aria-label": a
        });
      };
      b.prototype.addLegendProxyGroup = function () {
        this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", {
          "aria-label": "_placeholder_",
          role: "all" === this.chart.options.accessibility.landmarkVerbosity ? "region" : null
        });
      };
      b.prototype.proxyLegendItems = function () {
        var a = this,
          b;
        ((this.chart.legend || {}).allItems || []).forEach(function (c) {
          b = c.legendItem || {};
          b.label && b.label.element && a.proxyLegendItem(c);
        });
      };
      b.prototype.proxyLegendItem = function (a) {
        var b = a.legendItem || {};
        if (b.label && b.group) {
          var c = this.chart.langFormat("accessibility.legend.legendItem", {
            chart: this.chart,
            itemName: J(a.name),
            item: a
          });
          a.a11yProxyElement = this.proxyProvider.addProxyElement("legend", {
            click: b.label,
            visual: (b.group.div ? b.label : b.group).element
          }, {
            tabindex: -1,
            "aria-pressed": a.visible,
            "aria-label": c
          });
        }
      };
      b.prototype.getKeyboardNavigation = function () {
        var a = this.keyCodes,
          b = this,
          c = this.chart;
        return new p(c, {
          keyCodeMap: [[[a.left, a.right, a.up, a.down], function (a) {
            return b.onKbdArrowKey(this, a);
          }], [[a.enter, a.space], function () {
            return b.onKbdClick(this);
          }], [[a.pageDown, a.pageUp], function (c) {
            b.highlightAdjacentLegendPage(c === a.pageDown ? 1 : -1);
            return this.response.success;
          }]],
          validate: function () {
            return b.shouldHaveLegendNavigation();
          },
          init: function () {
            c.highlightLegendItem(0);
            b.highlightedLegendItemIx = 0;
          },
          terminate: function () {
            b.highlightedLegendItemIx = -1;
            c.legend.allItems.forEach(function (a) {
              return k(!1, a);
            });
          }
        });
      };
      b.prototype.onKbdArrowKey = function (a, b) {
        var c = this.keyCodes,
          e = a.response,
          d = this.chart,
          n = d.options.accessibility,
          f = d.legend.allItems.length;
        b = b === c.left || b === c.up ? -1 : 1;
        if (d.highlightLegendItem(this.highlightedLegendItemIx + b)) return this.highlightedLegendItemIx += b, e.success;
        1 < f && n.keyboardNavigation.wrapAround && a.init(b);
        return e.success;
      };
      b.prototype.onKbdClick = function (a) {
        var b = this.chart.legend.allItems[this.highlightedLegendItemIx];
        b && b.a11yProxyElement && b.a11yProxyElement.click();
        return a.response.success;
      };
      b.prototype.shouldHaveLegendNavigation = function () {
        if (!g(this.chart)) return !1;
        var a = this.chart,
          b = (a.options.legend || {}).accessibility || {};
        return !!(a.legend.display && b.keyboardNavigation && b.keyboardNavigation.enabled);
      };
      return b;
    }(m);
    (function (a) {
      function c(a) {
        var b = this.legend.allItems,
          c = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx,
          d = b[a],
          n = d.legendItem || {};
        return d ? (e(c) && b[c] && k(!1, b[c]), b = this.legend, a = (b.allItems[a].legendItem || {}).pageIx, c = b.currentPage, "undefined" !== typeof a && a + 1 !== c && b.scroll(1 + a - c), n = n.label, a = d.a11yProxyElement && d.a11yProxyElement.buttonElement, n && n.element && a && this.setFocusToElement(n, a), k(!0, d), !0) : !1;
      }
      function d(a) {
        var b = a.item;
        this.chart.options.accessibility.enabled && b && b.a11yProxyElement && b.a11yProxyElement.buttonElement.setAttribute("aria-pressed", a.visible ? "true" : "false");
      }
      var f = [];
      a.compose = function (a, e) {
        -1 === f.indexOf(a) && (f.push(a), a.prototype.highlightLegendItem = c);
        -1 === f.indexOf(e) && (f.push(e), b(e, "afterColorizeItem", d));
      };
    })(a || (a = {}));
    return a;
  });
  A(a, "Accessibility/Components/SeriesComponent/SeriesDescriber.js", [a["Accessibility/Components/AnnotationsA11y.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Core/FormatUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Core/Utilities.js"]], function (a, h, l, x, m) {
    function p(a) {
      var b = a.index;
      return a.series && a.series.data && F(b) ? q(a.series.data, function (a) {
        return !!(a && "undefined" !== typeof a.index && a.index > b && a.graphic && a.graphic.element);
      }) || null : null;
    }
    function u(a) {
      var b = a.chart.options.accessibility.series.pointDescriptionEnabledThreshold;
      return !!(!1 !== b && a.points && a.points.length >= b);
    }
    function z(a) {
      var b = a.options.accessibility || {};
      return !u(a) && !b.exposeAsGroupOnly;
    }
    function g(a) {
      var b = a.chart.options.accessibility.keyboardNavigation.seriesNavigation;
      return !(!a.points || !(a.points.length < b.pointNavigationEnabledThreshold || !1 === b.pointNavigationEnabledThreshold));
    }
    function k(a, b) {
      var c = a.series,
        e = c.chart;
      a = e.options.accessibility.point || {};
      var d = c.options.accessibility && c.options.accessibility.point || {};
      c = c.tooltipOptions || {};
      e = e.options.lang;
      return D(b) ? C(b, d.valueDecimals || a.valueDecimals || c.valueDecimals || -1, e.decimalPoint, e.accessibility.thousandsSep || e.thousandsSep) : b;
    }
    function w(a) {
      var b = (a.options.accessibility || {}).description;
      return b && a.chart.langFormat("accessibility.series.description", {
        description: b,
        series: a
      }) || "";
    }
    function f(a, b) {
      return a.chart.langFormat("accessibility.series." + b + "Description", {
        name: E(a[b]),
        series: a
      });
    }
    function d(a, b, c) {
      var e = b || "",
        d = c || "";
      return a.series.pointArrayMap.reduce(function (b, c) {
        b += b.length ? ", " : "";
        var n = k(a, y(a[c], a.options[c]));
        return b + (c + ": " + e + n + d);
      }, "");
    }
    function b(a) {
      var b = a.series,
        c = 1 < b.chart.series.length || b.options.name,
        e = a.series;
      var n = e.chart;
      var f = e.options.accessibility;
      f = f && f.point && f.point.valueDescriptionFormat || n.options.accessibility.point.valueDescriptionFormat;
      e = y(e.xAxis && e.xAxis.options.accessibility && e.xAxis.options.accessibility.enabled, !n.angular);
      if (e) {
        var t = a.series;
        var q = t.chart;
        var v = t.options.accessibility && t.options.accessibility.point || {},
          D = q.options.accessibility.point || {};
        (t = t.xAxis && t.xAxis.dateTime) ? (t = t.getXDateFormat(a.x || 0, q.options.tooltip.dateTimeLabelFormats), v = v.dateFormatter && v.dateFormatter(a) || D.dateFormatter && D.dateFormatter(a) || v.dateFormat || D.dateFormat || t, q = q.time.dateFormat(v, a.x || 0, void 0)) : q = void 0;
        v = (a.series.xAxis || {}).categories && F(a.category) && ("" + a.category).replace("<br/>", " ");
        D = F(a.id) && 0 > ("" + a.id).indexOf("highcharts-");
        t = "x, " + a.x;
        q = a.name || q || v || (D ? a.id : t);
      } else q = "";
      v = F(a.index) ? a.index + 1 : "";
      D = a.series;
      var g = D.chart.options.accessibility.point || {},
        E = D.chart.options.accessibility && D.chart.options.accessibility.point || {},
        h = D.tooltipOptions || {};
      t = E.valuePrefix || g.valuePrefix || h.valuePrefix || "";
      g = E.valueSuffix || g.valueSuffix || h.valueSuffix || "";
      E = k(a, a["undefined" !== typeof a.value ? "value" : "y"]);
      D = a.isNull ? D.chart.langFormat("accessibility.series.nullPointValue", {
        point: a
      }) : D.pointArrayMap ? d(a, t, g) : t + E + g;
      n = H(f, {
        point: a,
        index: v,
        xDescription: q,
        value: D,
        separator: e ? ", " : ""
      }, n);
      f = (f = a.options && a.options.accessibility && a.options.accessibility.description) ? " " + f : "";
      b = c ? " " + b.name + "." : "";
      c = a.series.chart;
      e = r(a);
      q = {
        point: a,
        annotations: e
      };
      c = e.length ? c.langFormat("accessibility.series.pointAnnotationsDescription", q) : "";
      a.accessibility = a.accessibility || {};
      a.accessibility.valueDescription = n;
      return n + f + b + (c ? " " + c : "");
    }
    function c(a) {
      var c = z(a),
        e = g(a),
        d = a.chart.options.accessibility.point.describeNull;
      (c || e) && a.points.forEach(function (e) {
        var f;
        if (!(f = e.graphic && e.graphic.element)) {
          var t = e.series;
          f = t && t.chart;
          t = t && t.is("sunburst");
          f = f && f.options.accessibility.point.describeNull;
          if (f = e.isNull && !t && f) {
            t = e.series;
            var q = p(e);
            t = (f = q && q.graphic) ? f.parentGroup : t.graph || t.group;
            q = q ? {
              x: y(e.plotX, q.plotX, 0),
              y: y(e.plotY, q.plotY, 0)
            } : {
              x: y(e.plotX, 0),
              y: y(e.plotY, 0)
            };
            q = e.series.chart.renderer.rect(q.x, q.y, 1, 1);
            q.attr({
              "class": "highcharts-a11y-mock-point",
              fill: "none",
              opacity: 0,
              "fill-opacity": 0,
              "stroke-opacity": 0
            });
            t && t.element ? (e.graphic = q, e.hasMockGraphic = !0, q.add(t), t.element.insertBefore(q.element, f ? f.element : null), f = q.element) : f = void 0;
          }
        }
        t = e.options && e.options.accessibility && !1 === e.options.accessibility.enabled;
        f && (e.isNull && !d ? f.setAttribute("aria-hidden", !0) : (f.setAttribute("tabindex", "-1"), a.chart.styledMode || (f.style.outline = "none"), c && !t ? (q = e.series, t = q.chart.options.accessibility.point || {}, q = q.options.accessibility && q.options.accessibility.point || {}, e = n(q.descriptionFormatter && q.descriptionFormatter(e) || t.descriptionFormatter && t.descriptionFormatter(e) || b(e)), f.setAttribute("role", "img"), f.setAttribute("aria-label", e)) : f.setAttribute("aria-hidden", !0)));
      });
    }
    function e(a) {
      var b = a.chart,
        c = b.types || [],
        e = w(a),
        d = function (c) {
          return b[c] && 1 < b[c].length && a[c];
        },
        n = a.index + 1,
        q = f(a, "xAxis"),
        t = f(a, "yAxis"),
        y = {
          seriesNumber: n,
          series: a,
          chart: b
        };
      c = 1 < c.length ? "Combination" : "";
      y = b.langFormat("accessibility.series.summary." + a.type + c, y) || b.langFormat("accessibility.series.summary.default" + c, y);
      d = (d("yAxis") ? " " + t + "." : "") + (d("xAxis") ? " " + q + "." : "");
      return H(b.options.accessibility.series.descriptionFormat || "", {
        seriesDescription: y,
        authorDescription: e ? " " + e : "",
        axisDescription: d,
        series: a,
        chart: b,
        seriesNumber: n
      }, void 0);
    }
    var r = a.getPointAnnotationTexts,
      E = h.getAxisDescription,
      I = h.getSeriesFirstPointElement,
      J = h.getSeriesA11yElement,
      B = h.unhideChartElementFromAT,
      H = l.format,
      C = l.numberFormat,
      v = x.reverseChildNodes,
      n = x.stripHTMLTagsFromString,
      q = m.find,
      D = m.isNumber,
      y = m.pick,
      F = m.defined;
    return {
      defaultPointDescriptionFormatter: b,
      defaultSeriesDescriptionFormatter: e,
      describeSeries: function (a) {
        var b = a.chart,
          d = I(a),
          f = J(a),
          q = b.is3d && b.is3d();
        if (f) {
          f.lastChild !== d || q || v(f);
          c(a);
          B(b, f);
          q = a.chart;
          b = q.options.chart;
          d = 1 < q.series.length;
          q = q.options.accessibility.series.describeSingleSeries;
          var y = (a.options.accessibility || {}).exposeAsGroupOnly;
          b.options3d && b.options3d.enabled && d || !(d || q || y || u(a)) ? f.removeAttribute("aria-label") : (b = a.chart.options.accessibility, d = b.landmarkVerbosity, (a.options.accessibility || {}).exposeAsGroupOnly ? f.setAttribute("role", "img") : "all" === d ? f.setAttribute("role", "region") : f.setAttribute("role", "group"), f.setAttribute("tabindex", "-1"), a.chart.styledMode || (f.style.outline = "none"), f.setAttribute("aria-label", n(b.series.descriptionFormatter && b.series.descriptionFormatter(a) || e(a))));
        }
      }
    };
  });
  A(a, "Accessibility/Components/SeriesComponent/NewDataAnnouncer.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Accessibility/Utils/Announcer.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/EventProvider.js"], a["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]], function (a, h, l, x, m, p) {
    function u(a) {
      var b = a.series.data.filter(function (b) {
        return a.x === b.x && a.y === b.y;
      });
      return 1 === b.length ? b[0] : a;
    }
    function z(a, c) {
      var b = (a || []).concat(c || []).reduce(function (a, b) {
        a[b.name + b.index] = b;
        return a;
      }, {});
      return Object.keys(b).map(function (a) {
        return b[a];
      });
    }
    var g = h.addEvent,
      k = h.defined,
      w = x.getChartTitle,
      f = p.defaultPointDescriptionFormatter,
      d = p.defaultSeriesDescriptionFormatter;
    h = function () {
      function b(a) {
        this.announcer = void 0;
        this.dirty = {
          allSeries: {}
        };
        this.eventProvider = void 0;
        this.lastAnnouncementTime = 0;
        this.chart = a;
      }
      b.prototype.init = function () {
        var a = this.chart,
          b = a.options.accessibility.announceNewData.interruptUser ? "assertive" : "polite";
        this.lastAnnouncementTime = 0;
        this.dirty = {
          allSeries: {}
        };
        this.eventProvider = new m();
        this.announcer = new l(a, b);
        this.addEventListeners();
      };
      b.prototype.destroy = function () {
        this.eventProvider.removeAddedEvents();
        this.announcer.destroy();
      };
      b.prototype.addEventListeners = function () {
        var a = this,
          b = this.chart,
          d = this.eventProvider;
        d.addEvent(b, "afterApplyDrilldown", function () {
          a.lastAnnouncementTime = 0;
        });
        d.addEvent(b, "afterAddSeries", function (b) {
          a.onSeriesAdded(b.series);
        });
        d.addEvent(b, "redraw", function () {
          a.announceDirtyData();
        });
      };
      b.prototype.onSeriesAdded = function (a) {
        this.chart.options.accessibility.announceNewData.enabled && (this.dirty.hasDirty = !0, this.dirty.allSeries[a.name + a.index] = a, this.dirty.newSeries = k(this.dirty.newSeries) ? void 0 : a);
      };
      b.prototype.announceDirtyData = function () {
        var a = this;
        if (this.chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
          var b = this.dirty.newPoint;
          b && (b = u(b));
          this.queueAnnouncement(Object.keys(this.dirty.allSeries).map(function (b) {
            return a.dirty.allSeries[b];
          }), this.dirty.newSeries, b);
          this.dirty = {
            allSeries: {}
          };
        }
      };
      b.prototype.queueAnnouncement = function (a, b, d) {
        var c = this,
          e = this.chart.options.accessibility.announceNewData;
        if (e.enabled) {
          var f = +new Date();
          e = Math.max(0, e.minAnnounceInterval - (f - this.lastAnnouncementTime));
          a = z(this.queuedAnnouncement && this.queuedAnnouncement.series, a);
          if (b = this.buildAnnouncementMessage(a, b, d)) this.queuedAnnouncement && clearTimeout(this.queuedAnnouncementTimer), this.queuedAnnouncement = {
            time: f,
            message: b,
            series: a
          }, this.queuedAnnouncementTimer = setTimeout(function () {
            c && c.announcer && (c.lastAnnouncementTime = +new Date(), c.announcer.announce(c.queuedAnnouncement.message), delete c.queuedAnnouncement, delete c.queuedAnnouncementTimer);
          }, e);
        }
      };
      b.prototype.buildAnnouncementMessage = function (b, e, r) {
        var c = this.chart,
          g = c.options.accessibility.announceNewData;
        if (g.announcementFormatter && (b = g.announcementFormatter(b, e, r), !1 !== b)) return b.length ? b : null;
        b = a.charts && 1 < a.charts.length ? "Multiple" : "Single";
        b = e ? "newSeriesAnnounce" + b : r ? "newPointAnnounce" + b : "newDataAnnounce";
        g = w(c);
        return c.langFormat("accessibility.announceNewData." + b, {
          chartTitle: g,
          seriesDesc: e ? d(e) : null,
          pointDesc: r ? f(r) : null,
          point: r,
          series: e
        });
      };
      return b;
    }();
    (function (a) {
      function b(a) {
        var b = this.chart,
          c = this.newDataAnnouncer;
        c && c.chart === b && b.options.accessibility.announceNewData.enabled && (c.dirty.newPoint = k(c.dirty.newPoint) ? void 0 : a.point);
      }
      function e() {
        var a = this.chart,
          b = this.newDataAnnouncer;
        b && b.chart === a && a.options.accessibility.announceNewData.enabled && (b.dirty.hasDirty = !0, b.dirty.allSeries[this.name + this.index] = this);
      }
      a.composedClasses = [];
      a.compose = function (c) {
        -1 === a.composedClasses.indexOf(c) && (a.composedClasses.push(c), g(c, "addPoint", b), g(c, "updatedData", e));
      };
    })(h || (h = {}));
    return h;
  });
  A(a, "Accessibility/ProxyElement.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Accessibility/Utils/EventProvider.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"]], function (a, h, l, x, m) {
    var p = a.doc,
      u = h.attr,
      z = h.css,
      g = h.merge,
      k = x.fireEventOnWrappedOrUnwrappedElement,
      w = m.cloneMouseEvent,
      f = m.cloneTouchEvent,
      d = m.getFakeMouseEvent,
      b = m.removeElement;
    return function () {
      function a(a, b, c, d) {
        this.chart = a;
        this.target = b;
        this.groupType = c;
        c = "ul" === c;
        this.eventProvider = new l();
        var e = c ? p.createElement("li") : null,
          f = this.buttonElement = p.createElement("button");
        a.styledMode || this.hideButtonVisually(f);
        e ? (c && !a.styledMode && (e.style.listStyle = "none"), e.appendChild(f), this.element = e) : this.element = f;
        this.updateTarget(b, d);
      }
      a.prototype.click = function () {
        var a = this.getTargetPosition();
        a.x += a.width / 2;
        a.y += a.height / 2;
        a = d("click", a);
        k(this.target.click, a);
      };
      a.prototype.updateTarget = function (a, b) {
        this.target = a;
        this.updateCSSClassName();
        var c = b || {};
        Object.keys(c).forEach(function (a) {
          null === c[a] && delete c[a];
        });
        u(this.buttonElement, g({
          "aria-label": this.getTargetAttr(a.click, "aria-label")
        }, c));
        this.eventProvider.removeAddedEvents();
        this.addProxyEventsToButton(this.buttonElement, a.click);
        this.refreshPosition();
      };
      a.prototype.refreshPosition = function () {
        var a = this.getTargetPosition();
        z(this.buttonElement, {
          width: (a.width || 1) + "px",
          height: (a.height || 1) + "px",
          left: (Math.round(a.x) || 0) + "px",
          top: (Math.round(a.y) || 0) + "px"
        });
      };
      a.prototype.remove = function () {
        this.eventProvider.removeAddedEvents();
        b(this.element);
      };
      a.prototype.updateCSSClassName = function () {
        var a = this.chart.legend;
        a = a.group && a.group.div;
        a = -1 < (a && a.className || "").indexOf("highcharts-no-tooltip");
        var b = -1 < (this.getTargetAttr(this.target.click, "class") || "").indexOf("highcharts-no-tooltip");
        this.buttonElement.className = a || b ? "highcharts-a11y-proxy-button highcharts-no-tooltip" : "highcharts-a11y-proxy-button";
      };
      a.prototype.addProxyEventsToButton = function (a, b) {
        var c = this;
        "click touchstart touchend touchcancel touchmove mouseover mouseenter mouseleave mouseout".split(" ").forEach(function (e) {
          var d = 0 === e.indexOf("touch");
          c.eventProvider.addEvent(a, e, function (a) {
            var c = d ? f(a) : w(a);
            b && k(b, c);
            a.stopPropagation();
            d || a.preventDefault();
          }, {
            passive: !1
          });
        });
      };
      a.prototype.hideButtonVisually = function (a) {
        z(a, {
          borderWidth: 0,
          backgroundColor: "transparent",
          cursor: "pointer",
          outline: "none",
          opacity: .001,
          filter: "alpha(opacity=1)",
          zIndex: 999,
          overflow: "hidden",
          padding: 0,
          margin: 0,
          display: "block",
          position: "absolute",
          "-ms-filter": "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)"
        });
      };
      a.prototype.getTargetPosition = function () {
        var a = this.target.click;
        a = a.element ? a.element : a;
        a = this.target.visual || a;
        if (this.chart.renderTo && a && a.getBoundingClientRect) {
          a = a.getBoundingClientRect();
          var b = this.chart.pointer.getChartPosition();
          return {
            x: (a.left - b.left) / b.scaleX,
            y: (a.top - b.top) / b.scaleY,
            width: a.right / b.scaleX - a.left / b.scaleX,
            height: a.bottom / b.scaleY - a.top / b.scaleY
          };
        }
        return {
          x: 0,
          y: 0,
          width: 1,
          height: 1
        };
      };
      a.prototype.getTargetAttr = function (a, b) {
        return a.element ? a.element.getAttribute(b) : a.getAttribute(b);
      };
      return a;
    }();
  });
  A(a, "Accessibility/ProxyProvider.js", [a["Core/Globals.js"], a["Core/Utilities.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/DOMElementProvider.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Accessibility/ProxyElement.js"]], function (a, h, l, x, m, p) {
    var u = a.doc,
      z = h.attr,
      g = h.css,
      k = l.unhideChartElementFromAT,
      w = m.removeElement,
      f = m.removeChildNodes;
    return function () {
      function a(a) {
        this.chart = a;
        this.domElementProvider = new x();
        this.groups = {};
        this.groupOrder = [];
        this.beforeChartProxyPosContainer = this.createProxyPosContainer("before");
        this.afterChartProxyPosContainer = this.createProxyPosContainer("after");
        this.update();
      }
      a.prototype.addProxyElement = function (a, c, e) {
        var b = this.groups[a];
        if (!b) throw Error("ProxyProvider.addProxyElement: Invalid group key " + a);
        a = new p(this.chart, c, b.type, e);
        b.proxyContainerElement.appendChild(a.element);
        b.proxyElements.push(a);
        return a;
      };
      a.prototype.addGroup = function (a, c, e) {
        var b = this.groups[a];
        if (b) return b.groupElement;
        b = this.domElementProvider.createElement(c);
        if (e && e.role && "div" !== c) {
          var d = this.domElementProvider.createElement("div");
          d.appendChild(b);
        } else d = b;
        d.className = "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" + a.replace(/\W/g, "-");
        this.groups[a] = {
          proxyContainerElement: b,
          groupElement: d,
          type: c,
          proxyElements: []
        };
        z(d, e || {});
        "ul" === c && b.setAttribute("role", "list");
        this.afterChartProxyPosContainer.appendChild(d);
        this.updateGroupOrder(this.groupOrder);
        return d;
      };
      a.prototype.updateGroupAttrs = function (a, c) {
        var b = this.groups[a];
        if (!b) throw Error("ProxyProvider.updateGroupAttrs: Invalid group key " + a);
        z(b.groupElement, c);
      };
      a.prototype.updateGroupOrder = function (a) {
        var b = this;
        this.groupOrder = a.slice();
        if (!this.isDOMOrderGroupOrder()) {
          var d = a.indexOf("series"),
            g = -1 < d ? a.slice(0, d) : a,
            k = -1 < d ? a.slice(d + 1) : [];
          a = u.activeElement;
          ["before", "after"].forEach(function (a) {
            var c = b["before" === a ? "beforeChartProxyPosContainer" : "afterChartProxyPosContainer"];
            a = "before" === a ? g : k;
            f(c);
            a.forEach(function (a) {
              (a = b.groups[a]) && c.appendChild(a.groupElement);
            });
          });
          (this.beforeChartProxyPosContainer.contains(a) || this.afterChartProxyPosContainer.contains(a)) && a && a.focus && a.focus();
        }
      };
      a.prototype.clearGroup = function (a) {
        var b = this.groups[a];
        if (!b) throw Error("ProxyProvider.clearGroup: Invalid group key " + a);
        f(b.proxyContainerElement);
      };
      a.prototype.removeGroup = function (a) {
        var b = this.groups[a];
        b && (w(b.groupElement), delete this.groups[a]);
      };
      a.prototype.update = function () {
        this.updatePosContainerPositions();
        this.updateGroupOrder(this.groupOrder);
        this.updateProxyElementPositions();
      };
      a.prototype.updateProxyElementPositions = function () {
        Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this));
      };
      a.prototype.updateGroupProxyElementPositions = function (a) {
        (a = this.groups[a]) && a.proxyElements.forEach(function (a) {
          return a.refreshPosition();
        });
      };
      a.prototype.destroy = function () {
        this.domElementProvider.destroyCreatedElements();
      };
      a.prototype.createProxyPosContainer = function (a) {
        var b = this.domElementProvider.createElement("div");
        b.setAttribute("aria-hidden", "false");
        b.className = "highcharts-a11y-proxy-container" + (a ? "-" + a : "");
        g(b, {
          top: "0",
          left: "0"
        });
        this.chart.styledMode || (b.style.whiteSpace = "nowrap", b.style.position = "absolute");
        return b;
      };
      a.prototype.getCurrentGroupOrderInDOM = function () {
        var a = this,
          c = function (b) {
            var c = [];
            b = b.children;
            for (var d = 0; d < b.length; ++d) {
              a: {
                var e = b[d];
                for (var f = Object.keys(a.groups), g = f.length; g--;) {
                  var k = f[g],
                    v = a.groups[k];
                  if (v && e === v.groupElement) {
                    e = k;
                    break a;
                  }
                }
                e = void 0;
              }
              e && c.push(e);
            }
            return c;
          },
          d = c(this.beforeChartProxyPosContainer);
        c = c(this.afterChartProxyPosContainer);
        d.push("series");
        return d.concat(c);
      };
      a.prototype.isDOMOrderGroupOrder = function () {
        var a = this,
          c = this.getCurrentGroupOrderInDOM(),
          d = this.groupOrder.filter(function (b) {
            return "series" === b || !!a.groups[b];
          }),
          f = c.length;
        if (f !== d.length) return !1;
        for (; f--;) if (c[f] !== d[f]) return !1;
        return !0;
      };
      a.prototype.updatePosContainerPositions = function () {
        var a = this.chart;
        if (!a.renderer.forExport) {
          var c = a.renderer.box;
          a.container.insertBefore(this.afterChartProxyPosContainer, c.nextSibling);
          a.container.insertBefore(this.beforeChartProxyPosContainer, c);
          k(this.chart, this.afterChartProxyPosContainer);
          k(this.chart, this.beforeChartProxyPosContainer);
        }
      };
      return a;
    }();
  });
  A(a, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function () {
    return {
      lang: {
        rangeSelectorZoom: "Zoom",
        rangeSelectorFrom: "",
        rangeSelectorTo: "\u2192"
      },
      rangeSelector: {
        allButtonsEnabled: !1,
        buttons: void 0,
        buttonSpacing: 5,
        dropdown: "responsive",
        enabled: void 0,
        verticalAlign: "top",
        buttonTheme: {
          width: 28,
          height: 18,
          padding: 2,
          zIndex: 7
        },
        floating: !1,
        x: 0,
        y: 0,
        height: void 0,
        inputBoxBorderColor: "none",
        inputBoxHeight: 17,
        inputBoxWidth: void 0,
        inputDateFormat: "%b %e, %Y",
        inputDateParser: void 0,
        inputEditDateFormat: "%Y-%m-%d",
        inputEnabled: !0,
        inputPosition: {
          align: "right",
          x: 0,
          y: 0
        },
        inputSpacing: 5,
        selected: void 0,
        buttonPosition: {
          align: "left",
          x: 0,
          y: 0
        },
        inputStyle: {
          color: "#335cad",
          cursor: "pointer"
        },
        labelStyle: {
          color: "#666666"
        }
      }
    };
  });
  A(a, "Stock/RangeSelector/RangeSelectorComposition.js", [a["Core/Defaults.js"], a["Stock/RangeSelector/RangeSelectorDefaults.js"], a["Core/Utilities.js"]], function (a, h, l) {
    function x() {
      var a = this.range,
        b = a.type,
        c = this.max,
        d = this.chart.time,
        e = function (a, c) {
          var e = "year" === b ? "FullYear" : "Month",
            n = new d.Date(a),
            f = d.get(e, n);
          d.set(e, n, f + c);
          f === d.get(e, n) && d.set("Date", n, 0);
          return n.getTime() - a;
        };
      if (E(a)) {
        var f = c - a;
        var t = a;
      } else a && (f = c + e(c, -(a.count || 1)), this.chart && (this.chart.fixedRange = c - f));
      var g = A(this.dataMin, Number.MIN_VALUE);
      E(f) || (f = g);
      f <= g && (f = g, "undefined" === typeof t && (t = e(f, a.count)), this.newMax = Math.min(f + t, A(this.dataMax, Number.MAX_VALUE)));
      E(c) ? !E(a) && a && a._offsetMin && (f += a._offsetMin) : f = void 0;
      return f;
    }
    function m() {
      this.options.rangeSelector && this.options.rangeSelector.enabled && (this.rangeSelector = new C(this));
    }
    function p() {
      var a = this.axes,
        b = this.rangeSelector;
      b && (E(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {
        a.updateNames();
        a.setScale();
      }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || ("bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0)));
    }
    function u(a) {
      var c,
        d,
        e,
        f,
        F = a.rangeSelector,
        t = function () {
          F && (c = a.xAxis[0].getExtremes(), d = a.legend, f = F && F.options.verticalAlign, E(c.min) && F.render(c.min, c.max), d.display && "top" === f && f === d.options.verticalAlign && (e = I(a.spacingBox), e.y = "vertical" === d.options.layout ? a.plotTop : e.y + F.getHeight(), d.group.placed = !1, d.align(e)));
        };
      F && (r(B, function (b) {
        return b[0] === a;
      }) || B.push([a, [b(a.xAxis[0], "afterSetExtremes", function (a) {
        F && F.render(a.min, a.max);
      }), b(a, "redraw", t)]]), t());
    }
    function z() {
      for (var a = 0, b = B.length; a < b; ++a) {
        var c = B[a];
        if (c[0] === this) {
          c[1].forEach(function (a) {
            return a();
          });
          B.splice(a, 1);
          break;
        }
      }
    }
    function g() {
      var a = this.rangeSelector;
      a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));
    }
    function k() {
      var a = this.rangeSelector;
      a && !a.options.floating && (a.render(), a = a.options.verticalAlign, "bottom" === a ? this.extraBottomMargin = !0 : "middle" !== a && (this.extraTopMargin = !0));
    }
    function w(a) {
      var b = a.options.rangeSelector;
      a = this.extraBottomMargin;
      var d = this.extraTopMargin,
        e = this.rangeSelector;
      b && b.enabled && !c(e) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = e = new C(this));
      this.extraTopMargin = this.extraBottomMargin = !1;
      e && (u(this), b = b && b.verticalAlign || e.options && e.options.verticalAlign, e.options.floating || ("bottom" === b ? this.extraBottomMargin = !0 : "middle" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== a || this.extraTopMargin !== d) && (this.isDirtyBox = !0);
    }
    var f = a.defaultOptions,
      d = a.setOptions,
      b = l.addEvent,
      c = l.defined,
      e = l.extend,
      r = l.find,
      E = l.isNumber,
      I = l.merge,
      A = l.pick,
      B = [],
      H = [],
      C;
    return {
      compose: function (a, c, q) {
        C = q;
        -1 === H.indexOf(a) && (H.push(a), a.prototype.minFromRange = x);
        -1 === H.indexOf(c) && (H.push(c), b(c, "afterGetContainer", m), b(c, "beforeRender", p), b(c, "destroy", z), b(c, "getMargins", g), b(c, "render", k), b(c, "update", w), c.prototype.callbacks.push(u));
        -1 === H.indexOf(d) && (e(f, {
          rangeSelector: h.rangeSelector
        }), e(f.lang, h.lang));
      }
    };
  });
  A(a, "Stock/RangeSelector/RangeSelector.js", [a["Core/Axis/Axis.js"], a["Core/Defaults.js"], a["Core/Globals.js"], a["Stock/RangeSelector/RangeSelectorComposition.js"], a["Core/Renderer/SVG/SVGElement.js"], a["Core/Utilities.js"]], function (a, h, l, x, m, p) {
    function u(a) {
      if (-1 !== a.indexOf("%L")) return "text";
      var b = "aAdewbBmoyY".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        }),
        c = "HkIlMS".split("").some(function (b) {
          return -1 !== a.indexOf("%" + b);
        });
      return b && c ? "datetime-local" : b ? "date" : c ? "time" : "text";
    }
    var z = h.defaultOptions,
      g = p.addEvent,
      k = p.createElement,
      w = p.css,
      f = p.defined,
      d = p.destroyObjectProperties,
      b = p.discardElement,
      c = p.extend,
      e = p.fireEvent,
      r = p.isNumber,
      E = p.merge,
      I = p.objectEach,
      A = p.pad,
      B = p.pick,
      H = p.pInt,
      C = p.splat;
    h = function () {
      function v(a) {
        this.buttons = void 0;
        this.buttonOptions = v.prototype.defaultButtons;
        this.initialButtonGroupWidth = 0;
        this.options = void 0;
        this.chart = a;
        this.init(a);
      }
      v.compose = function (a, b) {
        x.compose(a, b, v);
      };
      v.prototype.clickButton = function (b, c) {
        var d = this.chart,
          n = this.buttonOptions[b],
          q = d.xAxis[0],
          t = d.scroller && d.scroller.getUnionExtremes() || q || {},
          k = n.type,
          v = n.dataGrouping,
          h = t.dataMin,
          l = t.dataMax,
          G = q && Math.round(Math.min(q.max, B(l, q.max)));
        t = n._range;
        var p,
          w = !0;
        if (null !== h && null !== l) {
          d.fixedRange = t;
          this.setSelected(b);
          v && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(q || {
            chart: this.chart
          }, v, !1), this.frozenStates = n.preserveDataGrouping);
          if ("month" === k || "year" === k) {
            if (q) {
              k = {
                range: n,
                max: G,
                chart: d,
                dataMin: h,
                dataMax: l
              };
              var m = q.minFromRange.call(k);
              r(k.newMax) && (G = k.newMax);
              w = !1;
            } else t = n;
          } else if (t) m = Math.max(G - t, h), G = Math.min(m + t, l), w = !1;else if ("ytd" === k) {
            if (q) {
              if ("undefined" === typeof l || "undefined" === typeof h) h = Number.MAX_VALUE, l = Number.MIN_VALUE, d.series.forEach(function (a) {
                if (a = a.xData) h = Math.min(a[0], h), l = Math.max(a[a.length - 1], l);
              }), c = !1;
              k = this.getYTDExtremes(l, h, d.time.useUTC);
              m = p = k.min;
              G = k.max;
            } else {
              this.deferredYTDClick = b;
              return;
            }
          } else "all" === k && q && (d.navigator && d.navigator.baseSeries[0] && (d.navigator.baseSeries[0].xAxis.options.range = void 0), m = h, G = l);
          w && n._offsetMin && f(m) && (m += n._offsetMin);
          n._offsetMax && f(G) && (G += n._offsetMax);
          this.dropdown && (this.dropdown.selectedIndex = b + 1);
          if (q) q.setExtremes(m, G, B(c, !0), void 0, {
            trigger: "rangeSelectorButton",
            rangeSelectorButton: n
          });else {
            var u = C(d.options.xAxis)[0];
            var x = u.range;
            u.range = t;
            var E = u.min;
            u.min = p;
            g(d, "load", function () {
              u.range = x;
              u.min = E;
            });
          }
          e(this, "afterBtnClick");
        }
      };
      v.prototype.setSelected = function (a) {
        this.selected = this.options.selected = a;
      };
      v.prototype.init = function (a) {
        var b = this,
          c = a.options.rangeSelector,
          d = c.buttons || b.defaultButtons.slice(),
          f = c.selected,
          n = function () {
            var a = b.minInput,
              c = b.maxInput;
            a && a.blur && e(a, "blur");
            c && c.blur && e(c, "blur");
          };
        b.chart = a;
        b.options = c;
        b.buttons = [];
        b.buttonOptions = d;
        this.eventsToUnbind = [];
        this.eventsToUnbind.push(g(a.container, "mousedown", n));
        this.eventsToUnbind.push(g(a, "resize", n));
        d.forEach(b.computeButtonRange);
        "undefined" !== typeof f && d[f] && this.clickButton(f, !1);
        this.eventsToUnbind.push(g(a, "load", function () {
          a.xAxis && a.xAxis[0] && g(a.xAxis[0], "setExtremes", function (c) {
            this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== c.trigger && "updatedData" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);
          });
        }));
      };
      v.prototype.updateButtonStates = function () {
        var a = this,
          b = this.chart,
          c = this.dropdown,
          d = b.xAxis[0],
          e = Math.round(d.max - d.min),
          f = !d.hasVisibleSeries,
          g = b.scroller && b.scroller.getUnionExtremes() || d,
          k = g.dataMin,
          h = g.dataMax;
        b = a.getYTDExtremes(h, k, b.time.useUTC);
        var v = b.min,
          G = b.max,
          l = a.selected,
          p = a.options.allButtonsEnabled,
          m = a.buttons,
          w = r(l);
        a.buttonOptions.forEach(function (b, n) {
          var t = b._range,
            q = b.type,
            y = b.count || 1,
            g = m[n],
            F = b._offsetMax - b._offsetMin,
            D = n === l,
            r = t > h - k,
            L = t < d.minRange;
          b = 0;
          var u = !1,
            C = !1;
          t = t === e;
          ("month" === q || "year" === q) && e + 36E5 >= 864E5 * {
            month: 28,
            year: 365
          }[q] * y - F && e - 36E5 <= 864E5 * {
            month: 31,
            year: 366
          }[q] * y + F ? t = !0 : "ytd" === q ? (t = G - v + F === e, u = !D) : "all" === q && (t = d.max - d.min >= h - k, C = !D && w && t);
          q = !p && (r || L || C || f);
          y = D && t || t && !w && !u || D && a.frozenStates;
          q ? b = 3 : y && (w = !0, b = 2);
          g.state !== b && (g.setState(b), c && (c.options[n + 1].disabled = q, 2 === b && (c.selectedIndex = n + 1)), 0 === b && l === n && a.setSelected());
        });
      };
      v.prototype.computeButtonRange = function (a) {
        var b = a.type,
          c = a.count || 1,
          d = {
            millisecond: 1,
            second: 1E3,
            minute: 6E4,
            hour: 36E5,
            day: 864E5,
            week: 6048E5
          };
        if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * {
          month: 30,
          year: 365
        }[b] * c;
        a._offsetMin = B(a.offsetMin, 0);
        a._offsetMax = B(a.offsetMax, 0);
        a._range += a._offsetMax - a._offsetMin;
      };
      v.prototype.getInputValue = function (a) {
        a = "min" === a ? this.minInput : this.maxInput;
        var b = this.chart.options.rangeSelector,
          c = this.chart.time;
        return a ? ("text" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;
      };
      v.prototype.setInputValue = function (a, b) {
        var c = this.options,
          d = this.chart.time,
          e = "min" === a ? this.minInput : this.maxInput;
        a = "min" === a ? this.minDateBox : this.maxDateBox;
        if (e) {
          var n = e.getAttribute("data-hc-time");
          n = f(n) ? Number(n) : void 0;
          f(b) && (f(n) && e.setAttribute("data-hc-time-previous", n), e.setAttribute("data-hc-time", b), n = b);
          e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, n);
          a && a.attr({
            text: d.dateFormat(c.inputDateFormat, n)
          });
        }
      };
      v.prototype.setInputExtremes = function (a, b, c) {
        if (a = "min" === a ? this.minInput : this.maxInput) {
          var d = this.inputTypeFormats[a.type],
            e = this.chart.time;
          d && (b = e.dateFormat(d, b), a.min !== b && (a.min = b), c = e.dateFormat(d, c), a.max !== c && (a.max = c));
        }
      };
      v.prototype.showInput = function (a) {
        var b = "min" === a ? this.minDateBox : this.maxDateBox;
        if ((a = "min" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {
          var c = "text" === a.type,
            d = this.inputGroup,
            e = d.translateX;
          d = d.translateY;
          var f = this.options.inputBoxWidth;
          w(a, {
            width: c ? b.width + (f ? -2 : 20) + "px" : "auto",
            height: c ? b.height - 2 + "px" : "auto",
            border: "2px solid silver"
          });
          c && f ? w(a, {
            left: e + b.x + "px",
            top: d + "px"
          }) : w(a, {
            left: Math.min(Math.round(b.x + e - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + "px",
            top: d - (a.offsetHeight - b.height) / 2 + "px"
          });
        }
      };
      v.prototype.hideInput = function (a) {
        (a = "min" === a ? this.minInput : this.maxInput) && w(a, {
          top: "-9999em",
          border: 0,
          width: "1px",
          height: "1px"
        });
      };
      v.prototype.defaultInputDateParser = function (a, b, c) {
        var d = a.split("/").join("-").split(" ").join("T");
        -1 === d.indexOf("T") && (d += "T00:00");
        if (b) d += "Z";else {
          var e;
          if (e = l.isSafari) e = d, e = !(6 < e.length && (e.lastIndexOf("-") === e.length - 6 || e.lastIndexOf("+") === e.length - 6));
          e && (e = new Date(d).getTimezoneOffset() / 60, d += 0 >= e ? "+".concat(A(-e), ":00") : "-".concat(A(e), ":00"));
        }
        d = Date.parse(d);
        r(d) || (a = a.split("-"), d = Date.UTC(H(a[0]), H(a[1]) - 1, H(a[2])));
        c && b && r(d) && (d += c.getTimezoneOffset(d));
        return d;
      };
      v.prototype.drawInput = function (a) {
        function b() {
          var b = n.maxInput,
            c = n.minInput,
            e = d.xAxis[0],
            f = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : e,
            t = f.dataMin;
          f = f.dataMax;
          var q = n.getInputValue(a);
          q !== Number(m.getAttribute("data-hc-time-previous")) && r(q) && (m.setAttribute("data-hc-time-previous", q), p && b && r(t) ? q > Number(b.getAttribute("data-hc-time")) ? q = void 0 : q < t && (q = t) : c && r(f) && (q < Number(c.getAttribute("data-hc-time")) ? q = void 0 : q > f && (q = f)), "undefined" !== typeof q && e.setExtremes(p ? q : e.min, p ? e.max : q, void 0, void 0, {
            trigger: "rangeSelectorInput"
          }));
        }
        var d = this.chart,
          e = this.div,
          f = this.inputGroup,
          n = this,
          g = d.renderer.style || {},
          h = d.renderer,
          v = d.options.rangeSelector,
          p = "min" === a,
          G = z.lang[p ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
        G = h.label(G, 0).addClass("highcharts-range-label").attr({
          padding: G ? 2 : 0,
          height: G ? v.inputBoxHeight : 0
        }).add(f);
        h = h.label("", 0).addClass("highcharts-range-input").attr({
          padding: 2,
          width: v.inputBoxWidth,
          height: v.inputBoxHeight,
          "text-align": "center"
        }).on("click", function () {
          n.showInput(a);
          n[a + "Input"].focus();
        });
        d.styledMode || h.attr({
          stroke: v.inputBoxBorderColor,
          "stroke-width": 1
        });
        h.add(f);
        var m = k("input", {
          name: a,
          className: "highcharts-range-selector"
        }, void 0, e);
        m.setAttribute("type", u(v.inputDateFormat || "%b %e, %Y"));
        d.styledMode || (G.css(E(g, v.labelStyle)), h.css(E({
          color: "#333333"
        }, g, v.inputStyle)), w(m, c({
          position: "absolute",
          border: 0,
          boxShadow: "0 0 15px rgba(0,0,0,0.3)",
          width: "1px",
          height: "1px",
          padding: 0,
          textAlign: "center",
          fontSize: g.fontSize,
          fontFamily: g.fontFamily,
          top: "-9999em"
        }, v.inputStyle)));
        m.onfocus = function () {
          n.showInput(a);
        };
        m.onblur = function () {
          m === l.doc.activeElement && b();
          n.hideInput(a);
          n.setInputValue(a);
          m.blur();
        };
        var C = !1;
        m.onchange = function () {
          C || (b(), n.hideInput(a), m.blur());
        };
        m.onkeypress = function (a) {
          13 === a.keyCode && b();
        };
        m.onkeydown = function (a) {
          C = !0;
          38 !== a.keyCode && 40 !== a.keyCode || b();
        };
        m.onkeyup = function () {
          C = !1;
        };
        return {
          dateBox: h,
          input: m,
          label: G
        };
      };
      v.prototype.getPosition = function () {
        var a = this.chart,
          b = a.options.rangeSelector;
        a = "top" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;
        return {
          buttonTop: a + b.buttonPosition.y,
          inputTop: a + b.inputPosition.y - 10
        };
      };
      v.prototype.getYTDExtremes = function (a, b, c) {
        var d = this.chart.time,
          e = new d.Date(a),
          f = d.get("FullYear", e);
        c = c ? d.Date.UTC(f, 0, 1) : +new d.Date(f, 0, 1);
        b = Math.max(b, c);
        e = e.getTime();
        return {
          max: Math.min(a || e, e),
          min: b
        };
      };
      v.prototype.render = function (a, b) {
        var c = this.chart,
          d = c.renderer,
          e = c.container,
          n = c.options,
          q = n.rangeSelector,
          g = B(n.chart.style && n.chart.style.zIndex, 0) + 1;
        n = q.inputEnabled;
        if (!1 !== q.enabled) {
          this.rendered || (this.group = d.g("range-selector-group").attr({
            zIndex: 7
          }).add(), this.div = k("div", void 0, {
            position: "relative",
            height: 0,
            zIndex: g
          }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), n && (this.inputGroup = d.g("input-group").add(this.group), d = this.drawInput("min"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput("max"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));
          if (n && (this.setInputValue("min", a), this.setInputValue("max", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, f(a.dataMin) && f(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes("min", a.dataMin, Math.min(a.dataMax, this.getInputValue("max")) - c), this.setInputExtremes("max", Math.max(a.dataMin, this.getInputValue("min")) + c, a.dataMax)), this.inputGroup)) {
            var h = 0;
            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {
              if (a) {
                var b = a.getBBox().width;
                b && (a.attr({
                  x: h
                }), h += b + q.inputSpacing);
              }
            });
          }
          this.alignElements();
          this.rendered = !0;
        }
      };
      v.prototype.renderButtons = function () {
        var a = this,
          b = this.buttons,
          c = this.options,
          d = z.lang,
          f = this.chart.renderer,
          t = E(c.buttonTheme),
          h = t && t.states,
          v = t.width || 28;
        delete t.width;
        delete t.states;
        this.buttonGroup = f.g("range-selector-buttons").add(this.group);
        var r = this.dropdown = k("select", void 0, {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: 0,
          border: 0,
          top: "-9999em",
          cursor: "pointer",
          opacity: .0001
        }, this.div);
        g(r, "touchstart", function () {
          r.style.fontSize = "16px";
        });
        [[l.isMS ? "mouseover" : "mouseenter"], [l.isMS ? "mouseout" : "mouseleave"], ["change", "click"]].forEach(function (c) {
          var d = c[0],
            f = c[1];
          g(r, d, function () {
            var c = b[a.currentButtonIndex()];
            c && e(c.element, f || d);
          });
        });
        this.zoomText = f.label(d && d.rangeSelectorZoom || "", 0).attr({
          padding: c.buttonTheme.padding,
          height: c.buttonTheme.height,
          paddingLeft: 0,
          paddingRight: 0
        }).add(this.buttonGroup);
        this.chart.styledMode || (this.zoomText.css(c.labelStyle), t["stroke-width"] = B(t["stroke-width"], 0));
        k("option", {
          textContent: this.zoomText.textStr,
          disabled: !0
        }, void 0, r);
        this.buttonOptions.forEach(function (c, d) {
          k("option", {
            textContent: c.title || c.text
          }, void 0, r);
          b[d] = f.button(c.text, 0, 0, function (b) {
            var e = c.events && c.events.click,
              f;
            e && (f = e.call(c, b));
            !1 !== f && a.clickButton(d);
            a.isActive = !0;
          }, t, h && h.hover, h && h.select, h && h.disabled).attr({
            "text-align": "center",
            width: v
          }).add(a.buttonGroup);
          c.title && b[d].attr("title", c.title);
        });
      };
      v.prototype.alignElements = function () {
        var a = this,
          b = this.buttonGroup,
          c = this.buttons,
          d = this.chart,
          e = this.group,
          f = this.inputGroup,
          g = this.options,
          h = this.zoomText,
          k = d.options,
          v = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions;
        k = g.buttonPosition;
        var r = g.inputPosition,
          l = g.verticalAlign,
          m = function (b, c) {
            return v && a.titleCollision(d) && "top" === l && "right" === c.align && c.y - b.getBBox().height - 12 < (v.y || 0) + (v.height || 0) + d.spacing[0] ? -40 : 0;
          },
          p = d.plotLeft;
        if (e && k && r) {
          var w = k.x - d.spacing[3];
          if (b) {
            this.positionButtons();
            if (!this.initialButtonGroupWidth) {
              var C = 0;
              h && (C += h.getBBox().width + 5);
              c.forEach(function (a, b) {
                C += a.width;
                b !== c.length - 1 && (C += g.buttonSpacing);
              });
              this.initialButtonGroupWidth = C;
            }
            p -= d.spacing[3];
            this.updateButtonStates();
            h = m(b, k);
            this.alignButtonGroup(h);
            e.placed = b.placed = d.hasLoaded;
          }
          b = 0;
          f && (b = m(f, r), "left" === r.align ? w = p : "right" === r.align && (w = -Math.max(d.axisOffset[1], -b)), f.align({
            y: r.y,
            width: f.getBBox().width,
            align: r.align,
            x: r.x + w - 2
          }, !0, d.spacingBox), f.placed = d.hasLoaded);
          this.handleCollision(b);
          e.align({
            verticalAlign: l
          }, !0, d.spacingBox);
          f = e.alignAttr.translateY;
          b = e.getBBox().height + 20;
          m = 0;
          "bottom" === l && (m = (m = d.legend && d.legend.options) && "bottom" === m.verticalAlign && m.enabled && !m.floating ? d.legend.legendHeight + B(m.margin, 10) : 0, b = b + m - 20, m = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);
          if ("top" === l) g.floating && (m = 0), d.titleOffset && d.titleOffset[0] && (m = d.titleOffset[0]), m += d.margin[0] - d.spacing[0] || 0;else if ("middle" === l) if (r.y === k.y) m = f;else if (r.y || k.y) m = 0 > r.y || 0 > k.y ? m - Math.min(r.y, k.y) : f - b;
          e.translate(g.x, g.y + Math.floor(m));
          k = this.minInput;
          r = this.maxInput;
          f = this.dropdown;
          g.inputEnabled && k && r && (k.style.marginTop = e.translateY + "px", r.style.marginTop = e.translateY + "px");
          f && (f.style.marginTop = e.translateY + "px");
        }
      };
      v.prototype.alignButtonGroup = function (a, b) {
        var c = this.chart,
          d = this.buttonGroup,
          e = this.options.buttonPosition,
          f = c.plotLeft - c.spacing[3],
          n = e.x - c.spacing[3];
        "right" === e.align ? n += a - f : "center" === e.align && (n -= f / 2);
        d && d.align({
          y: e.y,
          width: B(b, this.initialButtonGroupWidth),
          align: e.align,
          x: n
        }, !0, c.spacingBox);
      };
      v.prototype.positionButtons = function () {
        var a = this.buttons,
          b = this.chart,
          c = this.options,
          d = this.zoomText,
          e = b.hasLoaded ? "animate" : "attr",
          f = c.buttonPosition,
          g = b = b.plotLeft;
        d && "hidden" !== d.visibility && (d[e]({
          x: B(b + f.x, b)
        }), g += f.x + d.getBBox().width + 5);
        d = 0;
        for (f = this.buttonOptions.length; d < f; ++d) if ("hidden" !== a[d].visibility) a[d][e]({
          x: g
        }), g += a[d].width + c.buttonSpacing;else a[d][e]({
          x: b
        });
      };
      v.prototype.handleCollision = function (a) {
        var b = this,
          c = this.chart,
          d = this.buttonGroup,
          e = this.inputGroup,
          f = this.options,
          n = f.buttonPosition,
          g = f.dropdown,
          k = f.inputPosition;
        f = function () {
          var a = 0;
          b.buttons.forEach(function (b) {
            b = b.getBBox();
            b.width > a && (a = b.width);
          });
          return a;
        };
        var h = function (b) {
            if (e && d) {
              var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,
                f = e.alignOptions.width,
                g = d.alignAttr.translateX + d.getBBox().x;
              return g + b > c && c + f > g && n.y < k.y + e.getBBox().height;
            }
            return !1;
          },
          r = function () {
            e && d && e.attr({
              translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),
              translateY: e.alignAttr.translateY + d.getBBox().height + 10
            });
          };
        if (d) {
          if ("always" === g) {
            this.collapseButtons(a);
            h(f()) && r();
            return;
          }
          "never" === g && this.expandButtons();
        }
        e && d ? k.align === n.align || h(this.initialButtonGroupWidth + 20) ? "responsive" === g ? (this.collapseButtons(a), h(f()) && r()) : r() : "responsive" === g && this.expandButtons() : d && "responsive" === g && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());
      };
      v.prototype.collapseButtons = function (a) {
        var b = this.buttons,
          c = this.buttonOptions,
          d = this.chart,
          e = this.dropdown,
          f = this.options,
          n = this.zoomText,
          g = d.userOptions.rangeSelector && d.userOptions.rangeSelector.buttonTheme || {},
          k = function (a) {
            return {
              text: a ? "" + a + " \u25be" : "\u25be",
              width: "auto",
              paddingLeft: B(f.buttonTheme.paddingLeft, g.padding, 8),
              paddingRight: B(f.buttonTheme.paddingRight, g.padding, 8)
            };
          };
        n && n.hide();
        var h = !1;
        c.forEach(function (a, c) {
          c = b[c];
          2 !== c.state ? c.hide() : (c.show(), c.attr(k(a.text)), h = !0);
        });
        h || (e && (e.selectedIndex = 0), b[0].show(), b[0].attr(k(this.zoomText && this.zoomText.textStr)));
        c = f.buttonPosition.align;
        this.positionButtons();
        "right" !== c && "center" !== c || this.alignButtonGroup(a, b[this.currentButtonIndex()].getBBox().width);
        this.showDropdown();
      };
      v.prototype.expandButtons = function () {
        var a = this.buttons,
          b = this.buttonOptions,
          c = this.options,
          d = this.zoomText;
        this.hideDropdown();
        d && d.show();
        b.forEach(function (b, d) {
          d = a[d];
          d.show();
          d.attr({
            text: b.text,
            width: c.buttonTheme.width || 28,
            paddingLeft: B(c.buttonTheme.paddingLeft, "unset"),
            paddingRight: B(c.buttonTheme.paddingRight, "unset")
          });
          2 > d.state && d.setState(0);
        });
        this.positionButtons();
      };
      v.prototype.currentButtonIndex = function () {
        var a = this.dropdown;
        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;
      };
      v.prototype.showDropdown = function () {
        var a = this.buttonGroup,
          b = this.buttons,
          c = this.chart,
          d = this.dropdown;
        if (a && d) {
          var e = a.translateX;
          a = a.translateY;
          b = b[this.currentButtonIndex()].getBBox();
          w(d, {
            left: c.plotLeft + e + "px",
            top: a + .5 + "px",
            width: b.width + "px",
            height: b.height + "px"
          });
          this.hasVisibleDropdown = !0;
        }
      };
      v.prototype.hideDropdown = function () {
        var a = this.dropdown;
        a && (w(a, {
          top: "-9999em",
          width: "1px",
          height: "1px"
        }), this.hasVisibleDropdown = !1);
      };
      v.prototype.getHeight = function () {
        var a = this.options,
          b = this.group,
          c = a.y,
          d = a.buttonPosition.y,
          e = a.inputPosition.y;
        if (a.height) return a.height;
        this.alignElements();
        a = b ? b.getBBox(!0).height + 13 + c : 0;
        b = Math.min(e, d);
        if (0 > e && 0 > d || 0 < e && 0 < d) a += Math.abs(b);
        return a;
      };
      v.prototype.titleCollision = function (a) {
        return !(a.options.title.text || a.options.subtitle.text);
      };
      v.prototype.update = function (a) {
        var b = this.chart;
        E(!0, b.options.rangeSelector, a);
        this.destroy();
        this.init(b);
        this.render();
      };
      v.prototype.destroy = function () {
        var a = this,
          c = a.minInput,
          e = a.maxInput;
        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {
          return a();
        }), a.eventsToUnbind = void 0);
        d(a.buttons);
        c && (c.onfocus = c.onblur = c.onchange = null);
        e && (e.onfocus = e.onblur = e.onchange = null);
        I(a, function (c, d) {
          c && "chart" !== d && (c instanceof m ? c.destroy() : c instanceof window.HTMLElement && b(c));
          c !== v.prototype[d] && (a[d] = null);
        }, this);
      };
      return v;
    }();
    c(h.prototype, {
      defaultButtons: [{
        type: "month",
        count: 1,
        text: "1m",
        title: "View 1 month"
      }, {
        type: "month",
        count: 3,
        text: "3m",
        title: "View 3 months"
      }, {
        type: "month",
        count: 6,
        text: "6m",
        title: "View 6 months"
      }, {
        type: "ytd",
        text: "YTD",
        title: "View year to date"
      }, {
        type: "year",
        count: 1,
        text: "1y",
        title: "View 1 year"
      }, {
        type: "all",
        text: "All",
        title: "View all"
      }],
      inputTypeFormats: {
        "datetime-local": "%Y-%m-%dT%H:%M:%S",
        date: "%Y-%m-%d",
        time: "%H:%M:%S"
      }
    });
    "";
    return h;
  });
  A(a, "Accessibility/Components/RangeSelectorComponent.js", [a["Stock/RangeSelector/RangeSelector.js"], a["Accessibility/AccessibilityComponent.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/Announcer.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Core/Utilities.js"]], function (a, h, l, x, m, p) {
    var u = this && this.__extends || function () {
        var a = function (d, b) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, b) {
            a.__proto__ = b;
          } || function (a, b) {
            for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);
          };
          return a(d, b);
        };
        return function (d, b) {
          function c() {
            this.constructor = d;
          }
          a(d, b);
          d.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c());
        };
      }(),
      z = l.unhideChartElementFromAT,
      g = l.getAxisRangeDescription,
      k = p.addEvent,
      w = p.attr;
    h = function (a) {
      function d() {
        var b = null !== a && a.apply(this, arguments) || this;
        b.announcer = void 0;
        return b;
      }
      u(d, a);
      d.prototype.init = function () {
        this.announcer = new x(this.chart, "polite");
      };
      d.prototype.onChartUpdate = function () {
        var a = this.chart,
          c = this,
          d = a.rangeSelector;
        d && (this.updateSelectorVisibility(), this.setDropdownAttrs(), d.buttons && d.buttons.length && d.buttons.forEach(function (a) {
          c.setRangeButtonAttrs(a);
        }), d.maxInput && d.minInput && ["minInput", "maxInput"].forEach(function (b, e) {
          if (b = d[b]) z(a, b), c.setRangeInputAttrs(b, "accessibility.rangeSelector." + (e ? "max" : "min") + "InputLabel");
        }));
      };
      d.prototype.updateSelectorVisibility = function () {
        var a = this.chart,
          c = a.rangeSelector,
          d = c && c.dropdown,
          f = c && c.buttons || [];
        c && c.hasVisibleDropdown && d ? (z(a, d), f.forEach(function (a) {
          return a.element.setAttribute("aria-hidden", !0);
        })) : (d && d.setAttribute("aria-hidden", !0), f.forEach(function (b) {
          return z(a, b.element);
        }));
      };
      d.prototype.setDropdownAttrs = function () {
        var a = this.chart,
          c = a.rangeSelector && a.rangeSelector.dropdown;
        c && (a = a.langFormat("accessibility.rangeSelector.dropdownLabel", {
          rangeTitle: a.options.lang.rangeSelectorZoom
        }), c.setAttribute("aria-label", a), c.setAttribute("tabindex", -1));
      };
      d.prototype.setRangeButtonAttrs = function (a) {
        w(a.element, {
          tabindex: -1,
          role: "button"
        });
      };
      d.prototype.setRangeInputAttrs = function (a, c) {
        var b = this.chart;
        w(a, {
          tabindex: -1,
          "aria-label": b.langFormat(c, {
            chart: b
          })
        });
      };
      d.prototype.onButtonNavKbdArrowKey = function (a, c) {
        var b = a.response,
          d = this.keyCodes,
          f = this.chart,
          g = f.options.accessibility.keyboardNavigation.wrapAround;
        c = c === d.left || c === d.up ? -1 : 1;
        return f.highlightRangeSelectorButton(f.highlightedRangeSelectorItemIx + c) ? b.success : g ? (a.init(c), b.success) : b[0 < c ? "next" : "prev"];
      };
      d.prototype.onButtonNavKbdClick = function (a) {
        a = a.response;
        var b = this.chart;
        3 !== b.oldRangeSelectorItemState && this.fakeClickEvent(b.rangeSelector.buttons[b.highlightedRangeSelectorItemIx].element);
        return a.success;
      };
      d.prototype.onAfterBtnClick = function () {
        var a = this.chart,
          c = g(a.xAxis[0]);
        (a = a.langFormat("accessibility.rangeSelector.clickButtonAnnouncement", {
          chart: a,
          axisRangeDescription: c
        })) && this.announcer.announce(a);
      };
      d.prototype.onInputKbdMove = function (a) {
        var b = this.chart,
          d = b.rangeSelector,
          f = b.highlightedInputRangeIx = (b.highlightedInputRangeIx || 0) + a;
        1 < f || 0 > f ? b.accessibility && (b.accessibility.keyboardNavigation.tabindexContainer.focus(), b.accessibility.keyboardNavigation.move(a)) : d && (a = d[f ? "maxDateBox" : "minDateBox"], d = d[f ? "maxInput" : "minInput"], a && d && b.setFocusToElement(a, d));
      };
      d.prototype.onInputNavInit = function (a) {
        var b = this,
          d = this,
          f = this.chart,
          g = 0 < a ? 0 : 1,
          h = f.rangeSelector,
          m = h && h[g ? "maxDateBox" : "minDateBox"];
        a = h && h.minInput;
        h = h && h.maxInput;
        f.highlightedInputRangeIx = g;
        if (m && a && h) {
          f.setFocusToElement(m, g ? h : a);
          this.removeInputKeydownHandler && this.removeInputKeydownHandler();
          f = function (a) {
            (a.which || a.keyCode) === b.keyCodes.tab && (a.preventDefault(), a.stopPropagation(), d.onInputKbdMove(a.shiftKey ? -1 : 1));
          };
          var l = k(a, "keydown", f),
            p = k(h, "keydown", f);
          this.removeInputKeydownHandler = function () {
            l();
            p();
          };
        }
      };
      d.prototype.onInputNavTerminate = function () {
        var a = this.chart.rangeSelector || {};
        a.maxInput && a.hideInput("max");
        a.minInput && a.hideInput("min");
        this.removeInputKeydownHandler && (this.removeInputKeydownHandler(), delete this.removeInputKeydownHandler);
      };
      d.prototype.initDropdownNav = function () {
        var a = this,
          c = this.chart,
          d = c.rangeSelector,
          f = d && d.dropdown;
        d && f && (c.setFocusToElement(d.buttonGroup, f), this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler(), this.removeDropdownKeydownHandler = k(f, "keydown", function (b) {
          var d = c.accessibility;
          (b.which || b.keyCode) === a.keyCodes.tab && (b.preventDefault(), b.stopPropagation(), d && (d.keyboardNavigation.tabindexContainer.focus(), d.keyboardNavigation.move(b.shiftKey ? -1 : 1)));
        }));
      };
      d.prototype.getRangeSelectorButtonNavigation = function () {
        var a = this.chart,
          c = this.keyCodes,
          d = this;
        return new m(a, {
          keyCodeMap: [[[c.left, c.right, c.up, c.down], function (a) {
            return d.onButtonNavKbdArrowKey(this, a);
          }], [[c.enter, c.space], function () {
            return d.onButtonNavKbdClick(this);
          }]],
          validate: function () {
            return !!(a.rangeSelector && a.rangeSelector.buttons && a.rangeSelector.buttons.length);
          },
          init: function (b) {
            var c = a.rangeSelector;
            c && c.hasVisibleDropdown ? d.initDropdownNav() : c && (c = c.buttons.length - 1, a.highlightRangeSelectorButton(0 < b ? 0 : c));
          },
          terminate: function () {
            d.removeDropdownKeydownHandler && (d.removeDropdownKeydownHandler(), delete d.removeDropdownKeydownHandler);
          }
        });
      };
      d.prototype.getRangeSelectorInputNavigation = function () {
        var a = this.chart,
          c = this;
        return new m(a, {
          keyCodeMap: [],
          validate: function () {
            return !!(a.rangeSelector && a.rangeSelector.inputGroup && "hidden" !== a.rangeSelector.inputGroup.element.style.visibility && !1 !== a.options.rangeSelector.inputEnabled && a.rangeSelector.minInput && a.rangeSelector.maxInput);
          },
          init: function (a) {
            c.onInputNavInit(a);
          },
          terminate: function () {
            c.onInputNavTerminate();
          }
        });
      };
      d.prototype.getKeyboardNavigation = function () {
        return [this.getRangeSelectorButtonNavigation(), this.getRangeSelectorInputNavigation()];
      };
      d.prototype.destroy = function () {
        this.removeDropdownKeydownHandler && this.removeDropdownKeydownHandler();
        this.removeInputKeydownHandler && this.removeInputKeydownHandler();
        this.announcer && this.announcer.destroy();
      };
      return d;
    }(h);
    (function (f) {
      function d(a) {
        var b = this.rangeSelector && this.rangeSelector.buttons || [],
          c = this.highlightedRangeSelectorItemIx,
          d = this.rangeSelector && this.rangeSelector.selected;
        "undefined" !== typeof c && b[c] && c !== d && b[c].setState(this.oldRangeSelectorItemState || 0);
        this.highlightedRangeSelectorItemIx = a;
        return b[a] ? (this.setFocusToElement(b[a].box, b[a].element), a !== d && (this.oldRangeSelectorItemState = b[a].state, b[a].setState(1)), !0) : !1;
      }
      function b() {
        var a = this.chart.accessibility;
        if (a && a.components.rangeSelector) return a.components.rangeSelector.onAfterBtnClick();
      }
      var c = [];
      f.compose = function (e, f) {
        -1 === c.indexOf(e) && (c.push(e), e.prototype.highlightRangeSelectorButton = d);
        -1 === c.indexOf(f) && (c.push(f), k(a, "afterBtnClick", b));
      };
    })(h || (h = {}));
    return h;
  });
  A(a, "Accessibility/Components/SeriesComponent/ForcedMarkers.js", [a["Core/Utilities.js"]], function (a) {
    var h = a.addEvent,
      l = a.merge,
      u;
    (function (a) {
      function m(a) {
        l(!0, a, {
          marker: {
            enabled: !0,
            states: {
              normal: {
                opacity: 0
              }
            }
          }
        });
      }
      function u(a) {
        return a.marker.states && a.marker.states.normal && a.marker.states.normal.opacity;
      }
      function x() {
        if (this.chart.styledMode) {
          if (this.markerGroup) this.markerGroup[this.a11yMarkersForced ? "addClass" : "removeClass"]("highcharts-a11y-markers-hidden");
          this._hasPointMarkers && this.points && this.points.length && this.points.forEach(function (a) {
            a.graphic && (a.graphic[a.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-hidden"), a.graphic[!1 === a.hasForcedA11yMarker ? "addClass" : "removeClass"]("highcharts-a11y-marker-visible"));
          });
        }
      }
      function g(a) {
        this.resetA11yMarkerOptions = l(a.options.marker || {}, this.userOptions.marker || {});
      }
      function k() {
        var a = this.options,
          d = !1 !== (this.options.accessibility && this.options.accessibility.enabled);
        if (d = this.chart.options.accessibility.enabled && d) d = this.chart.options.accessibility, d = this.points.length < d.series.pointDescriptionEnabledThreshold || !1 === d.series.pointDescriptionEnabledThreshold;
        if (d) {
          if (a.marker && !1 === a.marker.enabled && (this.a11yMarkersForced = !0, m(this.options)), this._hasPointMarkers && this.points && this.points.length) for (a = this.points.length; a--;) {
            d = this.points[a];
            var b = d.options,
              c = d.hasForcedA11yMarker;
            delete d.hasForcedA11yMarker;
            b.marker && (c = c && 0 === u(b), b.marker.enabled && !c ? (l(!0, b.marker, {
              states: {
                normal: {
                  opacity: u(b) || 1
                }
              }
            }), d.hasForcedA11yMarker = !1) : !1 === b.marker.enabled && (m(b), d.hasForcedA11yMarker = !0));
          }
        } else this.a11yMarkersForced && (delete this.a11yMarkersForced, (a = this.resetA11yMarkerOptions) && this.update({
          marker: {
            enabled: a.enabled,
            states: {
              normal: {
                opacity: a.states && a.states.normal && a.states.normal.opacity
              }
            }
          }
        }), delete this.resetA11yMarkerOptions);
      }
      var w = [];
      a.compose = function (a) {
        -1 === w.indexOf(a) && (w.push(a), h(a, "afterSetOptions", g), h(a, "render", k), h(a, "afterRender", x));
      };
    })(u || (u = {}));
    return u;
  });
  A(a, "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js", [a["Core/Series/Point.js"], a["Core/Series/Series.js"], a["Core/Series/SeriesRegistry.js"], a["Core/Globals.js"], a["Core/Utilities.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Accessibility/Utils/EventProvider.js"], a["Accessibility/Utils/ChartUtilities.js"]], function (a, h, l, x, m, p, A, z) {
    function g(a) {
      var b = a.index,
        c = a.series.points,
        d = c.length;
      if (c[b] !== a) for (; d--;) {
        if (c[d] === a) return d;
      } else return b;
    }
    function k(a) {
      var b = a.chart.options.accessibility.keyboardNavigation.seriesNavigation,
        c = a.options.accessibility || {},
        d = c.keyboardNavigation;
      return d && !1 === d.enabled || !1 === c.enabled || !1 === a.options.enableMouseTracking || !a.visible || b.pointNavigationEnabledThreshold && b.pointNavigationEnabledThreshold <= a.points.length;
    }
    function w(a) {
      var b = a.series.chart.options.accessibility,
        c = a.options.accessibility && !1 === a.options.accessibility.enabled;
      return a.isNull && b.keyboardNavigation.seriesNavigation.skipNullPoints || !1 === a.visible || !1 === a.isInside || c || k(a.series);
    }
    function f(a) {
      a = a.series || [];
      for (var b = a.length, c = 0; c < b; ++c) if (!k(a[c])) {
        a: {
          var d = a[c].points || [];
          for (var e = d.length, f = 0; f < e; ++f) if (!w(d[f])) {
            d = d[f];
            break a;
          }
          d = null;
        }
        if (d) return d;
      }
      return null;
    }
    function d(a) {
      for (var b = a.series.length, c = !1; b-- && !(a.highlightedPoint = a.series[b].points[a.series[b].points.length - 1], c = a.series[b].highlightNextValidPoint()););
      return c;
    }
    function b(a) {
      delete a.highlightedPoint;
      return (a = f(a)) ? a.highlight() : !1;
    }
    var c = l.seriesTypes,
      e = x.doc,
      r = m.defined,
      u = m.fireEvent,
      K = z.getPointFromXY,
      J = z.getSeriesFromName,
      B = z.scrollToPoint;
    l = function () {
      function c(a, b) {
        this.keyCodes = b;
        this.chart = a;
      }
      c.prototype.init = function () {
        var b = this,
          c = this.chart,
          d = this.eventProvider = new A();
        d.addEvent(h, "destroy", function () {
          return b.onSeriesDestroy(this);
        });
        d.addEvent(c, "afterApplyDrilldown", function () {
          var a = f(this);
          a && a.highlight(!1);
        });
        d.addEvent(c, "drilldown", function (a) {
          a = a.point;
          var c = a.series;
          b.lastDrilledDownPoint = {
            x: a.x,
            y: a.y,
            seriesName: c ? c.name : ""
          };
        });
        d.addEvent(c, "drillupall", function () {
          setTimeout(function () {
            b.onDrillupAll();
          }, 10);
        });
        d.addEvent(a, "afterSetState", function () {
          var a = this.graphic && this.graphic.element,
            b = e.activeElement,
            d = b && b.getAttribute("class");
          d = d && -1 < d.indexOf("highcharts-a11y-proxy-button");
          c.highlightedPoint === this && b !== a && !d && a && a.focus && a.focus();
        });
      };
      c.prototype.onDrillupAll = function () {
        var a = this.lastDrilledDownPoint,
          b = this.chart,
          c = a && J(b, a.seriesName),
          d;
        a && c && r(a.x) && r(a.y) && (d = K(c, a.x, a.y));
        d = d || f(b);
        b.container && b.container.focus();
        d && d.highlight && d.highlight(!1);
      };
      c.prototype.getKeyboardNavigationHandler = function () {
        var a = this,
          c = this.keyCodes,
          e = this.chart,
          g = e.inverted;
        return new p(e, {
          keyCodeMap: [[g ? [c.up, c.down] : [c.left, c.right], function (b) {
            return a.onKbdSideways(this, b);
          }], [g ? [c.left, c.right] : [c.up, c.down], function (b) {
            return a.onKbdVertical(this, b);
          }], [[c.enter, c.space], function (a, b) {
            if (a = e.highlightedPoint) b.point = a, u(a.series, "click", b), a.firePointEvent("click");
            return this.response.success;
          }], [[c.home], function () {
            b(e);
            return this.response.success;
          }], [[c.end], function () {
            d(e);
            return this.response.success;
          }], [[c.pageDown, c.pageUp], function (a) {
            e.highlightAdjacentSeries(a === c.pageDown);
            return this.response.success;
          }]],
          init: function () {
            return a.onHandlerInit(this);
          },
          validate: function () {
            return !!f(e);
          },
          terminate: function () {
            return a.onHandlerTerminate();
          }
        });
      };
      c.prototype.onKbdSideways = function (a, b) {
        var c = this.keyCodes;
        return this.attemptHighlightAdjacentPoint(a, b === c.right || b === c.down);
      };
      c.prototype.onHandlerInit = function (a) {
        var c = this.chart;
        c.options.accessibility.keyboardNavigation.seriesNavigation.rememberPointFocus && c.highlightedPoint ? c.highlightedPoint.highlight() : b(c);
        return a.response.success;
      };
      c.prototype.onKbdVertical = function (a, b) {
        var c = this.chart,
          d = this.keyCodes;
        b = b === d.down || b === d.right;
        d = c.options.accessibility.keyboardNavigation.seriesNavigation;
        if (d.mode && "serialize" === d.mode) return this.attemptHighlightAdjacentPoint(a, b);
        c[c.highlightedPoint && c.highlightedPoint.series.keyboardMoveVertical ? "highlightAdjacentPointVertical" : "highlightAdjacentSeries"](b);
        return a.response.success;
      };
      c.prototype.onHandlerTerminate = function () {
        var a = this.chart,
          b = a.options.accessibility.keyboardNavigation;
        a.tooltip && a.tooltip.hide(0);
        var c = a.highlightedPoint && a.highlightedPoint.series;
        if (c && c.onMouseOut) c.onMouseOut();
        if (a.highlightedPoint && a.highlightedPoint.onMouseOut) a.highlightedPoint.onMouseOut();
        b.seriesNavigation.rememberPointFocus || delete a.highlightedPoint;
      };
      c.prototype.attemptHighlightAdjacentPoint = function (a, c) {
        var e = this.chart,
          f = e.options.accessibility.keyboardNavigation.wrapAround;
        return e.highlightAdjacentPoint(c) ? a.response.success : f && (c ? b(e) : d(e)) ? a.response.success : a.response[c ? "next" : "prev"];
      };
      c.prototype.onSeriesDestroy = function (a) {
        var b = this.chart;
        b.highlightedPoint && b.highlightedPoint.series === a && (delete b.highlightedPoint, b.focusElement && b.focusElement.removeFocusBorder());
      };
      c.prototype.destroy = function () {
        this.eventProvider.removeAddedEvents();
      };
      return c;
    }();
    (function (a) {
      function b(a) {
        var b = this.series,
          c = this.highlightedPoint,
          d = c && g(c) || 0,
          e = c && c.series.points || [],
          f = this.series && this.series[this.series.length - 1];
        f = f && f.points && f.points[f.points.length - 1];
        if (!b[0] || !b[0].points) return !1;
        if (c) {
          if (b = b[c.series.index + (a ? 1 : -1)], d = e[d + (a ? 1 : -1)], !d && b && (d = b.points[a ? 0 : b.points.length - 1]), !d) return !1;
        } else d = a ? b[0].points[0] : f;
        return w(d) ? (b = d.series, k(b) ? this.highlightedPoint = a ? b.points[b.points.length - 1] : b.points[0] : this.highlightedPoint = d, this.highlightAdjacentPoint(a)) : d.highlight();
      }
      function d(a) {
        var b = this.highlightedPoint,
          c = Infinity,
          d;
        if (!r(b.plotX) || !r(b.plotY)) return !1;
        this.series.forEach(function (e) {
          k(e) || e.points.forEach(function (f) {
            if (r(f.plotY) && r(f.plotX) && f !== b) {
              var g = f.plotY - b.plotY,
                h = Math.abs(f.plotX - b.plotX);
              h = Math.abs(g) * Math.abs(g) + h * h * 4;
              e.yAxis && e.yAxis.reversed && (g *= -1);
              !(0 >= g && a || 0 <= g && !a || 5 > h || w(f)) && h < c && (c = h, d = f);
            }
          });
        });
        return d ? d.highlight() : !1;
      }
      function e(a) {
        var b = this.highlightedPoint,
          c = this.series && this.series[this.series.length - 1],
          d = c && c.points && c.points[c.points.length - 1];
        if (!this.highlightedPoint) return c = a ? this.series && this.series[0] : c, (d = a ? c && c.points && c.points[0] : d) ? d.highlight() : !1;
        c = this.series[b.series.index + (a ? -1 : 1)];
        if (!c) return !1;
        d = f(b, c, 4);
        if (!d) return !1;
        if (k(c)) return d.highlight(), a = this.highlightAdjacentSeries(a), a ? a : (b.highlight(), !1);
        d.highlight();
        return d.series.highlightNextValidPoint();
      }
      function f(a, b, c, d) {
        var e = Infinity,
          f = b.points.length,
          g = function (a) {
            return !(r(a.plotX) && r(a.plotY));
          };
        if (!g(a)) {
          for (; f--;) {
            var h = b.points[f];
            if (!g(h) && (h = (a.plotX - h.plotX) * (a.plotX - h.plotX) * (c || 1) + (a.plotY - h.plotY) * (a.plotY - h.plotY) * (d || 1), h < e)) {
              e = h;
              var k = f;
            }
          }
          return r(k) ? b.points[k] : void 0;
        }
      }
      function h(a) {
        void 0 === a && (a = !0);
        var b = this.series.chart;
        if (!this.isNull && a) this.onMouseOver();else b.tooltip && b.tooltip.hide(0);
        B(this);
        this.graphic && (b.setFocusToElement(this.graphic), !a && b.focusElement && b.focusElement.removeFocusBorder());
        b.highlightedPoint = this;
        return this;
      }
      function m() {
        var a = this.chart.highlightedPoint,
          b = (a && a.series) === this ? g(a) : 0;
        a = this.points;
        var c = a.length;
        if (a && c) {
          for (var d = b; d < c; ++d) if (!w(a[d])) return a[d].highlight();
          for (; 0 <= b; --b) if (!w(a[b])) return a[b].highlight();
        }
        return !1;
      }
      var l = [];
      a.compose = function (a, f, g) {
        -1 === l.indexOf(a) && (l.push(a), a = a.prototype, a.highlightAdjacentPoint = b, a.highlightAdjacentPointVertical = d, a.highlightAdjacentSeries = e);
        -1 === l.indexOf(f) && (l.push(f), f.prototype.highlight = h);
        -1 === l.indexOf(g) && (l.push(g), f = g.prototype, f.keyboardMoveVertical = !0, ["column", "gantt", "pie"].forEach(function (a) {
          c[a] && (c[a].prototype.keyboardMoveVertical = !1);
        }), f.highlightNextValidPoint = m);
      };
    })(l || (l = {}));
    return l;
  });
  A(a, "Accessibility/Components/SeriesComponent/SeriesComponent.js", [a["Accessibility/AccessibilityComponent.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Components/SeriesComponent/ForcedMarkers.js"], a["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"], a["Accessibility/Components/SeriesComponent/SeriesDescriber.js"], a["Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js"], a["Core/Tooltip.js"]], function (a, h, l, x, m, p, A) {
    var u = this && this.__extends || function () {
        var a = function (f, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
          };
          return a(f, d);
        };
        return function (f, d) {
          function b() {
            this.constructor = f;
          }
          a(f, d);
          f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
        };
      }(),
      g = h.hideSeriesFromAT,
      k = m.describeSeries;
    return function (a) {
      function f() {
        return null !== a && a.apply(this, arguments) || this;
      }
      u(f, a);
      f.compose = function (a, b, c) {
        x.compose(c);
        l.compose(c);
        p.compose(a, b, c);
      };
      f.prototype.init = function () {
        this.newDataAnnouncer = new x(this.chart);
        this.newDataAnnouncer.init();
        this.keyboardNavigation = new p(this.chart, this.keyCodes);
        this.keyboardNavigation.init();
        this.hideTooltipFromATWhenShown();
        this.hideSeriesLabelsFromATWhenShown();
      };
      f.prototype.hideTooltipFromATWhenShown = function () {
        var a = this;
        this.addEvent(A, "refresh", function () {
          this.chart === a.chart && this.label && this.label.element && this.label.element.setAttribute("aria-hidden", !0);
        });
      };
      f.prototype.hideSeriesLabelsFromATWhenShown = function () {
        this.addEvent(this.chart, "afterDrawSeriesLabels", function () {
          this.series.forEach(function (a) {
            a.labelBySeries && a.labelBySeries.attr("aria-hidden", !0);
          });
        });
      };
      f.prototype.onChartRender = function () {
        this.chart.series.forEach(function (a) {
          !1 !== (a.options.accessibility && a.options.accessibility.enabled) && a.visible ? k(a) : g(a);
        });
      };
      f.prototype.getKeyboardNavigation = function () {
        return this.keyboardNavigation.getKeyboardNavigationHandler();
      };
      f.prototype.destroy = function () {
        this.newDataAnnouncer.destroy();
        this.keyboardNavigation.destroy();
      };
      return f;
    }(a);
  });
  A(a, "Accessibility/Components/ZoomComponent.js", [a["Accessibility/AccessibilityComponent.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Core/Utilities.js"]], function (a, h, l, x, m) {
    var p = this && this.__extends || function () {
        var a = function (f, d) {
          a = Object.setPrototypeOf || {
            __proto__: []
          } instanceof Array && function (a, c) {
            a.__proto__ = c;
          } || function (a, c) {
            for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);
          };
          return a(f, d);
        };
        return function (f, d) {
          function b() {
            this.constructor = f;
          }
          a(f, d);
          f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());
        };
      }(),
      u = h.unhideChartElementFromAT,
      z = l.getFakeMouseEvent,
      g = m.attr,
      k = m.pick;
    return function (a) {
      function f() {
        var d = null !== a && a.apply(this, arguments) || this;
        d.focusedMapNavButtonIx = -1;
        return d;
      }
      p(f, a);
      f.prototype.init = function () {
        var a = this,
          b = this.chart;
        this.proxyProvider.addGroup("zoom", "div");
        ["afterShowResetZoom", "afterApplyDrilldown", "drillupall"].forEach(function (c) {
          a.addEvent(b, c, function () {
            a.updateProxyOverlays();
          });
        });
      };
      f.prototype.onChartUpdate = function () {
        var a = this.chart,
          b = this;
        a.mapNavigation && a.mapNavigation.navButtons.forEach(function (c, d) {
          u(a, c.element);
          b.setMapNavButtonAttrs(c.element, "accessibility.zoom.mapZoom" + (d ? "Out" : "In"));
        });
      };
      f.prototype.setMapNavButtonAttrs = function (a, b) {
        var c = this.chart;
        b = c.langFormat(b, {
          chart: c
        });
        g(a, {
          tabindex: -1,
          role: "button",
          "aria-label": b
        });
      };
      f.prototype.onChartRender = function () {
        this.updateProxyOverlays();
      };
      f.prototype.updateProxyOverlays = function () {
        var a = this.chart;
        this.proxyProvider.clearGroup("zoom");
        a.resetZoomButton && this.createZoomProxyButton(a.resetZoomButton, "resetZoomProxyButton", a.langFormat("accessibility.zoom.resetZoomButton", {
          chart: a
        }));
        a.drillUpButton && a.breadcrumbs && a.breadcrumbs.list && this.createZoomProxyButton(a.drillUpButton, "drillUpProxyButton", a.langFormat("accessibility.drillUpButton", {
          chart: a,
          buttonText: a.breadcrumbs.getButtonText(a.breadcrumbs.list[a.breadcrumbs.list.length - 1])
        }));
      };
      f.prototype.createZoomProxyButton = function (a, b, c) {
        this[b] = this.proxyProvider.addProxyElement("zoom", {
          click: a
        }, {
          "aria-label": c,
          tabindex: -1
        });
      };
      f.prototype.getMapZoomNavigation = function () {
        var a = this.keyCodes,
          b = this.chart,
          c = this;
        return new x(b, {
          keyCodeMap: [[[a.up, a.down, a.left, a.right], function (a) {
            return c.onMapKbdArrow(this, a);
          }], [[a.tab], function (a, b) {
            return c.onMapKbdTab(this, b);
          }], [[a.space, a.enter], function () {
            return c.onMapKbdClick(this);
          }]],
          validate: function () {
            return !!(b.mapView && b.mapNavigation && b.mapNavigation.navButtons.length);
          },
          init: function (a) {
            return c.onMapNavInit(a);
          }
        });
      };
      f.prototype.onMapKbdArrow = function (a, b) {
        var c = this.chart,
          d = this.keyCodes,
          f = c.container,
          g = b === d.up || b === d.down;
        b = (g ? c.plotHeight : c.plotWidth) / 10 * (b === d.left || b === d.up ? 1 : -1);
        d = 10 * Math.random();
        c = {
          x: f.offsetLeft + c.plotLeft + c.plotWidth / 2 + d,
          y: f.offsetTop + c.plotTop + c.plotHeight / 2 + d
        };
        g = g ? {
          x: c.x,
          y: c.y + b
        } : {
          x: c.x + b,
          y: c.y
        };
        [z("mousedown", c), z("mousemove", g), z("mouseup", g)].forEach(function (a) {
          return f.dispatchEvent(a);
        });
        return a.response.success;
      };
      f.prototype.onMapKbdTab = function (a, b) {
        var c = this.chart;
        a = a.response;
        var d = (b = b.shiftKey) && !this.focusedMapNavButtonIx || !b && this.focusedMapNavButtonIx;
        c.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);
        if (d) return c.mapView && c.mapView.zoomBy(), a[b ? "prev" : "next"];
        this.focusedMapNavButtonIx += b ? -1 : 1;
        b = c.mapNavigation.navButtons[this.focusedMapNavButtonIx];
        c.setFocusToElement(b.box, b.element);
        b.setState(2);
        return a.success;
      };
      f.prototype.onMapKbdClick = function (a) {
        this.fakeClickEvent(this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element);
        return a.response.success;
      };
      f.prototype.onMapNavInit = function (a) {
        var b = this.chart,
          c = b.mapNavigation.navButtons[0],
          d = b.mapNavigation.navButtons[1];
        c = 0 < a ? c : d;
        b.setFocusToElement(c.box, c.element);
        c.setState(2);
        this.focusedMapNavButtonIx = 0 < a ? 0 : 1;
      };
      f.prototype.simpleButtonNavigation = function (a, b, c) {
        var d = this.keyCodes,
          f = this,
          g = this.chart;
        return new x(g, {
          keyCodeMap: [[[d.tab, d.up, d.down, d.left, d.right], function (a, b) {
            return this.response[a === d.tab && b.shiftKey || a === d.left || a === d.up ? "prev" : "next"];
          }], [[d.space, d.enter], function () {
            var a = c(this, g);
            return k(a, this.response.success);
          }]],
          validate: function () {
            return g[a] && g[a].box && f[b].buttonElement;
          },
          init: function () {
            g.setFocusToElement(g[a].box, f[b].buttonElement);
          }
        });
      };
      f.prototype.getKeyboardNavigation = function () {
        return [this.simpleButtonNavigation("resetZoomButton", "resetZoomProxyButton", function (a, b) {
          b.zoomOut();
        }), this.simpleButtonNavigation("drillUpButton", "drillUpProxyButton", function (a, b) {
          b.drillUp();
          return a.response.prev;
        }), this.getMapZoomNavigation()];
      };
      return f;
    }(a);
  });
  A(a, "Accessibility/HighContrastMode.js", [a["Core/Globals.js"]], function (a) {
    var h = a.doc,
      l = a.isMS,
      u = a.win;
    return {
      isHighContrastModeActive: function () {
        var a = /(Edg)/.test(u.navigator.userAgent);
        if (u.matchMedia && a) return u.matchMedia("(-ms-high-contrast: active)").matches;
        if (l && u.getComputedStyle) {
          a = h.createElement("div");
          a.style.backgroundImage = "url(".concat("data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", ")");
          h.body.appendChild(a);
          var p = (a.currentStyle || u.getComputedStyle(a)).backgroundImage;
          h.body.removeChild(a);
          return "none" === p;
        }
        return u.matchMedia && u.matchMedia("(forced-colors: active)").matches;
      },
      setHighContrastTheme: function (a) {
        a.highContrastModeActive = !0;
        var h = a.options.accessibility.highContrastTheme;
        a.update(h, !1);
        a.series.forEach(function (a) {
          var l = h.plotOptions[a.type] || {};
          a.update({
            color: l.color || "windowText",
            colors: [l.color || "windowText"],
            borderColor: l.borderColor || "window"
          });
          a.points.forEach(function (a) {
            a.options && a.options.color && a.update({
              color: l.color || "windowText",
              borderColor: l.borderColor || "window"
            }, !1);
          });
        });
        a.redraw();
      }
    };
  });
  A(a, "Accessibility/HighContrastTheme.js", [], function () {
    return {
      chart: {
        backgroundColor: "window"
      },
      title: {
        style: {
          color: "windowText"
        }
      },
      subtitle: {
        style: {
          color: "windowText"
        }
      },
      colorAxis: {
        minColor: "windowText",
        maxColor: "windowText",
        stops: []
      },
      colors: ["windowText"],
      xAxis: {
        gridLineColor: "windowText",
        labels: {
          style: {
            color: "windowText"
          }
        },
        lineColor: "windowText",
        minorGridLineColor: "windowText",
        tickColor: "windowText",
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      yAxis: {
        gridLineColor: "windowText",
        labels: {
          style: {
            color: "windowText"
          }
        },
        lineColor: "windowText",
        minorGridLineColor: "windowText",
        tickColor: "windowText",
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      tooltip: {
        backgroundColor: "window",
        borderColor: "windowText",
        style: {
          color: "windowText"
        }
      },
      plotOptions: {
        series: {
          lineColor: "windowText",
          fillColor: "window",
          borderColor: "windowText",
          edgeColor: "windowText",
          borderWidth: 1,
          dataLabels: {
            connectorColor: "windowText",
            color: "windowText",
            style: {
              color: "windowText",
              textOutline: "none"
            }
          },
          marker: {
            lineColor: "windowText",
            fillColor: "windowText"
          }
        },
        pie: {
          color: "window",
          colors: ["window"],
          borderColor: "windowText",
          borderWidth: 1
        },
        boxplot: {
          fillColor: "window"
        },
        candlestick: {
          lineColor: "windowText",
          fillColor: "window"
        },
        errorbar: {
          fillColor: "window"
        }
      },
      legend: {
        backgroundColor: "window",
        itemStyle: {
          color: "windowText"
        },
        itemHoverStyle: {
          color: "windowText"
        },
        itemHiddenStyle: {
          color: "#555"
        },
        title: {
          style: {
            color: "windowText"
          }
        }
      },
      credits: {
        style: {
          color: "windowText"
        }
      },
      labels: {
        style: {
          color: "windowText"
        }
      },
      drilldown: {
        activeAxisLabelStyle: {
          color: "windowText"
        },
        activeDataLabelStyle: {
          color: "windowText"
        }
      },
      navigation: {
        buttonOptions: {
          symbolStroke: "windowText",
          theme: {
            fill: "window"
          }
        }
      },
      rangeSelector: {
        buttonTheme: {
          fill: "window",
          stroke: "windowText",
          style: {
            color: "windowText"
          },
          states: {
            hover: {
              fill: "window",
              stroke: "windowText",
              style: {
                color: "windowText"
              }
            },
            select: {
              fill: "#444",
              stroke: "windowText",
              style: {
                color: "windowText"
              }
            }
          }
        },
        inputBoxBorderColor: "windowText",
        inputStyle: {
          backgroundColor: "window",
          color: "windowText"
        },
        labelStyle: {
          color: "windowText"
        }
      },
      navigator: {
        handles: {
          backgroundColor: "window",
          borderColor: "windowText"
        },
        outlineColor: "windowText",
        maskFill: "transparent",
        series: {
          color: "windowText",
          lineColor: "windowText"
        },
        xAxis: {
          gridLineColor: "windowText"
        }
      },
      scrollbar: {
        barBackgroundColor: "#444",
        barBorderColor: "windowText",
        buttonArrowColor: "windowText",
        buttonBackgroundColor: "window",
        buttonBorderColor: "windowText",
        rifleColor: "windowText",
        trackBackgroundColor: "window",
        trackBorderColor: "windowText"
      }
    };
  });
  A(a, "Accessibility/Options/A11yDefaults.js", [], function () {
    return {
      accessibility: {
        enabled: !0,
        screenReaderSection: {
          beforeChartFormat: "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
          afterChartFormat: "{endOfChartMarker}",
          axisRangeDateFormat: "%Y-%m-%d %H:%M:%S"
        },
        series: {
          descriptionFormat: "{seriesDescription}{authorDescription}{axisDescription}",
          describeSingleSeries: !1,
          pointDescriptionEnabledThreshold: 200
        },
        point: {
          valueDescriptionFormat: "{xDescription}{separator}{value}.",
          describeNull: !0
        },
        landmarkVerbosity: "all",
        linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
        keyboardNavigation: {
          enabled: !0,
          focusBorder: {
            enabled: !0,
            hideBrowserFocusOutline: !0,
            style: {
              color: "#335cad",
              lineWidth: 2,
              borderRadius: 3
            },
            margin: 2
          },
          order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
          wrapAround: !0,
          seriesNavigation: {
            skipNullPoints: !0,
            pointNavigationEnabledThreshold: !1,
            rememberPointFocus: !1
          }
        },
        announceNewData: {
          enabled: !1,
          minAnnounceInterval: 5E3,
          interruptUser: !1
        }
      },
      legend: {
        accessibility: {
          enabled: !0,
          keyboardNavigation: {
            enabled: !0
          }
        }
      },
      exporting: {
        accessibility: {
          enabled: !0
        }
      }
    };
  });
  A(a, "Accessibility/Options/LangDefaults.js", [], function () {
    return {
      accessibility: {
        defaultChartTitle: "Chart",
        chartContainerLabel: "{title}. Highcharts interactive chart.",
        svgContainerLabel: "Interactive chart",
        drillUpButton: "{buttonText}",
        credits: "Chart credits: {creditsStr}",
        thousandsSep: ",",
        svgContainerTitle: "",
        graphicContainerLabel: "",
        screenReaderSection: {
          beforeRegionLabel: "",
          afterRegionLabel: "",
          annotations: {
            heading: "Chart annotations summary",
            descriptionSinglePoint: "{annotationText}. Related to {annotationPoint}",
            descriptionMultiplePoints: "{annotationText}. Related to {annotationPoint}{ Also related to, #each(additionalAnnotationPoints)}",
            descriptionNoPoints: "{annotationText}"
          },
          endOfChartMarker: "End of interactive chart."
        },
        sonification: {
          playAsSoundButtonText: "Play as sound, {chartTitle}",
          playAsSoundClickAnnouncement: "Play"
        },
        legend: {
          legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
          legendLabel: "Chart legend: {legendTitle}",
          legendItem: "Show {itemName}"
        },
        zoom: {
          mapZoomIn: "Zoom chart",
          mapZoomOut: "Zoom out chart",
          resetZoomButton: "Reset zoom"
        },
        rangeSelector: {
          dropdownLabel: "{rangeTitle}",
          minInputLabel: "Select start date.",
          maxInputLabel: "Select end date.",
          clickButtonAnnouncement: "Viewing {axisRangeDescription}"
        },
        table: {
          viewAsDataTableButtonText: "View as data table, {chartTitle}",
          tableSummary: "Table representation of chart."
        },
        announceNewData: {
          newDataAnnounce: "Updated data for chart {chartTitle}",
          newSeriesAnnounceSingle: "New data series: {seriesDesc}",
          newPointAnnounceSingle: "New data point: {pointDesc}",
          newSeriesAnnounceMultiple: "New data series in chart {chartTitle}: {seriesDesc}",
          newPointAnnounceMultiple: "New data point in chart {chartTitle}: {pointDesc}"
        },
        seriesTypeDescriptions: {
          boxplot: "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
          arearange: "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
          areasplinerange: "These charts are line charts displaying a range between a lower and higher value for each point.",
          bubble: "Bubble charts are scatter charts where each data point also has a size value.",
          columnrange: "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
          errorbar: "Errorbar series are used to display the variability of the data.",
          funnel: "Funnel charts are used to display reduction of data in stages.",
          pyramid: "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
          waterfall: "A waterfall chart is a column chart where each column contributes towards a total end value."
        },
        chartTypes: {
          emptyChart: "Empty chart",
          mapTypeDescription: "Map of {mapTitle} with {numSeries} data series.",
          unknownMap: "Map of unspecified region with {numSeries} data series.",
          combinationChart: "Combination chart with {numSeries} data series.",
          defaultSingle: "Chart with {numPoints} data {#plural(numPoints, points, point)}.",
          defaultMultiple: "Chart with {numSeries} data series.",
          splineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
          splineMultiple: "Line chart with {numSeries} lines.",
          lineSingle: "Line chart with {numPoints} data {#plural(numPoints, points, point)}.",
          lineMultiple: "Line chart with {numSeries} lines.",
          columnSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
          columnMultiple: "Bar chart with {numSeries} data series.",
          barSingle: "Bar chart with {numPoints} {#plural(numPoints, bars, bar)}.",
          barMultiple: "Bar chart with {numSeries} data series.",
          pieSingle: "Pie chart with {numPoints} {#plural(numPoints, slices, slice)}.",
          pieMultiple: "Pie chart with {numSeries} pies.",
          scatterSingle: "Scatter chart with {numPoints} {#plural(numPoints, points, point)}.",
          scatterMultiple: "Scatter chart with {numSeries} data series.",
          boxplotSingle: "Boxplot with {numPoints} {#plural(numPoints, boxes, box)}.",
          boxplotMultiple: "Boxplot with {numSeries} data series.",
          bubbleSingle: "Bubble chart with {numPoints} {#plural(numPoints, bubbles, bubble)}.",
          bubbleMultiple: "Bubble chart with {numSeries} data series."
        },
        axis: {
          xAxisDescriptionSingular: "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
          xAxisDescriptionPlural: "The chart has {numAxes} X axes displaying {#each(names, -1) }and {names[-1]}.",
          yAxisDescriptionSingular: "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
          yAxisDescriptionPlural: "The chart has {numAxes} Y axes displaying {#each(names, -1) }and {names[-1]}.",
          timeRangeDays: "Data range: {range} days.",
          timeRangeHours: "Data range: {range} hours.",
          timeRangeMinutes: "Data range: {range} minutes.",
          timeRangeSeconds: "Data range: {range} seconds.",
          rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.",
          rangeCategories: "Data range: {numCategories} categories."
        },
        exporting: {
          chartMenuLabel: "Chart menu",
          menuButtonLabel: "View chart menu, {chartTitle}"
        },
        series: {
          summary: {
            "default": "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.",
            defaultCombination: "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.",
            line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.",
            lineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.",
            spline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.",
            splineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.",
            column: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bars, bar)}.",
            columnCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#plural(series.points.length, bars, bar)}.",
            bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bars, bar)}.",
            barCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#plural(series.points.length, bars, bar)}.",
            pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, slices, slice)}.",
            pieCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#plural(series.points.length, slices, slice)}.",
            scatter: "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, points, point)}.",
            scatterCombination: "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#plural(series.points.length, points, point)}.",
            boxplot: "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, boxes, box)}.",
            boxplotCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#plural(series.points.length, boxes, box)}.",
            bubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.",
            bubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.",
            map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, areas, area)}.",
            mapCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#plural(series.points.length, areas, area)}.",
            mapline: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#plural(series.points.length, points, point)}.",
            maplineCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#plural(series.points.length, points, point)}.",
            mapbubble: "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#plural(series.points.length, bubbles, bubble)}.",
            mapbubbleCombination: "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#plural(series.points.length, bubbles, bubble)}."
          },
          description: "{description}",
          xAxisDescription: "X axis, {name}",
          yAxisDescription: "Y axis, {name}",
          nullPointValue: "No value",
          pointAnnotationsDescription: "{Annotation: #each(annotations). }"
        }
      }
    };
  });
  A(a, "Accessibility/Options/DeprecatedOptions.js", [a["Core/Utilities.js"]], function (a) {
    function h(a, h, l) {
      for (var f, d = 0; d < h.length - 1; ++d) f = h[d], a = a[f] = z(a[f], {});
      a[h[h.length - 1]] = l;
    }
    function l(a, k, l, f) {
      function d(a, b) {
        return b.reduce(function (a, b) {
          return a[b];
        }, a);
      }
      var b = d(a.options, k),
        c = d(a.options, l);
      Object.keys(f).forEach(function (d) {
        var e,
          g = b[d];
        "undefined" !== typeof g && (h(c, f[d], g), A(32, !1, a, (e = {}, e[k.join(".") + "." + d] = l.join(".") + "." + f[d].join("."), e)));
      });
    }
    function u(a) {
      var g = a.options.chart,
        h = a.options.accessibility || {};
      ["description", "typeDescription"].forEach(function (f) {
        var d;
        g[f] && (h[f] = g[f], A(32, !1, a, (d = {}, d["chart.".concat(f)] = "use accessibility.".concat(f), d)));
      });
    }
    function m(a) {
      a.axes.forEach(function (g) {
        (g = g.options) && g.description && (g.accessibility = g.accessibility || {}, g.accessibility.description = g.description, A(32, !1, a, {
          "axis.description": "use axis.accessibility.description"
        }));
      });
    }
    function p(a) {
      var g = {
        description: ["accessibility", "description"],
        exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
        pointDescriptionFormatter: ["accessibility", "point", "descriptionFormatter"],
        skipKeyboardNavigation: ["accessibility", "keyboardNavigation", "enabled"],
        "accessibility.pointDescriptionFormatter": ["accessibility", "point", "descriptionFormatter"]
      };
      a.series.forEach(function (k) {
        Object.keys(g).forEach(function (f) {
          var d,
            b = k.options[f];
          "accessibility.pointDescriptionFormatter" === f && (b = k.options.accessibility && k.options.accessibility.pointDescriptionFormatter);
          "undefined" !== typeof b && (h(k.options, g[f], "skipKeyboardNavigation" === f ? !b : b), A(32, !1, a, (d = {}, d["series.".concat(f)] = "series." + g[f].join("."), d)));
        });
      });
    }
    var A = a.error,
      z = a.pick;
    return function (a) {
      u(a);
      m(a);
      a.series && p(a);
      l(a, ["accessibility"], ["accessibility"], {
        pointDateFormat: ["point", "dateFormat"],
        pointDateFormatter: ["point", "dateFormatter"],
        pointDescriptionFormatter: ["point", "descriptionFormatter"],
        pointDescriptionThreshold: ["series", "pointDescriptionEnabledThreshold"],
        pointNavigationThreshold: ["keyboardNavigation", "seriesNavigation", "pointNavigationEnabledThreshold"],
        pointValueDecimals: ["point", "valueDecimals"],
        pointValuePrefix: ["point", "valuePrefix"],
        pointValueSuffix: ["point", "valueSuffix"],
        screenReaderSectionFormatter: ["screenReaderSection", "beforeChartFormatter"],
        describeSingleSeries: ["series", "describeSingleSeries"],
        seriesDescriptionFormatter: ["series", "descriptionFormatter"],
        onTableAnchorClick: ["screenReaderSection", "onViewDataTableClick"],
        axisRangeDateFormat: ["screenReaderSection", "axisRangeDateFormat"]
      });
      l(a, ["accessibility", "keyboardNavigation"], ["accessibility", "keyboardNavigation", "seriesNavigation"], {
        skipNullPoints: ["skipNullPoints"],
        mode: ["mode"]
      });
      l(a, ["lang", "accessibility"], ["lang", "accessibility"], {
        legendItem: ["legend", "legendItem"],
        legendLabel: ["legend", "legendLabel"],
        mapZoomIn: ["zoom", "mapZoomIn"],
        mapZoomOut: ["zoom", "mapZoomOut"],
        resetZoomButton: ["zoom", "resetZoomButton"],
        screenReaderRegionLabel: ["screenReaderSection", "beforeRegionLabel"],
        rangeSelectorButton: ["rangeSelector", "buttonText"],
        rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
        rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
        svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
        viewAsDataTable: ["table", "viewAsDataTableButtonText"],
        tableSummary: ["table", "tableSummary"]
      });
    };
  });
  A(a, "Accessibility/Accessibility.js", [a["Core/Defaults.js"], a["Core/Globals.js"], a["Core/Utilities.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Accessibility/A11yI18n.js"], a["Accessibility/Components/ContainerComponent.js"], a["Accessibility/FocusBorder.js"], a["Accessibility/Components/InfoRegionsComponent.js"], a["Accessibility/KeyboardNavigation.js"], a["Accessibility/Components/LegendComponent.js"], a["Accessibility/Components/MenuComponent.js"], a["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"], a["Accessibility/ProxyProvider.js"], a["Accessibility/Components/RangeSelectorComponent.js"], a["Accessibility/Components/SeriesComponent/SeriesComponent.js"], a["Accessibility/Components/ZoomComponent.js"], a["Accessibility/HighContrastMode.js"], a["Accessibility/HighContrastTheme.js"], a["Accessibility/Options/A11yDefaults.js"], a["Accessibility/Options/LangDefaults.js"], a["Accessibility/Options/DeprecatedOptions.js"]], function (a, h, l, x, m, p, A, z, g, k, w, f, d, b, c, e, r, E, I, J, B) {
    a = a.defaultOptions;
    var u = h.doc,
      C = l.addEvent,
      v = l.extend,
      n = l.fireEvent,
      q = l.merge,
      D = x.removeElement;
    h = function () {
      function a(a) {
        this.proxyProvider = this.keyboardNavigation = this.components = this.chart = void 0;
        this.init(a);
      }
      a.prototype.init = function (a) {
        this.chart = a;
        u.addEventListener && a.renderer.isSVG ? (B(a), this.proxyProvider = new d(this.chart), this.initComponents(), this.keyboardNavigation = new g(a, this.components)) : (this.zombie = !0, this.components = {}, a.renderTo.setAttribute("aria-hidden", !0));
      };
      a.prototype.initComponents = function () {
        var a = this.chart,
          d = this.proxyProvider,
          f = a.options.accessibility;
        this.components = {
          container: new p(),
          infoRegions: new z(),
          legend: new k(),
          chartMenu: new w(),
          rangeSelector: new b(),
          series: new c(),
          zoom: new e()
        };
        f.customComponents && v(this.components, f.customComponents);
        var g = this.components;
        this.getComponentOrder().forEach(function (b) {
          g[b].initBase(a, d);
          g[b].init();
        });
      };
      a.prototype.getComponentOrder = function () {
        if (!this.components) return [];
        if (!this.components.series) return Object.keys(this.components);
        var a = Object.keys(this.components).filter(function (a) {
          return "series" !== a;
        });
        return ["series"].concat(a);
      };
      a.prototype.update = function () {
        var a = this.components,
          b = this.chart,
          c = b.options.accessibility;
        n(b, "beforeA11yUpdate");
        b.types = this.getChartTypes();
        c = c.keyboardNavigation.order;
        this.proxyProvider.updateGroupOrder(c);
        this.getComponentOrder().forEach(function (c) {
          a[c].onChartUpdate();
          n(b, "afterA11yComponentUpdate", {
            name: c,
            component: a[c]
          });
        });
        this.keyboardNavigation.update(c);
        !b.highContrastModeActive && r.isHighContrastModeActive() && r.setHighContrastTheme(b);
        n(b, "afterA11yUpdate", {
          accessibility: this
        });
      };
      a.prototype.destroy = function () {
        var a = this.chart || {},
          b = this.components;
        Object.keys(b).forEach(function (a) {
          b[a].destroy();
          b[a].destroyBase();
        });
        this.proxyProvider && this.proxyProvider.destroy();
        a.announcerContainer && D(a.announcerContainer);
        this.keyboardNavigation && this.keyboardNavigation.destroy();
        a.renderTo && a.renderTo.setAttribute("aria-hidden", !0);
        a.focusElement && a.focusElement.removeFocusBorder();
      };
      a.prototype.getChartTypes = function () {
        var a = {};
        this.chart.series.forEach(function (b) {
          a[b.type] = 1;
        });
        return Object.keys(a);
      };
      return a;
    }();
    (function (a) {
      function d() {
        this.accessibility && this.accessibility.destroy();
      }
      function e() {
        this.a11yDirty && this.renderTo && (delete this.a11yDirty, this.updateA11yEnabled());
        var a = this.accessibility;
        a && !a.zombie && (a.proxyProvider.updateProxyElementPositions(), a.getComponentOrder().forEach(function (b) {
          a.components[b].onChartRender();
        }));
      }
      function h(a) {
        if (a = a.options.accessibility) a.customComponents && (this.options.accessibility.customComponents = a.customComponents, delete a.customComponents), q(!0, this.options.accessibility, a), this.accessibility && this.accessibility.destroy && (this.accessibility.destroy(), delete this.accessibility);
        this.a11yDirty = !0;
      }
      function l() {
        var b = this.accessibility,
          c = this.options.accessibility;
        c && c.enabled ? b && !b.zombie ? b.update() : (this.accessibility = b = new a(this), !b.zombie) && b.update() : b ? (b.destroy && b.destroy(), delete this.accessibility) : this.renderTo.setAttribute("aria-hidden", !0);
      }
      function n() {
        this.series.chart.accessibility && (this.series.chart.a11yDirty = !0);
      }
      var p = [];
      a.i18nFormat = m.i18nFormat;
      a.compose = function (a, q, r, u, t, v) {
        g.compose(a);
        f.compose(u);
        k.compose(a, q);
        w.compose(a);
        c.compose(a, r, u);
        m.compose(a);
        A.compose(a, t);
        v && b.compose(a, v);
        -1 === p.indexOf(a) && (p.push(a), a.prototype.updateA11yEnabled = l, C(a, "destroy", d), C(a, "render", e), C(a, "update", h), ["addSeries", "init"].forEach(function (b) {
          C(a, b, function () {
            this.a11yDirty = !0;
          });
        }), ["afterApplyDrilldown", "drillupall"].forEach(function (b) {
          C(a, b, function () {
            var a = this.accessibility;
            a && !a.zombie && a.update();
          });
        }));
        -1 === p.indexOf(r) && (p.push(r), C(r, "update", n));
        -1 === p.indexOf(u) && (p.push(u), ["update", "updatedData", "remove"].forEach(function (a) {
          C(u, a, function () {
            this.chart.accessibility && (this.chart.a11yDirty = !0);
          });
        }));
      };
    })(h || (h = {}));
    q(!0, a, I, {
      accessibility: {
        highContrastTheme: E
      },
      lang: J
    });
    return h;
  });
  A(a, "masters/modules/accessibility.src.js", [a["Core/Globals.js"], a["Accessibility/Accessibility.js"], a["Accessibility/AccessibilityComponent.js"], a["Accessibility/Utils/ChartUtilities.js"], a["Accessibility/Utils/HTMLUtilities.js"], a["Accessibility/KeyboardNavigationHandler.js"], a["Accessibility/Components/SeriesComponent/SeriesDescriber.js"]], function (a, h, l, x, m, p, A) {
    a.i18nFormat = h.i18nFormat;
    a.A11yChartUtilities = x;
    a.A11yHTMLUtilities = m;
    a.AccessibilityComponent = l;
    a.KeyboardNavigationHandler = p;
    a.SeriesAccessibilityDescriber = A;
    h.compose(a.Chart, a.Legend, a.Point, a.Series, a.SVGElement, a.RangeSelector);
  });
});

/***/ }),

/***/ 4151:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reactIs = __webpack_require__(8690);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above

  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }
  return targetComponent;
}
module.exports = hoistNonReactStatics;

/***/ }),

/***/ 7230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var aa = __webpack_require__(9471),
  ca = __webpack_require__(9817);
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = new Set(),
  ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++) da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
  ja = Object.prototype.hasOwnProperty,
  ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  la = {},
  ma = {};
function oa(a) {
  if (ja.call(ma, a)) return !0;
  if (ja.call(la, a)) return !1;
  if (ka.test(a)) return ma[a] = !0;
  la[a] = !0;
  return !1;
}
function pa(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;
  switch (typeof b) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      if (d) return !1;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return !1;
  }
}
function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return !0;
  if (d) return !1;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;
    case 4:
      return !1 === b;
    case 5:
      return isNaN(b);
    case 6:
      return isNaN(b) || 1 > b;
  }
  return !1;
}
function v(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  z[a] = new v(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  z[b] = new v(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  z[a] = new v(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  z[a] = new v(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  z[a] = new v(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  z[a] = new v(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
});
function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  va = Symbol.for("react.element"),
  wa = Symbol.for("react.portal"),
  ya = Symbol.for("react.fragment"),
  za = Symbol.for("react.strict_mode"),
  Aa = Symbol.for("react.profiler"),
  Ba = Symbol.for("react.provider"),
  Ca = Symbol.for("react.context"),
  Da = Symbol.for("react.forward_ref"),
  Ea = Symbol.for("react.suspense"),
  Fa = Symbol.for("react.suspense_list"),
  Ga = Symbol.for("react.memo"),
  Ha = Symbol.for("react.lazy");
Symbol.for("react.scope");
Symbol.for("react.debug_trace_mode");
var Ia = Symbol.for("react.offscreen");
Symbol.for("react.legacy_hidden");
Symbol.for("react.cache");
Symbol.for("react.tracing_marker");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign,
  La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La = b && b[1] || "";
  }
  return "\n" + La + a;
}
var Na = !1;
function Oa(a, b) {
  if (!a || Na) return "";
  Na = !0;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b) {
      if (b = function () {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", {
        set: function () {
          throw Error();
        }
      }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (l) {
        d = l;
      }
      a();
    }
  } catch (l) {
    if (l && d && "string" === typeof l.stack) {
      for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
      for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
        if (1 !== g || 1 !== h) {
          do if (g--, h--, 0 > h || e[g] !== f[h]) {
            var k = "\n" + e[g].replace(" at new ", " at ");
            a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
            return k;
          } while (1 <= g && 0 <= h);
        }
        break;
      }
    }
  } finally {
    Na = !1, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, !1), a;
    case 11:
      return a = Oa(a.type.render, !1), a;
    case 1:
      return a = Oa(a.type, !0), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
    case Ha:
      b = a._payload;
      a = a._init;
      try {
        return Qa(a(b));
      } catch (c) {}
  }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value",
    c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
    d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
      f = c.set;
    Object.defineProperty(a, b, {
      configurable: !0,
      get: function () {
        return e.call(this);
      },
      set: function (a) {
        d = "" + a;
        f.call(this, a);
      }
    });
    Object.defineProperty(a, b, {
      enumerable: c.enumerable
    });
    return {
      getValue: function () {
        return d;
      },
      setValue: function (a) {
        d = "" + a;
      },
      stopTracking: function () {
        a._valueTracker = null;
        delete a[b];
      }
    };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return !1;
  var b = a._valueTracker;
  if (!b) return !0;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), !0) : !1;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A({}, b, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: null != c ? c : a._wrapperState.initialChecked
  });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
    d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = {
    initialChecked: d,
    initialValue: c,
    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
  };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, !1);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value),
    d = b.type;
  if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;
        d && (a[e].defaultSelected = !0);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = !0);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
  return A({}, b, {
    value: void 0,
    defaultValue: void 0,
    children: "" + a._wrapperState.initialValue
  });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b) throw Error(p(92));
      if (eb(c)) {
        if (1 < c.length) throw Error(p(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = {
    initialValue: Sa(c)
  };
}
function ib(a, b) {
  var c = Sa(b.value),
    d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb,
  nb = function (a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function () {
        return a(b, c, d, e);
      });
    } : a;
  }(function (a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
      for (; b.firstChild;) a.appendChild(b.firstChild);
    }
  });
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function (a) {
  qb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--"),
      e = rb(c, b[c], d);
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e) : a[c] = e;
  }
}
var tb = A({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
    }
    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null,
  zb = null,
  Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb,
      b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {}
var Ib = !1;
function Jb(a, b, c) {
  if (Ib) return a(b, c);
  Ib = !0;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = !1, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];
  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;
    default:
      a = !1;
  }
  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
  return c;
}
var Lb = !1;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", {
    get: function () {
      Lb = !0;
    }
  });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = !1;
}
function Nb(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l);
  } catch (m) {
    this.onError(m);
  }
}
var Ob = !1,
  Pb = null,
  Qb = !1,
  Rb = null,
  Sb = {
    onError: function (a) {
      Ob = !0;
      Pb = a;
    }
  };
function Tb(a, b, c, d, e, f, g, h, k) {
  Ob = !1;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d, e, f, g, h, k) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l = Pb;
      Ob = !1;
      Pb = null;
    } else throw Error(p(198));
    Qb || (Qb = !0, Rb = l);
  }
}
function Vb(a) {
  var b = a,
    c = a;
  if (a.alternate) for (; b.return;) b = b.return;else {
    a = b;
    do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b) throw Error(p(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b;;) {
    var e = c.return;
    if (null === e) break;
    var f = e.alternate;
    if (null === f) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f;) {
        if (f === c) return Xb(e), a;
        if (f === d) return Xb(e), b;
        f = f.sibling;
      }
      throw Error(p(188));
    }
    if (c.return !== d.return) c = e, d = f;else {
      for (var g = !1, h = e.child; h;) {
        if (h === c) {
          g = !0;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = !0;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = !0;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g) throw Error(p(189));
      }
    }
    if (c.alternate !== d) throw Error(p(190));
  }
  if (3 !== c.tag) throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a;) {
    var b = $b(a);
    if (null !== b) return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback,
  bc = ca.unstable_cancelCallback,
  cc = ca.unstable_shouldYield,
  dc = ca.unstable_requestPaint,
  B = ca.unstable_now,
  ec = ca.unstable_getCurrentPriorityLevel,
  fc = ca.unstable_ImmediatePriority,
  gc = ca.unstable_UserBlockingPriority,
  hc = ca.unstable_NormalPriority,
  ic = ca.unstable_LowPriority,
  jc = ca.unstable_IdlePriority,
  kc = null,
  lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
  pc = Math.log,
  qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64,
  sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0,
    e = a.suspendedLanes,
    f = a.pingedLanes,
    g = c & 268435455;
  if (0 !== g) {
    var h = g & ~e;
    0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
  } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5E3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
    var g = 31 - oc(f),
      h = 1 << g,
      k = e[g];
    if (-1 === k) {
      if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
    } else k <= b && (a.expiredLanes |= h);
    f &= ~h;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++) b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c;) {
    var e = 31 - oc(c),
      f = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c;) {
    var d = 31 - oc(c),
      e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec,
  Fc,
  Gc,
  Hc,
  Ic,
  Jc = !1,
  Kc = [],
  Lc = null,
  Mc = null,
  Nc = null,
  Oc = new Map(),
  Pc = new Map(),
  Qc = [],
  Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f) return a = {
    blockedOn: b,
    domEventName: c,
    eventSystemFlags: d,
    nativeEvent: f,
    targetContainers: [e]
  }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), !0;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), !0;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), !0;
    case "pointerover":
      var f = e.pointerId;
      Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
      return !0;
    case "gotpointercapture":
      return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
  }
  return !1;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) if (b = c.tag, 13 === b) {
      if (b = Wb(c), null !== b) {
        a.blockedOn = b;
        Ic(a.priority, function () {
          Gc(c);
        });
        return;
      }
    } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
      return;
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return !1;
  for (var b = a.targetContainers; 0 < b.length;) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, !1;
    b.shift();
  }
  return !0;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = !1;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b) {
    return ad(b, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig,
  dd = !0;
function ed(a, b, c, d) {
  var e = C,
    f = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}
function gd(a, b, c, d) {
  var e = C,
    f = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f;
  }
}
function fd(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e;) {
        var f = Cb(e);
        null !== f && Ec(f);
        f = Yc(a, b, c, d);
        null === f && hd(a, b, d, id, c);
        if (f === e) break;
        e = f;
      }
      null !== e && d.stopPropagation();
    } else hd(a, b, d, null, c);
  }
}
var id = null;
function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
    a = Wb(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null,
  ld = null,
  md = null;
function nd() {
  if (md) return md;
  var a,
    b = ld,
    c = b.length,
    d,
    e = "value" in kd ? kd.value : kd.textContent,
    f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++);
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return !0;
}
function qd() {
  return !1;
}
function rd(a) {
  function b(b, d, e, f, g) {
    this._reactName = b;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var a = this.nativeEvent;
      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
    },
    stopPropagation: function () {
      var a = this.nativeEvent;
      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
    },
    persist: function () {},
    isPersistent: pd
  });
  return b;
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  td = rd(sd),
  ud = A({}, sd, {
    view: 0,
    detail: 0
  }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function (a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    },
    movementY: function (a) {
      return "movementY" in a ? a.movementY : xd;
    }
  }),
  Bd = rd(Ad),
  Cd = A({}, Ad, {
    dataTransfer: 0
  }),
  Dd = rd(Cd),
  Ed = A({}, ud, {
    relatedTarget: 0
  }),
  Fd = rd(Ed),
  Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  Hd = rd(Gd),
  Id = A({}, sd, {
    clipboardData: function (a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }),
  Jd = rd(Id),
  Kd = A({}, sd, {
    data: 0
  }),
  Ld = rd(Kd),
  Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, {
    key: function (a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (a) {
      return "keypress" === a.type ? od(a) : 0;
    },
    keyCode: function (a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    },
    which: function (a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }
  }),
  Rd = rd(Qd),
  Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  Td = rd(Sd),
  Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
  }),
  Vd = rd(Ud),
  Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  Xd = rd(Wd),
  Yd = A({}, Ad, {
    deltaX: function (a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function (a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae = ia && "CompositionEvent" in window,
  be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be,
  de = ia && (!ae || be && 8 < be && 11 >= be),
  ee = String.fromCharCode(32),
  fe = !1;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = !1;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which) return null;
      fe = !0;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
    event: c,
    listeners: b
  }));
}
var pe = null,
  qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}
var we = !1;
if (ia) {
  var xe;
  if (ia) {
    var ye = ("oninput" in document);
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = !1;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b) {
  if ("click" === a) return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b)) return !0;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
  var c = Object.keys(a),
    d = Object.keys(b);
  if (c.length !== d.length) return !1;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e])) return !1;
  }
  return !0;
}
function Je(a) {
  for (; a && a.firstChild;) a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return {
        node: c,
        offset: b - a
      };
      a = d;
    }
    a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = !1;
    }
    if (c) a = b.contentWindow;else break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(),
    c = a.focusedElem,
    d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
      a = a.getSelection();
      var e = c.textContent.length,
        f = Math.min(d.start, e);
      d = void 0 === d.end ? f : Math.min(d.end, e);
      !a.extend && f > d && (e = d, d = f, f = e);
      e = Ke(c, f);
      var g = Ke(c, d);
      e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
    }
    b = [];
    for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
      element: a,
      left: a.scrollLeft,
      top: a.scrollTop
    });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
  Qe = null,
  Re = null,
  Se = null,
  Te = !1;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
    start: d.selectionStart,
    end: d.selectionEnd
  } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
    anchorNode: d.anchorNode,
    anchorOffset: d.anchorOffset,
    focusNode: d.focusNode,
    focusOffset: d.focusOffset
  }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
    event: b,
    listeners: d
  }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
  },
  Xe = {},
  Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a],
    c;
  for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"),
  af = Ze("animationiteration"),
  bf = Ze("animationstart"),
  cf = Ze("transitionend"),
  df = new Map(),
  ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
    jf = hf.toLowerCase(),
    kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c],
      e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g],
          k = h.instance,
          l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      } else for (g = 0; g < d.length; g++) {
        h = d[g];
        k = h.instance;
        l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        nf(e, h, l);
        f = k;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, !1), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = !0;
    da.forEach(function (b) {
      "selectionchange" !== b && (mf.has(b) || qf(b, !1, a), qf(b, !0, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
  }
}
function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;
    case 4:
      e = gd;
      break;
    default:
      e = fd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
  d ? void 0 !== e ? a.addEventListener(b, c, {
    capture: !0,
    passive: e
  }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
    passive: e
  }) : a.addEventListener(b, c, !1);
}
function hd(a, b, c, d, e) {
  var f = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
    if (null === d) return;
    var g = d.tag;
    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d.return; null !== g;) {
        var k = g.tag;
        if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
        g = g.return;
      }
      for (; null !== h;) {
        g = Wc(h);
        if (null === g) return;
        k = g.tag;
        if (5 === k || 6 === k) {
          d = f = g;
          continue a;
        }
        h = h.parentNode;
      }
    }
    d = d.return;
  }
  Jb(function () {
    var d = f,
      e = xb(c),
      g = [];
    a: {
      var h = df.get(a);
      if (void 0 !== h) {
        var k = td,
          n = a;
        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;
          case "keydown":
          case "keyup":
            k = Rd;
            break;
          case "focusin":
            n = "focus";
            k = Fd;
            break;
          case "focusout":
            n = "blur";
            k = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k = Fd;
            break;
          case "click":
            if (2 === c.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = Vd;
            break;
          case $e:
          case af:
          case bf:
            k = Hd;
            break;
          case cf:
            k = Xd;
            break;
          case "scroll":
            k = vd;
            break;
          case "wheel":
            k = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Td;
        }
        var t = 0 !== (b & 4),
          J = !t && "scroll" === a,
          x = t ? null !== h ? h + "Capture" : null : h;
        t = [];
        for (var w = d, u; null !== w;) {
          u = w;
          var F = u.stateNode;
          5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
          if (J) break;
          w = w.return;
        }
        0 < t.length && (h = new k(h, n, null, c, e), g.push({
          event: h,
          listeners: t
        }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h = "mouseover" === a || "pointerover" === a;
        k = "mouseout" === a || "pointerout" === a;
        if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
        if (k || h) {
          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
          if (k) {
            if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
          } else k = null, n = d;
          if (k !== n) {
            t = Bd;
            F = "onMouseLeave";
            x = "onMouseEnter";
            w = "mouse";
            if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
            J = null == k ? h : ue(k);
            u = null == n ? h : ue(n);
            h = new t(F, w + "leave", k, c, e);
            h.target = J;
            h.relatedTarget = u;
            F = null;
            Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
            J = F;
            if (k && n) b: {
              t = k;
              x = n;
              w = 0;
              for (u = t; u; u = vf(u)) w++;
              u = 0;
              for (F = x; F; F = vf(F)) u++;
              for (; 0 < w - u;) t = vf(t), w--;
              for (; 0 < u - w;) x = vf(x), u--;
              for (; w--;) {
                if (t === x || null !== x && t === x.alternate) break b;
                t = vf(t);
                x = vf(x);
              }
              t = null;
            } else t = null;
            null !== k && wf(g, h, k, t, !1);
            null !== n && null !== J && wf(g, J, n, t, !0);
          }
        }
      }
      a: {
        h = d ? ue(d) : window;
        k = h.nodeName && h.nodeName.toLowerCase();
        if ("select" === k || "input" === k && "file" === h.type) var na = ve;else if (me(h)) {
          if (we) na = Fe;else {
            na = De;
            var xa = Ce;
          }
        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee);
        if (na && (na = na(a, d))) {
          ne(g, na, c, e);
          break a;
        }
        xa && xa(a, h, d);
        "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
      }
      xa = d ? ue(d) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = !1;
          Ue(g, c, e);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g, c, e);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      } else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
        event: ba,
        listeners: xa
      }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
        event: e,
        listeners: d
      }), e.data = $a);
    }
    se(g, b);
  });
}
function tf(a, b, c) {
  return {
    instance: a,
    listener: b,
    currentTarget: c
  };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a;) {
    var e = a,
      f = e.stateNode;
    5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a) return null;
  do a = a.return; while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d;) {
    var h = c,
      k = h.alternate,
      l = h.stateNode;
    if (null !== k && k === d) break;
    5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
    c = c.return;
  }
  0 !== g.length && a.push({
    event: b,
    listeners: g
  });
}
var xf = /\r\n?/g,
  yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p(425));
}
function Bf() {}
var Cf = null,
  Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
  Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
  Hf = "function" === typeof Promise ? Promise : void 0,
  Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
function If(a) {
  setTimeout(function () {
    throw a;
  });
}
function Kf(a, b) {
  var c = b,
    d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e);
        bd(b);
        return;
      }
      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a;) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2),
  Of = "__reactFiber$" + Nf,
  Pf = "__reactProps$" + Nf,
  uf = "__reactContainer$" + Nf,
  of = "__reactEvents$" + Nf,
  Qf = "__reactListeners$" + Nf,
  Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b) return b;
  for (var c = a.parentNode; c;) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [],
  Tf = -1;
function Uf(a) {
  return {
    current: a
  };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {},
  H = Uf(Vf),
  Wf = Uf(!1),
  Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {},
    f;
  for (f in c) e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf) throw Error(p(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();
  for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
  return A({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return !0;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null,
  fg = !1,
  gg = !1;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = !0;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = !0;
    var a = 0,
      b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do d = d(!0); while (null !== d);
      }
      eg = null;
      fg = !1;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = !1;
    }
  }
  return null;
}
var kg = [],
  lg = 0,
  mg = null,
  ng = 0,
  og = [],
  pg = 0,
  qg = null,
  rg = 1,
  sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f = 32 - oc(b) + e;
  if (30 < f) {
    var g = e - e % 5;
    f = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f + a;
  } else rg = 1 << f | c << e | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null,
  yg = null,
  I = !1,
  zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
        id: rg,
        overflow: sg
      } : null, a.memoizedState = {
        dehydrated: b,
        treeContext: c,
        retryLane: 1073741824
      }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
    default:
      return !1;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = !1;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return !1;
  if (!I) return Fg(a), I = !0, !1;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p(418));
    for (; b;) Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a;) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return !0;
}
function Hg() {
  for (var a = yg; a;) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = !1;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var Mg = Uf(null),
  Ng = null,
  Og = null,
  Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b = Mg.current;
  E(Mg);
  a._currentValue = b;
}
function Sg(a, b, c) {
  for (; null !== a;) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}
function Tg(a, b) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = !0), a.firstContext = null);
}
function Vg(a) {
  var b = a._currentValue;
  if (Pg !== a) if (a = {
    context: a,
    memoizedValue: b,
    next: null
  }, null === Og) {
    if (null === Ng) throw Error(p(308));
    Og = a;
    Ng.dependencies = {
      lanes: 0,
      firstContext: a
    };
  } else Og = Og.next = a;
  return b;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return Zg(a, d);
}
function Zg(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var $g = !1;
function ah(a) {
  a.updateQueue = {
    baseState: a.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0
    },
    effects: null
  };
}
function bh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = {
    baseState: a.baseState,
    firstBaseUpdate: a.firstBaseUpdate,
    lastBaseUpdate: a.lastBaseUpdate,
    shared: a.shared,
    effects: a.effects
  });
}
function ch(a, b) {
  return {
    eventTime: a,
    lane: b,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}
function dh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return Zg(a, c);
  }
  e = d.interleaved;
  null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return Zg(a, c);
}
function eh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
function fh(a, b) {
  var c = a.updateQueue,
    d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null,
      f = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = {
          eventTime: c.eventTime,
          lane: c.lane,
          tag: c.tag,
          payload: c.payload,
          callback: c.callback,
          next: null
        };
        null === f ? e = f = g : f = f.next = g;
        c = c.next;
      } while (null !== c);
      null === f ? e = f = b : f = f.next = b;
    } else e = f = b;
    c = {
      baseState: d.baseState,
      firstBaseUpdate: e,
      lastBaseUpdate: f,
      shared: d.shared,
      effects: d.effects
    };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function gh(a, b, c, d) {
  var e = a.updateQueue;
  $g = !1;
  var f = e.firstBaseUpdate,
    g = e.lastBaseUpdate,
    h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k = h,
      l = k.next;
    k.next = null;
    null === g ? f = l : g.next = l;
    g = k;
    var m = a.alternate;
    null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
  }
  if (null !== f) {
    var q = e.baseState;
    g = 0;
    m = l = k = null;
    h = f;
    do {
      var r = h.lane,
        y = h.eventTime;
      if ((d & r) === r) {
        null !== m && (m = m.next = {
          eventTime: y,
          lane: 0,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        });
        a: {
          var n = a,
            t = h;
          r = b;
          y = c;
          switch (t.tag) {
            case 1:
              n = t.payload;
              if ("function" === typeof n) {
                q = n.call(y, q, r);
                break a;
              }
              q = n;
              break a;
            case 3:
              n.flags = n.flags & -65537 | 128;
            case 0:
              n = t.payload;
              r = "function" === typeof n ? n.call(y, q, r) : n;
              if (null === r || void 0 === r) break a;
              q = A({}, q, r);
              break a;
            case 2:
              $g = !0;
          }
        }
        null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
      } else y = {
        eventTime: y,
        lane: r,
        tag: h.tag,
        payload: h.payload,
        callback: h.callback,
        next: null
      }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
      h = h.next;
      if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
    } while (1);
    null === m && (k = q);
    e.baseState = k;
    e.firstBaseUpdate = l;
    e.lastBaseUpdate = m;
    b = e.shared.interleaved;
    if (null !== b) {
      e = b;
      do g |= e.lane, e = e.next; while (e !== b);
    } else null === f && (e.shared.lanes = 0);
    hh |= g;
    a.lanes = g;
    a.memoizedState = q;
  }
}
function ih(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b],
      e = d.callback;
    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(p(191, e));
      e.call(d);
    }
  }
}
var jh = new aa.Component().refs;
function kh(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var nh = {
  isMounted: function (a) {
    return (a = a._reactInternals) ? Vb(a) === a : !1;
  },
  enqueueSetState: function (a, b, c) {
    a = a._reactInternals;
    var d = L(),
      e = lh(a),
      f = ch(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueReplaceState: function (a, b, c) {
    a = a._reactInternals;
    var d = L(),
      e = lh(a),
      f = ch(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = dh(a, f, e);
    null !== b && (mh(b, a, e, d), eh(b, a, e));
  },
  enqueueForceUpdate: function (a, b) {
    a = a._reactInternals;
    var c = L(),
      d = lh(a),
      e = ch(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = dh(a, e, d);
    null !== b && (mh(b, a, d, c), eh(b, a, d));
  }
};
function oh(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
}
function ph(a, b, c) {
  var d = !1,
    e = Vf;
  var f = b.contextType;
  "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = nh;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function qh(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && nh.enqueueReplaceState(b, b.state, null);
}
function rh(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = jh;
  ah(a);
  var f = b.contextType;
  "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag) throw Error(p(309));
        var d = c.stateNode;
      }
      if (!d) throw Error(p(147, a));
      var e = d,
        f = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
      b = function (a) {
        var b = e.refs;
        b === jh && (b = e.refs = {});
        null === a ? delete b[f] : b[f] = a;
      };
      b._stringRef = f;
      return b;
    }
    if ("string" !== typeof a) throw Error(p(284));
    if (!c._owner) throw Error(p(290, a));
  }
  return a;
}
function th(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function uh(a) {
  var b = a._init;
  return b(a._payload);
}
function vh(a) {
  function b(b, c) {
    if (a) {
      var d = b.deletions;
      null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
    }
  }
  function c(c, d) {
    if (!a) return null;
    for (; null !== d;) b(c, d), d = d.sibling;
    return null;
  }
  function d(a, b) {
    for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    return a;
  }
  function e(a, b) {
    a = wh(a, b);
    a.index = 0;
    a.sibling = null;
    return a;
  }
  function f(b, c, d) {
    b.index = d;
    if (!a) return b.flags |= 1048576, c;
    d = b.alternate;
    if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
    b.flags |= 2;
    return c;
  }
  function g(b) {
    a && null === b.alternate && (b.flags |= 2);
    return b;
  }
  function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = xh(c, a.mode, d), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }
  function k(a, b, c, d) {
    var f = c.type;
    if (f === ya) return m(a, b, c.props.children, d, c.key);
    if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && uh(f) === b.type)) return d = e(b, c.props), d.ref = sh(a, b, c), d.return = a, d;
    d = yh(c.type, c.key, c.props, null, a.mode, d);
    d.ref = sh(a, b, c);
    d.return = a;
    return d;
  }
  function l(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = zh(c, a.mode, d), b.return = a, b;
    b = e(b, c.children || []);
    b.return = a;
    return b;
  }
  function m(a, b, c, d, f) {
    if (null === b || 7 !== b.tag) return b = Ah(c, a.mode, d, f), b.return = a, b;
    b = e(b, c);
    b.return = a;
    return b;
  }
  function q(a, b, c) {
    if ("string" === typeof b && "" !== b || "number" === typeof b) return b = xh("" + b, a.mode, c), b.return = a, b;
    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case va:
          return c = yh(b.type, b.key, b.props, null, a.mode, c), c.ref = sh(a, null, b), c.return = a, c;
        case wa:
          return b = zh(b, a.mode, c), b.return = a, b;
        case Ha:
          var d = b._init;
          return q(a, d(b._payload), c);
      }
      if (eb(b) || Ka(b)) return b = Ah(b, a.mode, c, null), b.return = a, b;
      th(a, b);
    }
    return null;
  }
  function r(a, b, c, d) {
    var e = null !== b ? b.key : null;
    if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case va:
          return c.key === e ? k(a, b, c, d) : null;
        case wa:
          return c.key === e ? l(a, b, c, d) : null;
        case Ha:
          return e = c._init, r(a, b, e(c._payload), d);
      }
      if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
      th(a, c);
    }
    return null;
  }
  function y(a, b, c, d, e) {
    if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
    if ("object" === typeof d && null !== d) {
      switch (d.$$typeof) {
        case va:
          return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
        case wa:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
        case Ha:
          var f = d._init;
          return y(a, b, c, f(d._payload), e);
      }
      if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
      th(b, d);
    }
    return null;
  }
  function n(e, g, h, k) {
    for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
      u.index > w ? (x = u, u = null) : x = u.sibling;
      var n = r(e, u, h[w], k);
      if (null === n) {
        null === u && (u = x);
        break;
      }
      a && u && null === n.alternate && b(e, u);
      g = f(n, g, w);
      null === m ? l = n : m.sibling = n;
      m = n;
      u = x;
    }
    if (w === h.length) return c(e, u), I && tg(e, w), l;
    if (null === u) {
      for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
      I && tg(e, w);
      return l;
    }
    for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
    a && u.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }
  function t(e, g, h, k) {
    var l = Ka(h);
    if ("function" !== typeof l) throw Error(p(150));
    h = l.call(h);
    if (null == h) throw Error(p(151));
    for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
      m.index > w ? (x = m, m = null) : x = m.sibling;
      var t = r(e, m, n.value, k);
      if (null === t) {
        null === m && (m = x);
        break;
      }
      a && m && null === t.alternate && b(e, m);
      g = f(t, g, w);
      null === u ? l = t : u.sibling = t;
      u = t;
      m = x;
    }
    if (n.done) return c(e, m), I && tg(e, w), l;
    if (null === m) {
      for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
      I && tg(e, w);
      return l;
    }
    for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
    a && m.forEach(function (a) {
      return b(e, a);
    });
    I && tg(e, w);
    return l;
  }
  function J(a, d, f, h) {
    "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
    if ("object" === typeof f && null !== f) {
      switch (f.$$typeof) {
        case va:
          a: {
            for (var k = f.key, l = d; null !== l;) {
              if (l.key === k) {
                k = f.type;
                if (k === ya) {
                  if (7 === l.tag) {
                    c(a, l.sibling);
                    d = e(l, f.props.children);
                    d.return = a;
                    a = d;
                    break a;
                  }
                } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && uh(k) === l.type) {
                  c(a, l.sibling);
                  d = e(l, f.props);
                  d.ref = sh(a, l, f);
                  d.return = a;
                  a = d;
                  break a;
                }
                c(a, l);
                break;
              } else b(a, l);
              l = l.sibling;
            }
            f.type === ya ? (d = Ah(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = yh(f.type, f.key, f.props, null, a.mode, h), h.ref = sh(a, d, f), h.return = a, a = h);
          }
          return g(a);
        case wa:
          a: {
            for (l = f.key; null !== d;) {
              if (d.key === l) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }
            d = zh(f, a.mode, h);
            d.return = a;
            a = d;
          }
          return g(a);
        case Ha:
          return l = f._init, J(a, d, l(f._payload), h);
      }
      if (eb(f)) return n(a, d, f, h);
      if (Ka(f)) return t(a, d, f, h);
      th(a, f);
    }
    return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = xh(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
  }
  return J;
}
var Bh = vh(!0),
  Ch = vh(!1),
  Dh = {},
  Eh = Uf(Dh),
  Fh = Uf(Dh),
  Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh) throw Error(p(174));
  return a;
}
function Ih(a, b) {
  G(Gh, b);
  G(Fh, a);
  G(Eh, Dh);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(Eh);
  G(Eh, b);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b = Hh(Eh.current);
  var c = lb(b, a.type);
  b !== c && (G(Fh, a), G(Eh, c));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b = a; null !== b;) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a) break;
    for (; null === b.sibling;) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher,
  Qh = ua.ReactCurrentBatchConfig,
  Rh = 0,
  N = null,
  O = null,
  P = null,
  Sh = !1,
  Th = !1,
  Uh = 0,
  Vh = 0;
function Q() {
  throw Error(p(321));
}
function Wh(a, b) {
  if (null === b) return !1;
  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;
  return !0;
}
function Xh(a, b, c, d, e, f) {
  Rh = f;
  N = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d, e);
  if (Th) {
    f = 0;
    do {
      Th = !1;
      Uh = 0;
      if (25 <= f) throw Error(p(301));
      f += 1;
      P = O = null;
      b.updateQueue = null;
      Ph.current = $h;
      a = c(d, e);
    } while (Th);
  }
  Ph.current = ai;
  b = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = !1;
  if (b) throw Error(p(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = O.next;
  var b = null === P ? N.memoizedState : P.next;
  if (null !== b) P = b, O = a;else {
    if (null === a) throw Error(p(310));
    O = a;
    a = {
      memoizedState: O.memoizedState,
      baseState: O.baseState,
      baseQueue: O.baseQueue,
      queue: O.queue,
      next: null
    };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function fi(a) {
  var b = di(),
    c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = O,
    e = d.baseQueue,
    f = c.pending;
  if (null !== f) {
    if (null !== e) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (null !== e) {
    f = e.next;
    d = d.baseState;
    var h = g = null,
      k = null,
      l = f;
    do {
      var m = l.lane;
      if ((Rh & m) === m) null !== k && (k = k.next = {
        lane: 0,
        action: l.action,
        hasEagerState: l.hasEagerState,
        eagerState: l.eagerState,
        next: null
      }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
        var q = {
          lane: m,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null
        };
        null === k ? (h = k = q, g = d) : k = k.next = q;
        N.lanes |= m;
        hh |= m;
      }
      l = l.next;
    } while (null !== l && l !== f);
    null === k ? g = d : k.next = h;
    He(d, b.memoizedState) || (Ug = !0);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e = a;
    do f = e.lane, N.lanes |= f, hh |= f, e = e.next; while (e !== a);
  } else null === e && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function gi(a) {
  var b = di(),
    c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch,
    e = c.pending,
    f = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do f = a(f, g.action), g = g.next; while (g !== e);
    He(f, b.memoizedState) || (Ug = !0);
    b.memoizedState = f;
    null === b.baseQueue && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function hi() {}
function ii(a, b) {
  var c = N,
    d = di(),
    e = b(),
    f = !He(d.memoizedState, e);
  f && (d.memoizedState = e, Ug = !0);
  d = d.queue;
  ji(ki.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d, e, b), void 0, null);
    if (null === R) throw Error(p(349));
    0 !== (Rh & 30) || ni(c, b, e);
  }
  return e;
}
function ni(a, b, c) {
  a.flags |= 16384;
  a = {
    getSnapshot: b,
    value: c
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function mi(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  oi(b) && pi(a);
}
function ki(a, b, c) {
  return c(function () {
    oi(b) && pi(a);
  });
}
function oi(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return !0;
  }
}
function pi(a) {
  var b = Zg(a, 1);
  null !== b && mh(b, a, 1, -1);
}
function qi(a) {
  var b = ci();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = {
    pending: null,
    interleaved: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: ei,
    lastRenderedState: a
  };
  b.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b.memoizedState, a];
}
function li(a, b, c, d) {
  a = {
    tag: a,
    create: b,
    destroy: c,
    deps: d,
    next: null
  };
  b = N.updateQueue;
  null === b ? (b = {
    lastEffect: null,
    stores: null
  }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b, c, d) {
  var e = ci();
  N.flags |= a;
  e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
}
function ui(a, b, c, d) {
  var e = di();
  d = void 0 === d ? null : d;
  var f = void 0;
  if (null !== O) {
    var g = O.memoizedState;
    f = g.destroy;
    if (null !== d && Wh(d, g.deps)) {
      e.memoizedState = li(b, c, f, d);
      return;
    }
  }
  N.flags |= a;
  e.memoizedState = li(1 | b, c, f, d);
}
function vi(a, b) {
  return ti(8390656, 8, a, b);
}
function ji(a, b) {
  return ui(2048, 8, a, b);
}
function wi(a, b) {
  return ui(4, 2, a, b);
}
function xi(a, b) {
  return ui(4, 4, a, b);
}
function yi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function () {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
    b.current = null;
  };
}
function zi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b, a), c);
}
function Ai() {}
function Bi(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}
function Ci(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function Di(a, b, c) {
  if (0 === (Rh & 21)) return a.baseState && (a.baseState = !1, Ug = !0), a.memoizedState = c;
  He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = !0);
  return b;
}
function Ei(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(!0);
  var d = Qh.transition;
  Qh.transition = {};
  try {
    a(!1), b();
  } finally {
    C = c, Qh.transition = d;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b, c) {
  var d = lh(a);
  c = {
    lane: d,
    action: c,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (Hi(a)) Ii(b, c);else if (c = Yg(a, b, c, d), null !== c) {
    var e = L();
    mh(c, a, d, e);
    Ji(c, b, d);
  }
}
function ri(a, b, c) {
  var d = lh(a),
    e = {
      lane: d,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
  if (Hi(a)) Ii(b, e);else {
    var f = a.alternate;
    if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
      var g = b.lastRenderedState,
        h = f(g, c);
      e.hasEagerState = !0;
      e.eagerState = h;
      if (He(h, g)) {
        var k = b.interleaved;
        null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
        b.interleaved = e;
        return;
      }
    } catch (l) {} finally {}
    c = Yg(a, b, e, d);
    null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
  }
}
function Hi(a) {
  var b = a.alternate;
  return a === N || null !== b && b === N;
}
function Ii(a, b) {
  Th = Sh = !0;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Ji(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
var ai = {
    readContext: Vg,
    useCallback: Q,
    useContext: Q,
    useEffect: Q,
    useImperativeHandle: Q,
    useInsertionEffect: Q,
    useLayoutEffect: Q,
    useMemo: Q,
    useReducer: Q,
    useRef: Q,
    useState: Q,
    useDebugValue: Q,
    useDeferredValue: Q,
    useTransition: Q,
    useMutableSource: Q,
    useSyncExternalStore: Q,
    useId: Q,
    unstable_isNewReconciler: !1
  },
  Yh = {
    readContext: Vg,
    useCallback: function (a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function (a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(4194308, 4, yi.bind(null, b, a), c);
    },
    useLayoutEffect: function (a, b) {
      return ti(4194308, 4, a, b);
    },
    useInsertionEffect: function (a, b) {
      return ti(4, 2, a, b);
    },
    useMemo: function (a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: function (a, b, c) {
      var d = ci();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      d.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d.memoizedState, a];
    },
    useRef: function (a) {
      var b = ci();
      a = {
        current: a
      };
      return b.memoizedState = a;
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      return ci().memoizedState = a;
    },
    useTransition: function () {
      var a = qi(!1),
        b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (a, b, c) {
      var d = N,
        e = ci();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(d, b, c);
      }
      e.memoizedState = c;
      var f = {
        value: c,
        getSnapshot: b
      };
      e.queue = f;
      vi(ki.bind(null, d, f, a), [a]);
      d.flags |= 2048;
      li(9, mi.bind(null, d, f, c, b), void 0, null);
      return c;
    },
    useId: function () {
      var a = ci(),
        b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    },
    unstable_isNewReconciler: !1
  },
  Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function () {
      return fi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      var b = di();
      return Di(b, O.memoizedState, a);
    },
    useTransition: function () {
      var a = fi(ei)[0],
        b = di().memoizedState;
      return [a, b];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
  },
  $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function () {
      return gi(ei);
    },
    useDebugValue: Ai,
    useDeferredValue: function (a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    },
    useTransition: function () {
      var a = gi(ei)[0],
        b = di().memoizedState;
      return [a, b];
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
  };
function Ki(a, b) {
  try {
    var c = "",
      d = b;
    do c += Pa(d), d = d.return; while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return {
    value: a,
    source: b,
    stack: e,
    digest: null
  };
}
function Li(a, b, c) {
  return {
    value: a,
    source: null,
    stack: null != c ? c : null,
    digest: null != b ? b : null
  };
}
function Mi(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function () {
      throw c;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = {
    element: null
  };
  var d = b.value;
  c.callback = function () {
    Pi || (Pi = !0, Qi = d);
    Mi(a, b);
  };
  return c;
}
function Ri(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function () {
      return d(e);
    };
    c.callback = function () {
      Mi(a, b);
    };
  }
  var f = a.stateNode;
  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
    Mi(a, b);
    "function" !== typeof d && (null === Si ? Si = new Set([this]) : Si.add(this));
    var c = b.stack;
    this.componentDidCatch(b.value, {
      componentStack: null !== c ? c : ""
    });
  });
  return c;
}
function Ti(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Ni();
    var e = new Set();
    d.set(b, e);
  } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
  e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
}
function Vi(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? !0 : !1 : !0;
    if (b) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b, c, d, e) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Xi = ua.ReactCurrentOwner,
  Ug = !1;
function Yi(a, b, c, d) {
  b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
}
function Zi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  Tg(b, e);
  d = Xh(a, b, c, d, f, e);
  c = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Yi(a, b, d, e);
  return b.child;
}
function aj(a, b, c, d, e) {
  if (null === a) {
    var f = c.type;
    if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d, e);
    a = yh(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f = a.child;
  if (0 === (a.lanes & e)) {
    var g = f.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref) return $i(a, b, e);
  }
  b.flags |= 1;
  a = wh(f, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function cj(a, b, c, d, e) {
  if (null !== a) {
    var f = a.memoizedProps;
    if (Ie(f, d) && a.ref === b.ref) if (Ug = !1, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = !0);else return b.lanes = a.lanes, $i(a, b, e);
  }
  return dj(a, b, c, d, e);
}
function ej(a, b, c) {
  var d = b.pendingProps,
    e = d.children,
    f = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) {
    if (0 === (b.mode & 1)) b.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, G(fj, gj), gj |= c;else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
        baseLanes: a,
        cachePool: null,
        transitions: null
      }, b.updateQueue = null, G(fj, gj), gj |= a, null;
      b.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      };
      d = null !== f ? f.baseLanes : c;
      G(fj, gj);
      gj |= d;
    }
  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
  Yi(a, b, e, c);
  return b.child;
}
function hj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}
function dj(a, b, c, d, e) {
  var f = Zf(c) ? Xf : H.current;
  f = Yf(b, f);
  Tg(b, e);
  c = Xh(a, b, c, d, f, e);
  d = bi();
  if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Yi(a, b, c, e);
  return b.child;
}
function ij(a, b, c, d, e) {
  if (Zf(c)) {
    var f = !0;
    cg(b);
  } else f = !1;
  Tg(b, e);
  if (null === b.stateNode) jj(a, b), ph(b, c, d), rh(b, c, d, e), d = !0;else if (null === a) {
    var g = b.stateNode,
      h = b.memoizedProps;
    g.props = h;
    var k = g.context,
      l = c.contextType;
    "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
    var m = c.getDerivedStateFromProps,
      q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
    q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && qh(b, g, d, l);
    $g = !1;
    var r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    k = b.memoizedState;
    h !== d || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d), k = b.memoizedState), (h = $g || oh(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = !1);
  } else {
    g = b.stateNode;
    bh(a, b);
    h = b.memoizedProps;
    l = b.type === b.elementType ? h : Lg(b.type, h);
    g.props = l;
    q = b.pendingProps;
    r = g.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
    var y = c.getDerivedStateFromProps;
    (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d, k);
    $g = !1;
    r = b.memoizedState;
    g.state = r;
    gh(b, d, g, e);
    var n = b.memoizedState;
    h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d), n = b.memoizedState), (l = $g || oh(b, c, l, d, r, n, k) || !1) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
  }
  return kj(a, b, c, d, f, e);
}
function kj(a, b, c, d, e, f) {
  hj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g) return e && dg(b, c, !1), $i(a, b, f);
  d = b.stateNode;
  Xi.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
  b.memoizedState = d.state;
  e && dg(b, c, !0);
  return b.child;
}
function lj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1);
  Ih(a, b.containerInfo);
}
function mj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Yi(a, b, c, d);
  return b.child;
}
var nj = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};
function oj(a) {
  return {
    baseLanes: a,
    cachePool: null,
    transitions: null
  };
}
function pj(a, b, c) {
  var d = b.pendingProps,
    e = M.current,
    f = !1,
    g = 0 !== (b.flags & 128),
    h;
  (h = g) || (h = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
  if (h) f = !0, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
  G(M, e & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f ? (d = b.mode, f = b.child, g = {
      mode: "hidden",
      children: g
    }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d, 0, null), a = Ah(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
  }
  e = a.memoizedState;
  if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d, h, e, c);
  if (f) {
    f = d.fallback;
    g = b.mode;
    e = a.child;
    h = e.sibling;
    var k = {
      mode: "hidden",
      children: d.children
    };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = wh(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
    f.return = b;
    d.return = b;
    d.sibling = f;
    b.child = d;
    d = f;
    f = b.child;
    g = a.child.memoizedState;
    g = null === g ? oj(c) : {
      baseLanes: g.baseLanes | c,
      cachePool: null,
      transitions: g.transitions
    };
    f.memoizedState = g;
    f.childLanes = a.childLanes & ~c;
    b.memoizedState = nj;
    return d;
  }
  f = a.child;
  a = f.sibling;
  d = wh(f, {
    mode: "visible",
    children: d.children
  });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function rj(a, b) {
  b = qj({
    mode: "visible",
    children: b
  }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function tj(a, b, c, d) {
  null !== d && Jg(d);
  Bh(b, a.child, null, c);
  a = rj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function sj(a, b, c, d, e, f, g) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Li(Error(p(422))), tj(a, b, g, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f = d.fallback;
    e = b.mode;
    d = qj({
      mode: "visible",
      children: d.children
    }, e, 0, null);
    f = Ah(f, e, g, null);
    f.flags |= 2;
    d.return = b;
    f.return = b;
    d.sibling = f;
    b.child = d;
    0 !== (b.mode & 1) && Bh(b, a.child, null, g);
    b.child.memoizedState = oj(g);
    b.memoizedState = nj;
    return f;
  }
  if (0 === (b.mode & 1)) return tj(a, b, g, null);
  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d) var h = d.dgst;
    d = h;
    f = Error(p(419));
    d = Li(f, d, void 0);
    return tj(a, b, g, d);
  }
  h = 0 !== (g & a.childLanes);
  if (Ug || h) {
    d = R;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;
        case 16:
          e = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;
        case 536870912:
          e = 268435456;
          break;
        default:
          e = 0;
      }
      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d, a, e, -1));
    }
    uj();
    d = Li(Error(p(421)));
    return tj(a, b, g, d);
  }
  if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
  a = f.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = !0;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = rj(b, d.children);
  b.flags |= 4096;
  return b;
}
function wj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  Sg(a.return, b, c);
}
function xj(a, b, c, d, e) {
  var f = a.memoizedState;
  null === f ? a.memoizedState = {
    isBackwards: b,
    rendering: null,
    renderingStartTime: 0,
    last: d,
    tail: c,
    tailMode: e
  } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
}
function yj(a, b, c) {
  var d = b.pendingProps,
    e = d.revealOrder,
    f = d.tail;
  Yi(a, b, d.children, c);
  d = M.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
      if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);else if (19 === a.tag) wj(a, c, b);else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;
      for (; null === a.sibling;) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G(M, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
    case "forwards":
      c = b.child;
      for (e = null; null !== c;) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      xj(b, !1, e, c, f);
      break;
    case "backwards":
      c = null;
      e = b.child;
      for (b.child = null; null !== e;) {
        a = e.alternate;
        if (null !== a && null === Mh(a)) {
          b.child = e;
          break;
        }
        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }
      xj(b, !0, c, null, f);
      break;
    case "together":
      xj(b, !1, null, null, void 0);
      break;
    default:
      b.memoizedState = null;
  }
  return b.child;
}
function jj(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function $i(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  hh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p(153));
  if (null !== b.child) {
    a = b.child;
    c = wh(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function zj(a, b, c) {
  switch (b.tag) {
    case 3:
      lj(b);
      Ig();
      break;
    case 5:
      Kh(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      Ih(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context,
        e = b.memoizedProps.value;
      G(Mg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
        G(M, M.current & 1);
        a = $i(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d) return yj(a, b, c);
        b.flags |= 128;
      }
      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(M, M.current);
      if (d) break;else return null;
    case 22:
    case 23:
      return b.lanes = 0, ej(a, b, c);
  }
  return $i(a, b, c);
}
var Aj, Bj, Cj, Dj;
Aj = function (a, b) {
  for (var c = b.child; null !== c;) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;
    for (; null === c.sibling;) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Bj = function () {};
Cj = function (a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    Hh(Eh.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "select":
        e = A({}, e, {
          value: void 0
        });
        d = A({}, d, {
          value: void 0
        });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
      var h = e[l];
      for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
    } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
    for (l in d) {
      var k = d[l];
      h = null != e ? e[l] : void 0;
      if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
        if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(l, c)), c = k;
      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
    }
    c && (f = f || []).push("style", c);
    var l = f;
    if (b.updateQueue = l) b.flags |= 4;
  }
};
Dj = function (a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Ej(a, b) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b = a.tail;
      for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
      null === c ? a.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = a.tail;
      for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}
function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child,
    c = 0,
    d = 0;
  if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Fj(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;
    case 1:
      return Zf(b.type) && $f(), S(b), null;
    case 3:
      d = b.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b);
      S(b);
      return null;
    case 5:
      Lh(b);
      var e = Hh(Gh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
        if (!d) {
          if (null === b.stateNode) throw Error(p(166));
          S(b);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++) D(lf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D("error", d);
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = {
                wasMultiple: !!f.multiple
              };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f), D("invalid", d);
          }
          ub(c, f);
          e = null;
          for (var g in f) if (f.hasOwnProperty(g)) {
            var h = f[g];
            "children" === g ? "string" === typeof h ? d.textContent !== h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (!0 !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
          }
          switch (c) {
            case "input":
              Va(d);
              db(d, f, !0);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f.onClick && (d.onclick = Bf);
          }
          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
            is: d.is
          }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          Aj(a, b, !1, !1);
          b.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D("error", a);
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = {
                  wasMultiple: !!d.multiple
                };
                e = A({}, d, {
                  value: void 0
                });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            ub(c, e);
            h = e;
            for (f in h) if (h.hasOwnProperty(f)) {
              var k = h[f];
              "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
            }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, !1);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f = d.value;
                null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                break;
              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = !0;
                break a;
              default:
                d = !1;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;
    case 6:
      if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d);else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
        c = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
            case 3:
              Af(d.nodeValue, c, 0 !== (a.mode & 1));
              break;
            case 5:
              !0 !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
          }
          f && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S(b);
      return null;
    case 13:
      E(M);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = !1;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f) throw Error(p(318));
            f = b.memoizedState;
            f = null !== f ? f.dehydrated : null;
            if (!f) throw Error(p(317));
            f[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S(b);
          f = !1;
        } else null !== zg && (Gj(zg), zg = null), f = !0;
        if (!f) return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;
    case 4:
      return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
    case 10:
      return Rg(b.type._context), S(b), null;
    case 17:
      return Zf(b.type) && $f(), S(b), null;
    case 19:
      E(M);
      f = b.memoizedState;
      if (null === f) return S(b), null;
      d = 0 !== (b.flags & 128);
      g = f.rendering;
      if (null === g) {
        if (d) Ej(f, !1);else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
            g = Mh(a);
            if (null !== g) {
              b.flags |= 128;
              Ej(f, !1);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                lanes: a.lanes,
                firstContext: a.firstContext
              }), c = c.sibling;
              G(M, M.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Hj && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        }
      } else {
        if (!d) if (a = Mh(g), null !== a) {
          if (b.flags |= 128, d = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, !0), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
        } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = !0, Ej(f, !1), b.lanes = 4194304);
        f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
      }
      if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;
    case 22:
    case 23:
      return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b.tag));
}
function Jj(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Lh(b), null;
    case 13:
      E(M);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = !1,
  U = !1,
  Lj = "function" === typeof WeakSet ? WeakSet : Set,
  V = null;
function Mj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W(a, b, d);
  } else c.current = null;
}
function Nj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}
var Oj = !1;
function Pj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c = {
      start: a.selectionStart,
      end: a.selectionEnd
    };else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();
      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e = d.anchorOffset,
          f = d.focusNode;
        d = d.focusOffset;
        try {
          c.nodeType, f.nodeType;
        } catch (F) {
          c = null;
          break a;
        }
        var g = 0,
          h = -1,
          k = -1,
          l = 0,
          m = 0,
          q = a,
          r = null;
        b: for (;;) {
          for (var y;;) {
            q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
            q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
            3 === q.nodeType && (g += q.nodeValue.length);
            if (null === (y = q.firstChild)) break;
            r = q;
            q = y;
          }
          for (;;) {
            if (q === a) break b;
            r === c && ++l === e && (h = g);
            r === f && ++m === d && (k = g);
            if (null !== (y = q.nextSibling)) break;
            q = r;
            r = q.parentNode;
          }
          q = y;
        }
        c = -1 === h || -1 === k ? null : {
          start: h,
          end: k
        };
      } else c = null;
    }
    c = c || {
      start: 0,
      end: 0
    };
  } else c = null;
  Df = {
    focusedElem: a,
    selectionRange: c
  };
  dd = !1;
  for (V = b; null !== V;) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;else for (; null !== V;) {
    b = V;
    try {
      var n = b.alternate;
      if (0 !== (b.flags & 1024)) switch (b.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n) {
            var t = n.memoizedProps,
              J = n.memoizedState,
              x = b.stateNode,
              w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
            x.__reactInternalSnapshotBeforeUpdate = w;
          }
          break;
        case 3:
          var u = b.stateNode.containerInfo;
          1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p(163));
      }
    } catch (F) {
      W(b, b.return, F);
    }
    a = b.sibling;
    if (null !== a) {
      a.return = b.return;
      V = a;
      break;
    }
    V = b.return;
  }
  n = Oj;
  Oj = !1;
  return n;
}
function Qj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f = e.destroy;
        e.destroy = void 0;
        void 0 !== f && Nj(b, c, f);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Rj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Sj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Tj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Tj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a: for (;;) {
    for (; null === a.sibling;) {
      if (null === a.return || Uj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
}
function Xj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a;) Xj(a, b, c), a = a.sibling;
}
var X = null,
  Yj = !1;
function Zj(a, b, c) {
  for (c = c.child; null !== c;) ak(a, b, c), c = c.sibling;
}
function ak(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c);
  } catch (h) {}
  switch (c.tag) {
    case 5:
      U || Mj(c, b);
    case 6:
      var d = X,
        e = Yj;
      X = null;
      Zj(a, b, c);
      X = d;
      Yj = e;
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d = X;
      e = Yj;
      X = c.stateNode.containerInfo;
      Yj = !0;
      Zj(a, b, c);
      X = d;
      Yj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;
        do {
          var f = e,
            g = f.destroy;
          f = f.tag;
          void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
          e = e.next;
        } while (e !== d);
      }
      Zj(a, b, c);
      break;
    case 1:
      if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h) {
        W(c, b, h);
      }
      Zj(a, b, c);
      break;
    case 21:
      Zj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
      break;
    default:
      Zj(a, b, c);
  }
}
function bk(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b.forEach(function (b) {
      var d = ck.bind(null, a, b);
      c.has(b) || (c.add(b), b.then(d, d));
    });
  }
}
function dk(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e = c[d];
    try {
      var f = a,
        g = b,
        h = g;
      a: for (; null !== h;) {
        switch (h.tag) {
          case 5:
            X = h.stateNode;
            Yj = !1;
            break a;
          case 3:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;
          case 4:
            X = h.stateNode.containerInfo;
            Yj = !0;
            break a;
        }
        h = h.return;
      }
      if (null === X) throw Error(p(160));
      ak(f, g, e);
      X = null;
      Yj = !1;
      var k = e.alternate;
      null !== k && (k.return = null);
      e.return = null;
    } catch (l) {
      W(e, b, l);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) ek(b, a), b = b.sibling;
}
function ek(a, b) {
  var c = a.alternate,
    d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b, a);
      fk(a);
      if (d & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t) {
          W(a, a.return, t);
        }
        try {
          Qj(5, a, a.return);
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 1:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      break;
    case 5:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          ob(e, "");
        } catch (t) {
          W(a, a.return, t);
        }
      }
      if (d & 4 && (e = a.stateNode, null != e)) {
        var f = a.memoizedProps,
          g = null !== c ? c.memoizedProps : f,
          h = a.type,
          k = a.updateQueue;
        a.updateQueue = null;
        if (null !== k) try {
          "input" === h && "radio" === f.type && null != f.name && ab(e, f);
          vb(h, g);
          var l = vb(h, f);
          for (g = 0; g < k.length; g += 2) {
            var m = k[g],
              q = k[g + 1];
            "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
          }
          switch (h) {
            case "input":
              bb(e, f);
              break;
            case "textarea":
              ib(e, f);
              break;
            case "select":
              var r = e._wrapperState.wasMultiple;
              e._wrapperState.wasMultiple = !!f.multiple;
              var y = f.value;
              null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
          }
          e[Pf] = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 6:
      dk(b, a);
      fk(a);
      if (d & 4) {
        if (null === a.stateNode) throw Error(p(162));
        e = a.stateNode;
        f = a.memoizedProps;
        try {
          e.nodeValue = f;
        } catch (t) {
          W(a, a.return, t);
        }
      }
      break;
    case 3:
      dk(b, a);
      fk(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd(b.containerInfo);
      } catch (t) {
        W(a, a.return, t);
      }
      break;
    case 4:
      dk(b, a);
      fk(a);
      break;
    case 13:
      dk(b, a);
      fk(a);
      e = a.child;
      e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
      d & 4 && bk(a);
      break;
    case 22:
      m = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
      fk(a);
      if (d & 8192) {
        l = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m;) {
          for (q = V = m; null !== V;) {
            r = V;
            y = r.child;
            switch (r.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Qj(4, r, r.return);
                break;
              case 1:
                Mj(r, r.return);
                var n = r.stateNode;
                if ("function" === typeof n.componentWillUnmount) {
                  d = r;
                  c = r.return;
                  try {
                    b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                  } catch (t) {
                    W(d, c, t);
                  }
                }
                break;
              case 5:
                Mj(r, r.return);
                break;
              case 22:
                if (null !== r.memoizedState) {
                  hk(q);
                  continue;
                }
            }
            null !== y ? (y.return = r, V = y) : hk(q);
          }
          m = m.sibling;
        }
        a: for (m = null, q = a;;) {
          if (5 === q.tag) {
            if (null === m) {
              m = q;
              try {
                e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
              } catch (t) {
                W(a, a.return, t);
              }
            }
          } else if (6 === q.tag) {
            if (null === m) try {
              q.stateNode.nodeValue = l ? "" : q.memoizedProps;
            } catch (t) {
              W(a, a.return, t);
            }
          } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
            q.child.return = q;
            q = q.child;
            continue;
          }
          if (q === a) break a;
          for (; null === q.sibling;) {
            if (null === q.return || q.return === a) break a;
            m === q && (m = null);
            q = q.return;
          }
          m === q && (m = null);
          q.sibling.return = q.return;
          q = q.sibling;
        }
      }
      break;
    case 19:
      dk(b, a);
      fk(a);
      d & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(b, a), fk(a);
  }
}
function fk(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c;) {
          if (Uj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f = Vj(a);
          Xj(a, f, e);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo,
            h = Vj(a);
          Wj(a, h, g);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k) {
      W(a, a.return, k);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function ik(a, b, c) {
  V = a;
  jk(a, b, c);
}
function jk(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V;) {
    var e = V,
      f = e.child;
    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Kj;
      if (!g) {
        var h = e.alternate,
          k = null !== h && null !== h.memoizedState || U;
        h = Kj;
        var l = U;
        Kj = g;
        if ((U = k) && !l) for (V = e; null !== V;) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
        for (; null !== f;) V = f, jk(f, b, c), f = f.sibling;
        V = e;
        Kj = h;
        U = l;
      }
      lk(a, b, c);
    } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
  }
}
function lk(a) {
  for (; null !== V;) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U || Rj(5, b);
            break;
          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U) if (null === c) d.componentDidMount();else {
              var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
              d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f = b.updateQueue;
            null !== f && ih(b, f, d);
            break;
          case 3:
            var g = b.updateQueue;
            if (null !== g) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;
                case 1:
                  c = b.child.stateNode;
              }
              ih(b, g, c);
            }
            break;
          case 5:
            var h = b.stateNode;
            if (null === c && b.flags & 4) {
              c = h;
              var k = b.memoizedProps;
              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k.autoFocus && c.focus();
                  break;
                case "img":
                  k.src && (c.src = k.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b.memoizedState) {
              var l = b.alternate;
              if (null !== l) {
                var m = l.memoizedState;
                if (null !== m) {
                  var q = m.dehydrated;
                  null !== q && bd(q);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p(163));
        }
        U || b.flags & 512 && Sj(b);
      } catch (r) {
        W(b, b.return, r);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function hk(a) {
  for (; null !== V;) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function kk(a) {
  for (; null !== V;) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Rj(4, b);
          } catch (k) {
            W(b, c, k);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e = b.return;
            try {
              d.componentDidMount();
            } catch (k) {
              W(b, e, k);
            }
          }
          var f = b.return;
          try {
            Sj(b);
          } catch (k) {
            W(b, f, k);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Sj(b);
          } catch (k) {
            W(b, g, k);
          }
      }
    } catch (k) {
      W(b, b.return, k);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h = b.sibling;
    if (null !== h) {
      h.return = b.return;
      V = h;
      break;
    }
    V = b.return;
  }
}
var mk = Math.ceil,
  nk = ua.ReactCurrentDispatcher,
  ok = ua.ReactCurrentOwner,
  pk = ua.ReactCurrentBatchConfig,
  K = 0,
  R = null,
  Y = null,
  Z = 0,
  gj = 0,
  fj = Uf(0),
  T = 0,
  qk = null,
  hh = 0,
  rk = 0,
  sk = 0,
  tk = null,
  uk = null,
  gk = 0,
  Hj = Infinity,
  vk = null,
  Pi = !1,
  Qi = null,
  Si = null,
  wk = !1,
  xk = null,
  yk = 0,
  zk = 0,
  Ak = null,
  Bk = -1,
  Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b, c, d) {
  if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function () {
      0 === (K & 6) && jg();
    }), c = null;else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Hk(a, b) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6)) throw Error(p(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c) return null;
  var d = uc(a, a === R ? Z : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Jk(a, d);else {
    b = d;
    var e = K;
    K |= 2;
    var f = Kk();
    if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
    do try {
      Mk();
      break;
    } catch (h) {
      Nk(a, h);
    } while (1);
    Qg();
    nk.current = f;
    K = e;
    null !== Y ? b = 0 : (R = null, Z = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
    if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
    if (6 === b) Dk(a, d);else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d);
          if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0)) break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              L();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;
          for (e = -1; 0 < d;) {
            var g = 31 - oc(d);
            f = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}
function Ok(a, b) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
  a = Jk(a, b);
  2 !== a && (b = uk, uk = c, null !== b && Gj(b));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b = a;;) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e = c[d],
          f = e.getSnapshot;
        e = e.value;
        try {
          if (!He(f(), e)) return !1;
        } catch (g) {
          return !1;
        }
      }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
      if (b === a) break;
      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return !0;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return !0;
}
function Dk(a, b) {
  b &= ~sk;
  b &= ~rk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b;) {
    var c = 31 - oc(b),
      d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Fk(a) {
  if (0 !== (K & 6)) throw Error(p(327));
  Ik();
  var b = uc(a, 0);
  if (0 === (b & 1)) return Ek(a, B()), null;
  var c = Jk(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Ok(a, d));
  }
  if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
  if (6 === c) throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b) {
  var c = K;
  K |= 1;
  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b = K;
  K |= 1;
  var c = pk.transition,
    d = C;
  try {
    if (pk.transition = null, C = 1, a) return a();
  } finally {
    C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y) for (c = Y.return; null !== c;) {
    var d = c;
    wg(d);
    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;
      case 3:
        Jh();
        E(Wf);
        E(H);
        Oh();
        break;
      case 5:
        Lh(d);
        break;
      case 4:
        Jh();
        break;
      case 13:
        E(M);
        break;
      case 19:
        E(M);
        break;
      case 10:
        Rg(d.type._context);
        break;
      case 22:
      case 23:
        Ij();
    }
    c = c.return;
  }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b = 0; b < Wg.length; b++) if (c = Wg[b], d = c.interleaved, null !== d) {
      c.interleaved = null;
      var e = d.next,
        f = c.pending;
      if (null !== f) {
        var g = f.next;
        f.next = e;
        d.next = g;
      }
      c.pending = d;
    }
    Wg = null;
  }
  return a;
}
function Nk(a, b) {
  do {
    var c = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d = N.memoizedState; null !== d;) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        Sh = !1;
      }
      Rh = 0;
      P = O = N = null;
      Th = !1;
      Uh = 0;
      ok.current = null;
      if (null === c || null === c.return) {
        T = 1;
        qk = b;
        Y = null;
        break;
      }
      a: {
        var f = a,
          g = c.return,
          h = c,
          k = b;
        b = Z;
        h.flags |= 32768;
        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l = k,
            m = h,
            q = m.tag;
          if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
            var r = m.alternate;
            r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
          }
          var y = Vi(g);
          if (null !== y) {
            y.flags &= -257;
            Wi(y, g, h, f, b);
            y.mode & 1 && Ti(f, l, b);
            b = y;
            k = l;
            var n = b.updateQueue;
            if (null === n) {
              var t = new Set();
              t.add(k);
              b.updateQueue = t;
            } else n.add(k);
            break a;
          } else {
            if (0 === (b & 1)) {
              Ti(f, l, b);
              uj();
              break a;
            }
            k = Error(p(426));
          }
        } else if (I && h.mode & 1) {
          var J = Vi(g);
          if (null !== J) {
            0 === (J.flags & 65536) && (J.flags |= 256);
            Wi(J, g, h, f, b);
            Jg(Ki(k, h));
            break a;
          }
        }
        f = k = Ki(k, h);
        4 !== T && (T = 2);
        null === tk ? tk = [f] : tk.push(f);
        f = g;
        do {
          switch (f.tag) {
            case 3:
              f.flags |= 65536;
              b &= -b;
              f.lanes |= b;
              var x = Oi(f, k, b);
              fh(f, x);
              break a;
            case 1:
              h = k;
              var w = f.type,
                u = f.stateNode;
              if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var F = Ri(f, h, b);
                fh(f, F);
                break a;
              }
          }
          f = f.return;
        } while (null !== f);
      }
      Tk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b) {
  var c = K;
  K |= 2;
  var d = Kk();
  if (R !== a || Z !== b) vk = null, Lk(a, b);
  do try {
    Uk();
    break;
  } catch (e) {
    Nk(a, e);
  } while (1);
  Qg();
  K = c;
  nk.current = d;
  if (null !== Y) throw Error(p(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y;) Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc();) Vk(Y);
}
function Vk(a) {
  var b = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b ? Tk(a) : Y = b;
  ok.current = null;
}
function Tk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Fj(c, b, gj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Jj(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
        T = 6;
        Y = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Qk(a, b, c) {
  var d = C,
    e = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b, c, d);
  } finally {
    pk.transition = e, C = d;
  }
  return null;
}
function Xk(a, b, c, d) {
  do Ik(); while (null !== xk);
  if (0 !== (K & 6)) throw Error(p(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f = c.lanes | c.childLanes;
  Bc(a, f);
  a === R && (Y = R = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = !0, Gk(hc, function () {
    Ik();
    return null;
  }));
  f = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f) {
    f = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h = K;
    K |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c, a, e);
    dc();
    K = h;
    C = g;
    pk.transition = f;
  } else a.current = c;
  wk && (wk = !1, xk = a, yk = e);
  f = a.pendingLanes;
  0 === f && (Si = null);
  mc(c.stateNode, d);
  Ek(a, B());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
    componentStack: e.stack,
    digest: e.digest
  });
  if (Pi) throw Pi = !1, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f = a.pendingLanes;
  0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk),
      b = pk.transition,
      c = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk) var d = !1;else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6)) throw Error(p(331));
        var e = K;
        K |= 4;
        for (V = a.current; null !== V;) {
          var f = V,
            g = f.child;
          if (0 !== (V.flags & 16)) {
            var h = f.deletions;
            if (null !== h) {
              for (var k = 0; k < h.length; k++) {
                var l = h[k];
                for (V = l; null !== V;) {
                  var m = V;
                  switch (m.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m, f);
                  }
                  var q = m.child;
                  if (null !== q) q.return = m, V = q;else for (; null !== V;) {
                    m = V;
                    var r = m.sibling,
                      y = m.return;
                    Tj(m);
                    if (m === l) {
                      V = null;
                      break;
                    }
                    if (null !== r) {
                      r.return = y;
                      V = r;
                      break;
                    }
                    V = y;
                  }
                }
              }
              var n = f.alternate;
              if (null !== n) {
                var t = n.child;
                if (null !== t) {
                  n.child = null;
                  do {
                    var J = t.sibling;
                    t.sibling = null;
                    t = J;
                  } while (null !== t);
                }
              }
              V = f;
            }
          }
          if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;else b: for (; null !== V;) {
            f = V;
            if (0 !== (f.flags & 2048)) switch (f.tag) {
              case 0:
              case 11:
              case 15:
                Qj(9, f, f.return);
            }
            var x = f.sibling;
            if (null !== x) {
              x.return = f.return;
              V = x;
              break b;
            }
            V = f.return;
          }
        }
        var w = a.current;
        for (V = w; null !== V;) {
          g = V;
          var u = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;else b: for (g = w; null !== V;) {
            h = V;
            if (0 !== (h.flags & 2048)) try {
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  Rj(9, h);
              }
            } catch (na) {
              W(h, h.return, na);
            }
            if (h === g) {
              V = null;
              break b;
            }
            var F = h.sibling;
            if (null !== F) {
              F.return = h.return;
              V = F;
              break b;
            }
            V = h.return;
          }
        }
        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {}
        d = !0;
      }
      return d;
    } finally {
      C = c, pk.transition = b;
    }
  }
  return !1;
}
function Yk(a, b, c) {
  b = Ki(c, b);
  b = Oi(a, b, 1);
  a = dh(a, b, 1);
  b = L();
  null !== a && (Ac(a, 1, b), Ek(a, b));
}
function W(a, b, c) {
  if (3 === a.tag) Yk(a, a, c);else for (; null !== b;) {
    if (3 === b.tag) {
      Yk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;
      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
        a = Ki(c, a);
        a = Ri(b, a, 1);
        b = dh(b, a, 1);
        a = L();
        null !== b && (Ac(b, 1, a), Ek(b, a));
        break;
      }
    }
    b = b.return;
  }
}
function Ui(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = L();
  a.pingedLanes |= a.suspendedLanes & c;
  R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b);
}
function Zk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L();
  a = Zg(a, b);
  null !== a && (Ac(a, b, c), Ek(a, c));
}
function vj(a) {
  var b = a.memoizedState,
    c = 0;
  null !== b && (c = b.retryLane);
  Zk(a, c);
}
function ck(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d && d.delete(b);
  Zk(a, c);
}
var Wk;
Wk = function (a, b, c) {
  if (null !== a) {
    if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = !0;else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = !1, zj(a, b, c);
      Ug = 0 !== (a.flags & 131072) ? !0 : !1;
    }
  } else Ug = !1, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      jj(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      Tg(b, c);
      e = Xh(null, b, d, a, e, c);
      var f = bi();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, !0, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        jj(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = $k(d);
        a = Lg(d, a);
        switch (e) {
          case 0:
            b = dj(null, b, d, a, c);
            break a;
          case 1:
            b = ij(null, b, d, a, c);
            break a;
          case 11:
            b = Zi(null, b, d, a, c);
            break a;
          case 14:
            b = aj(null, b, d, Lg(d.type, a), c);
            break a;
        }
        throw Error(p(306, d, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
    case 3:
      a: {
        lj(b);
        if (null === a) throw Error(p(387));
        d = b.pendingProps;
        f = b.memoizedState;
        e = f.element;
        bh(a, b);
        gh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f.isDehydrated) {
          if (f = {
            element: d,
            isDehydrated: !1,
            cache: g.cache,
            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
            transitions: g.transitions
          }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ki(Error(p(423)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ki(Error(p(424)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, c = Ch(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
        } else {
          Ig();
          if (d === e) {
            b = $i(a, b, c);
            break a;
          }
          Yi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return pj(a, b, c);
    case 4:
      return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
    case 7:
      return Yi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f = b.memoizedProps;
        g = e.value;
        G(Mg, d._currentValue);
        d._currentValue = g;
        if (null !== f) if (He(f.value, g)) {
          if (f.children === e.children && !Wf.current) {
            b = $i(a, b, c);
            break a;
          }
        } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
          var h = f.dependencies;
          if (null !== h) {
            g = f.child;
            for (var k = h.firstContext; null !== k;) {
              if (k.context === d) {
                if (1 === f.tag) {
                  k = ch(-1, c & -c);
                  k.tag = 2;
                  var l = f.updateQueue;
                  if (null !== l) {
                    l = l.shared;
                    var m = l.pending;
                    null === m ? k.next = k : (k.next = m.next, m.next = k);
                    l.pending = k;
                  }
                }
                f.lanes |= c;
                k = f.alternate;
                null !== k && (k.lanes |= c);
                Sg(f.return, c, b);
                h.lanes |= c;
                break;
              }
              k = k.next;
            }
          } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
            g = f.return;
            if (null === g) throw Error(p(341));
            g.lanes |= c;
            h = g.alternate;
            null !== h && (h.lanes |= c);
            Sg(g, c, b);
            g = f.sibling;
          } else g = f.child;
          if (null !== g) g.return = f;else for (g = f; null !== g;) {
            if (g === b) {
              g = null;
              break;
            }
            f = g.sibling;
            if (null !== f) {
              f.return = g.return;
              g = f;
              break;
            }
            g = g.return;
          }
          f = g;
        }
        Yi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
    case 15:
      return cj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, !0, a, c);
    case 19:
      return yj(a, b, c);
    case 22:
      return ej(a, b, c);
  }
  throw Error(p(156, b.tag));
};
function Gk(a, b) {
  return ac(a, b);
}
function al(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new al(a, b, c, d);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a) return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function wh(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : {
    lanes: b.lanes,
    firstContext: b.firstContext
  };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function yh(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if ("function" === typeof a) bj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
    case ya:
      return Ah(c.children, e, f, b);
    case za:
      g = 8;
      e |= 8;
      break;
    case Aa:
      return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
    case Ea:
      return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
    case Fa:
      return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
    case Ia:
      return qj(c, e, f, b);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g = 10;
          break a;
        case Ca:
          g = 9;
          break a;
        case Da:
          g = 11;
          break a;
        case Ga:
          g = 14;
          break a;
        case Ha:
          g = 16;
          d = null;
          break a;
      }
      throw Error(p(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Ah(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function qj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = {
    isHidden: !1
  };
  return a;
}
function xh(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function zh(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}
function bl(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b, c, d, e, f, g, h, k) {
  a = new bl(a, b, c, h, k);
  1 === b ? (b = 1, !0 === f && (b |= 8)) : b = 0;
  f = Bg(3, null, null, b);
  a.current = f;
  f.stateNode = a;
  f.memoizedState = {
    element: d,
    isDehydrated: c,
    cache: null,
    transitions: null,
    pendingSuspenseBoundaries: null
  };
  ah(f);
  return a;
}
function dl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: wa,
    key: null == d ? null : "" + d,
    children: a,
    containerInfo: b,
    implementation: c
  };
}
function el(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }
  return b;
}
function fl(a, b, c, d, e, f, g, h, k) {
  a = cl(c, d, !0, a, e, f, g, h, k);
  a.context = el(null);
  c = a.current;
  d = L();
  e = lh(c);
  f = ch(d, e);
  f.callback = void 0 !== b && null !== b ? b : null;
  dh(c, f, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Ek(a, d);
  return a;
}
function gl(a, b, c, d) {
  var e = b.current,
    f = L(),
    g = lh(e);
  c = el(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = ch(f, g);
  b.payload = {
    element: a
  };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = dh(e, b, g);
  null !== a && (mh(a, e, g, f), eh(a, e, g));
  return g;
}
function hl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function jl(a, b) {
  il(a, b);
  (a = a.alternate) && il(a, b);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function (a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function (a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p(409));
  gl(a, b, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function () {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Sk(function () {
      gl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function (a) {
  if (a) {
    var b = Hc();
    a = {
      blockedOn: null,
      target: a,
      priority: b
    };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {}
function rl(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f = d;
      d = function () {
        var a = hl(g);
        f.call(a);
      };
    }
    var g = fl(b, d, a, 0, null, !1, !1, "", ql);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g;
  }
  for (; e = a.lastChild;) a.removeChild(e);
  if ("function" === typeof d) {
    var h = d;
    d = function () {
      var a = hl(k);
      h.call(a);
    };
  }
  var k = cl(a, 0, !1, null, null, !1, !1, "", ql);
  a._reactRootContainer = k;
  a[uf] = k.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function () {
    gl(b, k, c, d);
  });
  return k;
}
function sl(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f;
    if ("function" === typeof e) {
      var h = e;
      e = function () {
        var a = hl(g);
        h.call(a);
      };
    }
    gl(b, g, a, e);
  } else g = rl(c, b, a, e, d);
  return hl(g);
}
Ec = function (a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function () {
        var b = Zg(a, 1);
        if (null !== b) {
          var c = L();
          mh(b, a, 1, c);
        }
      }), jl(a, 1);
  }
};
Fc = function (a) {
  if (13 === a.tag) {
    var b = Zg(a, 134217728);
    if (null !== b) {
      var c = L();
      mh(b, a, 134217728, c);
    }
    jl(a, 134217728);
  }
};
Gc = function (a) {
  if (13 === a.tag) {
    var b = lh(a),
      c = Zg(a, b);
    if (null !== c) {
      var d = L();
      mh(c, a, b, d);
    }
    jl(a, b);
  }
};
Hc = function () {
  return C;
};
Ic = function (a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function (a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(p(90));
            Wa(d);
            bb(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, !1);
  }
};
Gb = Rk;
Hb = Sk;
var tl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Rk]
  },
  ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  };
var vl = {
  bundleType: ul.bundleType,
  version: ul.version,
  rendererPackageName: ul.rendererPackageName,
  rendererConfig: ul.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setErrorHandler: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: ua.ReactCurrentDispatcher,
  findHostInstanceByFiber: function (a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  },
  findFiberByHostInstance: ul.findFiberByHostInstance || kl,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null,
  reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber) try {
    kc = wl.inject(vl), lc = wl;
  } catch (a) {}
}
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
exports.createPortal = function (a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b)) throw Error(p(200));
  return dl(a, b, null, c);
};
exports.createRoot = function (a, b) {
  if (!ol(a)) throw Error(p(299));
  var c = !1,
    d = "",
    e = ll;
  null !== b && void 0 !== b && (!0 === b.unstable_strictMode && (c = !0), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = cl(a, 1, !1, null, null, c, !1, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b);
};
exports.findDOMNode = function (a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
exports.flushSync = function (a) {
  return Sk(a);
};
exports.hydrate = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !0, c);
};
exports.hydrateRoot = function (a, b, c) {
  if (!ol(a)) throw Error(p(405));
  var d = null != c && c.hydratedSources || null,
    e = !1,
    f = "",
    g = ll;
  null !== c && void 0 !== c && (!0 === c.unstable_strictMode && (e = !0), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = fl(b, null, a, 1, null != c ? c : null, e, !1, f, g);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
  return new nl(b);
};
exports.render = function (a, b, c) {
  if (!pl(b)) throw Error(p(200));
  return sl(null, a, b, !1, c);
};
exports.unmountComponentAtNode = function (a) {
  if (!pl(a)) throw Error(p(40));
  return a._reactRootContainer ? (Sk(function () {
    sl(null, null, a, !1, function () {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), !0) : !1;
};
exports.unstable_batchedUpdates = Rk;
exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
  if (!pl(c)) throw Error(p(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p(38));
  return sl(a, b, c, !1, d);
};
exports.version = "18.2.0-next-9e3b772b8-20220608";

/***/ }),

/***/ 4723:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var m = __webpack_require__(9834);
if (true) {
  exports.createRoot = m.createRoot;
  exports.hydrateRoot = m.hydrateRoot;
} else { var i; }

/***/ }),

/***/ 9834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(7230);
} else {}

/***/ }),

/***/ 6542:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var b = "function" === typeof Symbol && Symbol.for,
  c = b ? Symbol.for("react.element") : 60103,
  d = b ? Symbol.for("react.portal") : 60106,
  e = b ? Symbol.for("react.fragment") : 60107,
  f = b ? Symbol.for("react.strict_mode") : 60108,
  g = b ? Symbol.for("react.profiler") : 60114,
  h = b ? Symbol.for("react.provider") : 60109,
  k = b ? Symbol.for("react.context") : 60110,
  l = b ? Symbol.for("react.async_mode") : 60111,
  m = b ? Symbol.for("react.concurrent_mode") : 60111,
  n = b ? Symbol.for("react.forward_ref") : 60112,
  p = b ? Symbol.for("react.suspense") : 60113,
  q = b ? Symbol.for("react.suspense_list") : 60120,
  r = b ? Symbol.for("react.memo") : 60115,
  t = b ? Symbol.for("react.lazy") : 60116,
  v = b ? Symbol.for("react.block") : 60121,
  w = b ? Symbol.for("react.fundamental") : 60117,
  x = b ? Symbol.for("react.responder") : 60118,
  y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u = a.$$typeof;
    switch (u) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a;
              default:
                return u;
            }
        }
      case d:
        return u;
    }
  }
}
function A(a) {
  return z(a) === m;
}
exports.AsyncMode = l;
exports.ConcurrentMode = m;
exports.ContextConsumer = k;
exports.ContextProvider = h;
exports.Element = c;
exports.ForwardRef = n;
exports.Fragment = e;
exports.Lazy = t;
exports.Memo = r;
exports.Portal = d;
exports.Profiler = g;
exports.StrictMode = f;
exports.Suspense = p;
exports.isAsyncMode = function (a) {
  return A(a) || z(a) === l;
};
exports.isConcurrentMode = A;
exports.isContextConsumer = function (a) {
  return z(a) === k;
};
exports.isContextProvider = function (a) {
  return z(a) === h;
};
exports.isElement = function (a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
exports.isForwardRef = function (a) {
  return z(a) === n;
};
exports.isFragment = function (a) {
  return z(a) === e;
};
exports.isLazy = function (a) {
  return z(a) === t;
};
exports.isMemo = function (a) {
  return z(a) === r;
};
exports.isPortal = function (a) {
  return z(a) === d;
};
exports.isProfiler = function (a) {
  return z(a) === g;
};
exports.isStrictMode = function (a) {
  return z(a) === f;
};
exports.isSuspense = function (a) {
  return z(a) === p;
};
exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
exports.typeOf = z;

/***/ }),

/***/ 8690:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(6542);
} else {}

/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var f = __webpack_require__(9471),
  k = Symbol.for("react.element"),
  l = Symbol.for("react.fragment"),
  m = Object.prototype.hasOwnProperty,
  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function q(c, a, g) {
  var b,
    d = {},
    e = null,
    h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return {
    $$typeof: k,
    type: c,
    key: e,
    ref: h,
    props: d,
    _owner: n.current
  };
}
exports.Fragment = l;
exports.jsx = q;
exports.jsxs = q;

/***/ }),

/***/ 3534:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var l = Symbol.for("react.element"),
  n = Symbol.for("react.portal"),
  p = Symbol.for("react.fragment"),
  q = Symbol.for("react.strict_mode"),
  r = Symbol.for("react.profiler"),
  t = Symbol.for("react.provider"),
  u = Symbol.for("react.context"),
  v = Symbol.for("react.forward_ref"),
  w = Symbol.for("react.suspense"),
  x = Symbol.for("react.memo"),
  y = Symbol.for("react.lazy"),
  z = Symbol.iterator;
function A(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z && a[z] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  C = Object.assign,
  D = {};
function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {}
F.prototype = E.prototype;
function G(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
var I = Array.isArray,
  J = Object.prototype.hasOwnProperty,
  K = {
    current: null
  },
  L = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };
function M(a, b, e) {
  var d,
    c = {},
    k = null,
    h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
    c.children = f;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return {
    $$typeof: l,
    type: a,
    key: k,
    ref: h,
    props: c,
    _owner: K.current
  };
}
function N(a, b) {
  return {
    $$typeof: l,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}
function O(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l;
}
function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}
var P = /\/+/g;
function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R(a, b, e, d, c) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;
    case "object":
      switch (a.$$typeof) {
        case l:
        case n:
          h = !0;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {
    return a;
  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = d + Q(k, g);
    h += R(k, b, e, f, c);
  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S(a, b, e) {
  if (null == a) return a;
  var d = [],
    c = 0;
  R(a, d, "", "", function (a) {
    return b.call(e, a, c++);
  });
  return d;
}
function T(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (b) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
    }, function (b) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U = {
    current: null
  },
  V = {
    transition: null
  },
  W = {
    ReactCurrentDispatcher: U,
    ReactCurrentBatchConfig: V,
    ReactCurrentOwner: K
  };
exports.Children = {
  map: S,
  forEach: function (a, b, e) {
    S(a, function () {
      b.apply(this, arguments);
    }, e);
  },
  count: function (a) {
    var b = 0;
    S(a, function () {
      b++;
    });
    return b;
  },
  toArray: function (a) {
    return S(a, function (a) {
      return a;
    }) || [];
  },
  only: function (a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  }
};
exports.Component = E;
exports.Fragment = p;
exports.Profiler = r;
exports.PureComponent = G;
exports.StrictMode = q;
exports.Suspense = w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
exports.cloneElement = function (a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C({}, a.props),
    c = a.key,
    k = a.ref,
    h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = K.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    g = Array(f);
    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
    d.children = g;
  }
  return {
    $$typeof: l,
    type: a.type,
    key: c,
    ref: k,
    props: d,
    _owner: h
  };
};
exports.createContext = function (a) {
  a = {
    $$typeof: u,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  };
  a.Provider = {
    $$typeof: t,
    _context: a
  };
  return a.Consumer = a;
};
exports.createElement = M;
exports.createFactory = function (a) {
  var b = M.bind(null, a);
  b.type = a;
  return b;
};
exports.createRef = function () {
  return {
    current: null
  };
};
exports.forwardRef = function (a) {
  return {
    $$typeof: v,
    render: a
  };
};
exports.isValidElement = O;
exports.lazy = function (a) {
  return {
    $$typeof: y,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: T
  };
};
exports.memo = function (a, b) {
  return {
    $$typeof: x,
    type: a,
    compare: void 0 === b ? null : b
  };
};
exports.startTransition = function (a) {
  var b = V.transition;
  V.transition = {};
  try {
    a();
  } finally {
    V.transition = b;
  }
};
exports.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
exports.useCallback = function (a, b) {
  return U.current.useCallback(a, b);
};
exports.useContext = function (a) {
  return U.current.useContext(a);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (a) {
  return U.current.useDeferredValue(a);
};
exports.useEffect = function (a, b) {
  return U.current.useEffect(a, b);
};
exports.useId = function () {
  return U.current.useId();
};
exports.useImperativeHandle = function (a, b, e) {
  return U.current.useImperativeHandle(a, b, e);
};
exports.useInsertionEffect = function (a, b) {
  return U.current.useInsertionEffect(a, b);
};
exports.useLayoutEffect = function (a, b) {
  return U.current.useLayoutEffect(a, b);
};
exports.useMemo = function (a, b) {
  return U.current.useMemo(a, b);
};
exports.useReducer = function (a, b, e) {
  return U.current.useReducer(a, b, e);
};
exports.useRef = function (a) {
  return U.current.useRef(a);
};
exports.useState = function (a) {
  return U.current.useState(a);
};
exports.useSyncExternalStore = function (a, b, e) {
  return U.current.useSyncExternalStore(a, b, e);
};
exports.useTransition = function () {
  return U.current.useTransition();
};
exports.version = "18.2.0";

/***/ }),

/***/ 9471:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(3534);
} else {}

/***/ }),

/***/ 7671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(7933);
} else {}

/***/ }),

/***/ 8582:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function f(a, b) {
  var c = a.length;
  a.push(b);
  a: for (; 0 < c;) {
    var d = c - 1 >>> 1,
      e = a[d];
    if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}
function h(a) {
  return 0 === a.length ? null : a[0];
}
function k(a) {
  if (0 === a.length) return null;
  var b = a[0],
    c = a.pop();
  if (c !== b) {
    a[0] = c;
    a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
      var m = 2 * (d + 1) - 1,
        C = a[m],
        n = m + 1,
        x = a[n];
      if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
    }
  }
  return b;
}
function g(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}
if ("object" === typeof performance && "function" === typeof performance.now) {
  var l = performance;
  exports.unstable_now = function () {
    return l.now();
  };
} else {
  var p = Date,
    q = p.now();
  exports.unstable_now = function () {
    return p.now() - q;
  };
}
var r = [],
  t = [],
  u = 1,
  v = null,
  y = 3,
  z = !1,
  A = !1,
  B = !1,
  D = "function" === typeof setTimeout ? setTimeout : null,
  E = "function" === typeof clearTimeout ? clearTimeout : null,
  F = "undefined" !== typeof setImmediate ? setImmediate : null;
"undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
function G(a) {
  for (var b = h(t); null !== b;) {
    if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
    b = h(t);
  }
}
function H(a) {
  B = !1;
  G(a);
  if (!A) if (null !== h(r)) A = !0, I(J);else {
    var b = h(t);
    null !== b && K(H, b.startTime - a);
  }
}
function J(a, b) {
  A = !1;
  B && (B = !1, E(L), L = -1);
  z = !0;
  var c = y;
  try {
    G(b);
    for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
      var d = v.callback;
      if ("function" === typeof d) {
        v.callback = null;
        y = v.priorityLevel;
        var e = d(v.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? v.callback = e : v === h(r) && k(r);
        G(b);
      } else k(r);
      v = h(r);
    }
    if (null !== v) var w = !0;else {
      var m = h(t);
      null !== m && K(H, m.startTime - b);
      w = !1;
    }
    return w;
  } finally {
    v = null, y = c, z = !1;
  }
}
var N = !1,
  O = null,
  L = -1,
  P = 5,
  Q = -1;
function M() {
  return exports.unstable_now() - Q < P ? !1 : !0;
}
function R() {
  if (null !== O) {
    var a = exports.unstable_now();
    Q = a;
    var b = !0;
    try {
      b = O(!0, a);
    } finally {
      b ? S() : (N = !1, O = null);
    }
  } else N = !1;
}
var S;
if ("function" === typeof F) S = function () {
  F(R);
};else if ("undefined" !== typeof MessageChannel) {
  var T = new MessageChannel(),
    U = T.port2;
  T.port1.onmessage = R;
  S = function () {
    U.postMessage(null);
  };
} else S = function () {
  D(R, 0);
};
function I(a) {
  O = a;
  N || (N = !0, S());
}
function K(a, b) {
  L = D(function () {
    a(exports.unstable_now());
  }, b);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};
exports.unstable_continueExecution = function () {
  A || z || (A = !0, I(J));
};
exports.unstable_forceFrameRate = function (a) {
  0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
};
exports.unstable_getCurrentPriorityLevel = function () {
  return y;
};
exports.unstable_getFirstCallbackNode = function () {
  return h(r);
};
exports.unstable_next = function (a) {
  switch (y) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;
    default:
      b = y;
  }
  var c = y;
  y = b;
  try {
    return a();
  } finally {
    y = c;
  }
};
exports.unstable_pauseExecution = function () {};
exports.unstable_requestPaint = function () {};
exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      a = 3;
  }
  var c = y;
  y = a;
  try {
    return b();
  } finally {
    y = c;
  }
};
exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();
  "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
  switch (a) {
    case 1:
      var e = -1;
      break;
    case 2:
      e = 250;
      break;
    case 5:
      e = 1073741823;
      break;
    case 4:
      e = 1E4;
      break;
    default:
      e = 5E3;
  }
  e = c + e;
  a = {
    id: u++,
    callback: b,
    priorityLevel: a,
    startTime: c,
    expirationTime: e,
    sortIndex: -1
  };
  c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J)));
  return a;
};
exports.unstable_shouldYield = M;
exports.unstable_wrapCallback = function (a) {
  var b = y;
  return function () {
    var c = y;
    y = b;
    try {
      return a.apply(this, arguments);
    } finally {
      y = c;
    }
  };
};

/***/ }),

/***/ 9817:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(8582);
} else {}

/***/ }),

/***/ 2845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./AddCard.tsx": [
		4277,
		4277
	],
	"./ArrowDown.tsx": [
		2041,
		2041
	],
	"./ArrowLeft.tsx": [
		402,
		402
	],
	"./ArrowRight.tsx": [
		8387,
		8387
	],
	"./ArrowUp.tsx": [
		8002,
		8002
	],
	"./AutoCar.tsx": [
		6903,
		6903
	],
	"./AutoCarGuides.tsx": [
		236,
		236
	],
	"./AutoCarNew.tsx": [
		5049,
		5049
	],
	"./AutoCarPurchase.tsx": [
		5002,
		5002
	],
	"./AutoInsurance.tsx": [
		9373,
		9373
	],
	"./Badge.tsx": [
		6487,
		6487
	],
	"./Badge1.tsx": [
		3002,
		3002
	],
	"./Bank.tsx": [
		5934,
		5934
	],
	"./BankBest.tsx": [
		7316,
		7316
	],
	"./BankReviews.tsx": [
		2411,
		2411
	],
	"./BankSearch.tsx": [
		5302,
		5302
	],
	"./Book.tsx": [
		7527,
		7527
	],
	"./Business.tsx": [
		9354,
		9354
	],
	"./Calculator.tsx": [
		2560,
		2560
	],
	"./Calendar.tsx": [
		7566,
		7566
	],
	"./CalendarClock.tsx": [
		3066,
		3066
	],
	"./CalendarDay.tsx": [
		7266,
		7266
	],
	"./CalendarMoney.tsx": [
		4552,
		4552
	],
	"./CalendarX.tsx": [
		3416,
		3416
	],
	"./CarOutline.tsx": [
		3444,
		3444
	],
	"./CaretDown.tsx": [
		1075,
		1075
	],
	"./CaretLeft.tsx": [
		3364,
		3364
	],
	"./CaretRight.tsx": [
		7541,
		7541
	],
	"./CaretUp.tsx": [
		1216,
		1216
	],
	"./Cd.tsx": [
		4293,
		4293
	],
	"./CdRates.tsx": [
		4812,
		4812
	],
	"./Checkmark.tsx": [
		1349,
		1349
	],
	"./CircleCheck.tsx": [
		2098,
		2098
	],
	"./ClockWait.tsx": [
		8127,
		8127
	],
	"./CloseX.tsx": [
		5052,
		5052
	],
	"./Collapse.tsx": [
		9649,
		9649
	],
	"./Congrats.tsx": [
		2195,
		2195
	],
	"./CreditCard.tsx": [
		9733,
		9733
	],
	"./CreditCardApr.tsx": [
		9858,
		9858
	],
	"./CreditCardBalanceTransfer.tsx": [
		8928,
		8928
	],
	"./CreditCardBest.tsx": [
		4487,
		4487
	],
	"./CreditCardCashBack.tsx": [
		549,
		549
	],
	"./CreditCardReviews.tsx": [
		5346,
		5346
	],
	"./CreditCardSearch.tsx": [
		8661,
		8661
	],
	"./CreditCardTime.tsx": [
		4346,
		4346
	],
	"./CreditCardZeroPercent.tsx": [
		52,
		52
	],
	"./CreditExcellent.tsx": [
		3065,
		3065
	],
	"./CreditFair.tsx": [
		1773,
		1773
	],
	"./CreditGood.tsx": [
		9732,
		9732
	],
	"./CreditNone.tsx": [
		2689,
		2689
	],
	"./CreditPoor.tsx": [
		5415,
		5415
	],
	"./Dashboard.tsx": [
		1506,
		1506
	],
	"./Debt.tsx": [
		4203,
		4203
	],
	"./Document.tsx": [
		3043,
		3043
	],
	"./Dollar.tsx": [
		5102,
		5102
	],
	"./DollarCoin.tsx": [
		2925,
		2925
	],
	"./DollarReload.tsx": [
		7209,
		7209
	],
	"./Download.tsx": [
		7220,
		7220
	],
	"./Edit.tsx": [
		3564,
		3564
	],
	"./Education.tsx": [
		5688,
		5688
	],
	"./Email.tsx": [
		5814,
		5814
	],
	"./Error.tsx": [
		9740,
		9740
	],
	"./ErrorAlt.tsx": [
		8255,
		8255
	],
	"./ExternalLink.tsx": [
		6757,
		6757
	],
	"./EyeHide.tsx": [
		4093,
		4093
	],
	"./EyeShow.tsx": [
		4406,
		4406
	],
	"./Facebook.tsx": [
		4596,
		4596
	],
	"./FederalReserve.tsx": [
		5185,
		5185
	],
	"./Filter.tsx": [
		2966,
		2966
	],
	"./GlobeWorld.tsx": [
		9121,
		9121
	],
	"./Help.tsx": [
		1445,
		1445
	],
	"./HomeEquity.tsx": [
		4052,
		4052
	],
	"./Info.tsx": [
		1464,
		1464
	],
	"./Instagram.tsx": [
		5146,
		5146
	],
	"./Insurance.tsx": [
		750,
		750
	],
	"./InsuranceAuto.tsx": [
		6059,
		6059
	],
	"./InsuranceHome.tsx": [
		3811,
		3811
	],
	"./InsuranceHomeAlt.tsx": [
		8294,
		8294
	],
	"./InsuranceLife.tsx": [
		2696,
		2696
	],
	"./Invest.tsx": [
		6535,
		6535
	],
	"./InvestPortfolio.tsx": [
		5567,
		5567
	],
	"./InvestRate.tsx": [
		229,
		229
	],
	"./InvestReview.tsx": [
		1587,
		1587
	],
	"./InvestSearch.tsx": [
		7091,
		7091
	],
	"./Lightbulb.tsx": [
		6203,
		6203
	],
	"./Linkedin.tsx": [
		7542,
		7542
	],
	"./Loan.tsx": [
		3994,
		1613
	],
	"./LoanAuto.tsx": [
		5071,
		5071
	],
	"./LoanHomeImprovement.tsx": [
		1875,
		1875
	],
	"./LoanStudent.tsx": [
		389,
		389
	],
	"./Location.tsx": [
		2529,
		2529
	],
	"./LocationPin.tsx": [
		2736,
		2736
	],
	"./Lock.tsx": [
		9517,
		9517
	],
	"./LockSecure.tsx": [
		1526,
		1526
	],
	"./LogOut.tsx": [
		7010,
		7010
	],
	"./Menu.tsx": [
		6741,
		6741
	],
	"./MenuList.tsx": [
		7305,
		7305
	],
	"./Moneybag.tsx": [
		7862,
		7862
	],
	"./Mortgage.tsx": [
		8766,
		8766
	],
	"./Mortgage15Year.tsx": [
		5755,
		5755
	],
	"./Mortgage30Year.tsx": [
		8256,
		8256
	],
	"./MortgageCalculator.tsx": [
		7830,
		7830
	],
	"./MortgageMarket.tsx": [
		9610,
		9610
	],
	"./MortgagePercent.tsx": [
		9123,
		9123
	],
	"./MortgagePuchase.tsx": [
		9489,
		9489
	],
	"./MortgageQuestions.tsx": [
		7991,
		7991
	],
	"./MortgageRatesDown.tsx": [
		1357,
		1357
	],
	"./MortgageRatesUp.tsx": [
		526,
		526
	],
	"./MortgageReviews.tsx": [
		5915,
		5915
	],
	"./MortgageSearch.tsx": [
		3574,
		3574
	],
	"./Online.tsx": [
		6285,
		6285
	],
	"./OnlineBest.tsx": [
		7871,
		7871
	],
	"./OnlineError.tsx": [
		6403,
		6403
	],
	"./OnlineReviews.tsx": [
		1613,
		3994
	],
	"./OnlineSearch.tsx": [
		893,
		893
	],
	"./Phone.tsx": [
		7614,
		7614
	],
	"./Plus.tsx": [
		4912,
		4912
	],
	"./Profile.tsx": [
		1001,
		1001
	],
	"./Rates.tsx": [
		795,
		795
	],
	"./RatesDown.tsx": [
		8815,
		8815
	],
	"./RemoveCard.tsx": [
		8598,
		8598
	],
	"./Retirement.tsx": [
		7441,
		7441
	],
	"./Rewards.tsx": [
		610,
		610
	],
	"./Ribbon.tsx": [
		7868,
		7868
	],
	"./Savings.tsx": [
		5951,
		5951
	],
	"./SavingsRate.tsx": [
		957,
		957
	],
	"./Search.tsx": [
		1508,
		1508
	],
	"./Share.tsx": [
		871,
		871
	],
	"./Sort.tsx": [
		2676,
		2676
	],
	"./SortTable.tsx": [
		1426,
		1426
	],
	"./SortTableActive.tsx": [
		2856,
		2856
	],
	"./Spinner.tsx": [
		8057,
		8057
	],
	"./Star.tsx": [
		2428,
		2428
	],
	"./StarAlt.tsx": [
		8111,
		8111
	],
	"./Support.tsx": [
		5351,
		5351
	],
	"./Tiktok.tsx": [
		5298,
		5298
	],
	"./Travel.tsx": [
		2460,
		2460
	],
	"./Twitter.tsx": [
		5963,
		5963
	],
	"./TwoThirds.tsx": [
		1730,
		1730
	],
	"./User.tsx": [
		8157,
		8157
	],
	"./Youtube.tsx": [
		6161,
		6161
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = 2845;
module.exports = webpackAsyncContext;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "react-roth-ira:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			8792: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkreact_roth_ira"] = self["webpackChunkreact_roth_ira"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(7671);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(9471);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(4723);
;// CONCATENATED MODULE: ../../src/react/src/constants/MaxLength.ts
var MaxLength_MaxLength;
(function (MaxLength) {
    MaxLength[MaxLength["Text"] = 26] = "Text";
    MaxLength[MaxLength["DefaultWholeNumber"] = 15] = "DefaultWholeNumber";
    MaxLength[MaxLength["DefaultFractionalPart"] = 4] = "DefaultFractionalPart";
    MaxLength[MaxLength["MoneyFractionalPart"] = 2] = "MoneyFractionalPart";
    MaxLength[MaxLength["PercentWholeNumber"] = 3] = "PercentWholeNumber";
})(MaxLength_MaxLength || (MaxLength_MaxLength = {}));
/* harmony default export */ const constants_MaxLength = (MaxLength_MaxLength);

;// CONCATENATED MODULE: ../../src/react/src/utils/Common.ts

var isFloatValue = function (value, unsigned) {
    if (unsigned)
        return /^\d+\.?\d*$/.test(value);
    return /^-?\d*\.?\d*$/.test(value);
};
// Function to format thousand(,) and decimal(.) for numeric values
var commaFormat = function (inputValue, inputType) {
    if (inputValue === 0) {
        return '0';
    }
    if (!inputValue) {
        return '';
    }
    var inputValueString = inputValue.toString();
    var notForTypes = ['text'];
    if (!notForTypes.includes(inputType)) {
        var valueWithoutFormat = inputValueString.replaceAll(',', '');
        if (!isFloatValue(valueWithoutFormat))
            return '';
        var elements = valueWithoutFormat.split('.');
        // Remove leading zeroes
        var integerPart = Number(elements[0]).toString();
        elements[0] = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return elements.join('.');
    }
    return inputValueString;
};
var uniqueKeys = function (prefix) {
    return prefix + Math.floor(Math.random() * 1000000 + 1).toString();
};
var sortArrayOfObjects = function (itemA, itemB, property, order) {
    var orderType = order !== null && order !== void 0 ? order : 'asc';
    var valueA = itemA[property].toUpperCase();
    var valueB = itemB[property].toUpperCase();
    if (valueA < valueB) {
        return orderType === 'asc' ? -1 : 1;
    }
    if (valueA > valueB) {
        return orderType === 'asc' ? 1 : -1;
    }
    return 0;
};
var validateLength = function (value, inputType) {
    if (inputType === 'text') {
        if (value.length > MaxLength.Text) {
            return false;
        }
        return true;
    }
    var _a = value.replaceAll(',', '').split('.'), wholeNumber = _a[0], fractionalPart = _a[1];
    if (inputType === 'percent') {
        if (wholeNumber.length > MaxLength.PercentWholeNumber) {
            return false;
        }
        if ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) > MaxLength.DefaultFractionalPart) {
            return false;
        }
        return true;
    }
    if (inputType === 'money') {
        if (wholeNumber.length > MaxLength.DefaultWholeNumber) {
            return false;
        }
        if ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) > MaxLength.MoneyFractionalPart) {
            return false;
        }
        return true;
    }
    if (inputType === 'number') {
        if (wholeNumber.length > MaxLength.DefaultWholeNumber) {
            return false;
        }
        if ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) > MaxLength.DefaultFractionalPart) {
            return false;
        }
    }
    return true;
};
var isIntegerValue = function (value, unsigned) {
    if (unsigned)
        return /^\d+$/.test(value);
    return /^-?\d+$/.test(value);
};
var validateFloatValue = function (inputValue, inputType) {
    // this validation is valid if the commaFormat function is passed as format function
    if (inputType === 'text')
        return true;
    if (inputValue === '') {
        return true;
    }
    if (!inputValue) {
        return false;
    }
    var valueWithoutFormat = inputValue.toString().replaceAll(',', '');
    if (valueWithoutFormat === '')
        return true;
    if (!isFloatValue(valueWithoutFormat, true)) {
        return false;
    }
    return validateLength(valueWithoutFormat, inputType);
};
var validateIntegerValue = function (inputValue, inputType) {
    if (inputValue === '') {
        return true;
    }
    if (!inputValue) {
        return false;
    }
    var inputValueString = inputValue.toString();
    // this validation is valid if the commaFormat function is passed as format function
    if (inputType === 'text')
        return true;
    var valueWithoutFormat = inputValueString.replaceAll(',', '');
    if (valueWithoutFormat === '')
        return true;
    if (!isIntegerValue(valueWithoutFormat, true)) {
        return false;
    }
    return validateLength(valueWithoutFormat, inputType);
};
var unformattedNumericValues = function (value, formatCharacter) {
    if (formatCharacter === void 0) { formatCharacter = ','; }
    if (value === '')
        return 0;
    var valueWithoutFormat = value.replaceAll(formatCharacter, '');
    if (!isFloatValue(valueWithoutFormat))
        return 0;
    return parseFloat(valueWithoutFormat);
};
var convertStringToNumberOrNull = function (value) {
    if (value === '0') {
        return 0;
    }
    if (!value) {
        return null;
    }
    var valueWithoutFormat = value.replaceAll(',', '');
    if (!isIntegerValue(valueWithoutFormat) &&
        !isFloatValue(valueWithoutFormat)) {
        return null;
    }
    return Number(valueWithoutFormat);
};
var convertStringToNumber = function (value) {
    var _a;
    return (_a = convertStringToNumberOrNull(value)) !== null && _a !== void 0 ? _a : 0;
};

;// CONCATENATED MODULE: ./components/helpers.ts
/* eslint-disable no-plusplus */

// https://www.irs.gov/retirement-plans/plan-participant-employee/retirement-topics-ira-contribution-limits
// values for 2023
var maximumAnnualContributionUnder50y = 7000;
var maximumAnnualContributionAbove50y = 8000;
/**
 * Checks if the key value map has any error strings. Will be considered valid if there
 * are no error messages in the values
 * @param validationErrors
 * @returns
 */
function hasValidationErrors(validationErrors) {
    return Object.keys(validationErrors).reduce(function (memo, nextKey) { return (memo ? true : !!validationErrors[nextKey]); }, false);
}
function convertTextInputs(dataIn) {
    return {
        startBalance: parseFloat(dataIn.startBalance),
        annualContribution: parseFloat(dataIn.annualContribution),
        currentAge: parseFloat(dataIn.currentAge),
        ageOfRetirement: parseFloat(dataIn.ageOfRetirement),
        expectedRateOfReturn: parseFloat(dataIn.expectedRateOfReturn) / 100,
        marginalTaxRate: parseFloat(dataIn.marginalTaxRate) / 100,
        maximize: dataIn.maximize === 'yes',
    };
}
function calculateRothIRAOverTime(values) {
    var _a = convertTextInputs(values), currentAge = _a.currentAge, ageOfRetirement = _a.ageOfRetirement, annualContribution = _a.annualContribution, startBalance = _a.startBalance, expectedRateOfReturn = _a.expectedRateOfReturn, marginalTaxRate = _a.marginalTaxRate, maximize = _a.maximize;
    var taxedROR = expectedRateOfReturn * (1 - marginalTaxRate);
    var taxableAdditionalEarnings = [];
    var taxableOriginalEarnings = [];
    var rothOriginalEarnings = [];
    var rothAdditionalEarnings = [];
    var totalEarnings = 0;
    var contributionLimit;
    for (var year = currentAge - 1; year < ageOfRetirement; year++) {
        var taxableOriginal = startBalance * Math.pow((1 + taxedROR), (year - currentAge));
        var originalRoth = startBalance * Math.pow((1 + expectedRateOfReturn), (year - currentAge));
        taxableOriginalEarnings.push(taxableOriginal);
        rothOriginalEarnings.push(originalRoth);
        if (annualContribution > maximumAnnualContributionUnder50y && year < 50) {
            contributionLimit = maximumAnnualContributionUnder50y;
        }
        else if (annualContribution > 7000 && year >= 50) {
            contributionLimit = maximumAnnualContributionAbove50y;
        }
        else {
            contributionLimit = annualContribution;
        }
        if (maximize) {
            contributionLimit =
                year >= 50
                    ? maximumAnnualContributionAbove50y
                    : maximumAnnualContributionUnder50y;
        }
        var taxableAdditionalTotal = contributionLimit *
            ((Math.pow((1 + taxedROR), (year - currentAge + 1)) - 1) / taxedROR);
        var rothAdditionalTotal = contributionLimit *
            ((Math.pow((1 + expectedRateOfReturn), (year - currentAge + 1)) - 1) /
                expectedRateOfReturn);
        taxableAdditionalEarnings.push(taxableAdditionalTotal);
        rothAdditionalEarnings.push(rothAdditionalTotal);
    }
    var taxableEarningsOverTime = taxableOriginalEarnings.map(function (original, i) { return original + taxableAdditionalEarnings[i]; });
    var rothEarningsOverTime = rothOriginalEarnings.map(function (original, i) { return original + rothAdditionalEarnings[i]; });
    totalEarnings = rothEarningsOverTime[rothEarningsOverTime.length - 1];
    var earnings = [];
    for (var i = 0; i < taxableEarningsOverTime.length; i++) {
        earnings.push({
            year: i + currentAge,
            rothEarnings: rothEarningsOverTime[i],
            taxableEarnings: taxableEarningsOverTime[i],
        });
    }
    return { totalEarnings: totalEarnings, earnings: earnings };
}
//  Simple money formatter using the current comma formatter
var formatMoney = function (amount) {
    return "$".concat(commaFormat(parseFloat(amount).toFixed(2), 'money'));
};
//  Simple money string cleaner
var cleanCommas = function (amount) { return amount.replaceAll(',', ''); };

;// CONCATENATED MODULE: ./tracking/tracking.ts
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var emitEvent = function (eventType, eventPayload) {
    if (typeof window.tagular === 'function') {
        window.tagular('beam', __assign({ '@type': eventType }, eventPayload));
    }
};
var trackFormSubmit = function (data) {
    emitEvent('redventures.usertracking.v3.FormSubmitted', data);
};
var trackElementClicked = function (data) {
    emitEvent('redventures.usertracking.v3.ElementClicked', data);
};
var trackFieldInput = function (data) {
    emitEvent('redventures.usertracking.v3.FieldInputted', data);
};

// EXTERNAL MODULE: ./node_modules/highcharts/highcharts.js
var highcharts = __webpack_require__(7684);
// EXTERNAL MODULE: ./node_modules/highcharts-react-official/dist/highcharts-react.min.js
var highcharts_react_min = __webpack_require__(1427);
var highcharts_react_min_default = /*#__PURE__*/__webpack_require__.n(highcharts_react_min);
// EXTERNAL MODULE: ./node_modules/highcharts/modules/accessibility.js
var accessibility = __webpack_require__(1631);
var accessibility_default = /*#__PURE__*/__webpack_require__.n(accessibility);
;// CONCATENATED MODULE: ../../src/react/src/constants/colors.ts
var CHART_COLORS = [
    ['#4898ff'],
    ['#4898ff', '#88dd9b'],
    ['#4898ff', '#88dd9b', '#0041a7'],
    ['#4898ff', '#a5d4f4', '#359367', '#2b0086'],
    ['#4898ff', '#88dd9b', '#7c64c3', '#a5d4f4', '#2b0086'],
    ['#4898ff', '#88dd9b', '#7c64c3', '#0041a7', '#359367', '#2b0086'],
    ['#4898ff', '#88dd9b', '#7c64c3', '#a5d4f4', '#0041a7', '#359367', '#2b0086'],
];
var COLORS_NAMES_ARRAY = (/* unused pure expression or super */ null && ([
    'blue-light',
    'blue',
    'blue-mid',
    'blue-dark',
    'teal',
    'white',
    'gray-light',
    'gray',
    'gray-medium',
    'slate',
    'black',
    'green',
    'green-dark',
    'red-light',
    'red',
    'gold',
    'yellow',
    'transparent',
]));
/* harmony default export */ const colors = (CHART_COLORS);

;// CONCATENATED MODULE: ../../src/react/src/components/LineChartHC/LineChartHCProps.ts

var getConfigObj = function (charData) {
    var _a, _b, _c, _d, _e, _f, _g;
    var configObj = {
        title: {
            text: charData.title,
            align: (_a = charData.titleAlign) !== null && _a !== void 0 ? _a : 'center',
            style: {
                fontFamily: 'CircularStd-Bold, Arial, sans-serif',
            },
        },
        chart: {
            width: charData.width,
            height: charData.height,
            animation: charData.animation,
        },
        subtitle: {
            text: (_b = charData.subtitle) !== null && _b !== void 0 ? _b : '',
            align: (_c = charData.subtitleAlign) !== null && _c !== void 0 ? _c : 'center',
            style: {
                fontFamily: 'CircularStd-Book, Arial, sans-serif',
                fontSize: '1rem',
            },
        },
        yAxis: {
            max: charData.yAxisMax,
            title: {
                text: charData.yAxisTitle,
            },
            labels: {
                formatter: charData.yAxisFormatter,
            },
        },
        xAxis: {
            categories: charData.xAxisCategories,
            labels: {
                style: {
                    fontFamily: 'CircularStd-Book, Arial, sans-serif',
                    fontSize: '0.875rem',
                },
            },
        },
        legend: {
            layout: (_d = charData.legendLayoutOrientation) !== null && _d !== void 0 ? _d : 'horizontal',
            align: (_e = charData.legendHorizontalAlign) !== null && _e !== void 0 ? _e : 'center',
            verticalAlign: (_f = charData.legendVerticalAlign) !== null && _f !== void 0 ? _f : 'bottom',
        },
        tooltip: {
            pointFormat: (_g = charData.tooltipFormat) !== null && _g !== void 0 ? _g : '{series.name}: <b>{point.y}</b>',
        },
        series: charData.seriesData.map(function (item) { return ({
            name: item.name,
            type: 'line',
            data: item.data,
            color: item.color,
            dataLabels: {
                enabled: charData.dataLabelsFormat !== undefined,
                color: 'black',
                align: 'center',
                format: charData.dataLabelsFormat,
                y: 1,
                style: {
                    fontSize: '0.875rem',
                    fontFamily: 'CircularStd-Book, Arial, sans-serif',
                },
            },
        }); }),
        responsive: {
            rules: [
                {
                    condition: {
                        maxWidth: 598,
                    },
                    chartOptions: {
                        legend: {
                            layout: 'horizontal',
                            align: 'center',
                            verticalAlign: 'bottom',
                        },
                    },
                },
            ],
        },
        colors: colors[charData.seriesData.length - 1],
        credits: {
            enabled: false,
        },
        plotOptions: {
            series: {
                events: {
                    legendItemClick: function () {
                        return false;
                    },
                },
            },
        },
    };
    return configObj;
};

;// CONCATENATED MODULE: ../../src/react/src/components/ChartContainer/ChartContainer.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ChartContainer_module = ({"InnerContainer":"PGMa14s7YZwSEons3M0S","OuterContainer":"ZmChyOybOo4K3hOOs7Br"});
;// CONCATENATED MODULE: ../../src/react/src/components/ChartContainer/index.tsx
var ChartContainer_assign = (undefined && undefined.__assign) || function () {
    ChartContainer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ChartContainer_assign.apply(this, arguments);
};



function ChartContainer(props) {
    var children = props.children, height = props.height, className = props.className;
    return ((0,jsx_runtime.jsx)("div", ChartContainer_assign({ className: "".concat(ChartContainer_module.OuterContainer, " ").concat(className), style: { height: "".concat(height, "px") } }, { children: (0,jsx_runtime.jsx)("div", ChartContainer_assign({ className: ChartContainer_module.InnerContainer }, { children: children })) })));
}
/* harmony default export */ const components_ChartContainer = (ChartContainer);

;// CONCATENATED MODULE: ../../src/react/src/components/LineChartHC/LineChartHC.tsx
var LineChartHC_assign = (undefined && undefined.__assign) || function () {
    LineChartHC_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return LineChartHC_assign.apply(this, arguments);
};







if (typeof window !== "undefined") {
    accessibility_default()(highcharts);
}
function LineChartHC(props) {
    var className = props.className, height = props.height, title = props.title;
    highcharts.setOptions({
        lang: {
            thousandsSep: ',',
            accessibility: {
                svgContainerLabel: title !== null && title !== void 0 ? title : 'Highcharts svg graph',
            },
        },
    });
    return ((0,jsx_runtime.jsx)(components_ChartContainer, LineChartHC_assign({ className: className, height: height !== null && height !== void 0 ? height : 0 }, { children: (0,jsx_runtime.jsx)((highcharts_react_min_default()), { highcharts: highcharts, options: getConfigObj(props) }) })));
}
/* harmony default export */ const LineChartHC_LineChartHC = (LineChartHC);

;// CONCATENATED MODULE: ../../src/react/src/components/LineChartHC/index.ts



;// CONCATENATED MODULE: ./node_modules/react-number-format/dist/react-number-format.es.js
/**
 * react-number-format - 5.3.4
 * Author : Sudhanshu Yadav
 * Copyright (c) 2016, 2024 to Sudhanshu Yadav, released under the MIT license.
 * https://github.com/s-yadav/react-number-format
 */



/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
      t[p] = s[p];
    }
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
        t[p[i]] = s[p[i]];
      }
    }
  }
  return t;
}
var SourceType;
(function (SourceType) {
  SourceType["event"] = "event";
  SourceType["props"] = "prop";
})(SourceType || (SourceType = {}));

// basic noop function
function noop() {}
function memoizeOnce(cb) {
  var lastArgs;
  var lastValue = undefined;
  return function () {
    var args = [],
      len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (lastArgs && args.length === lastArgs.length && args.every(function (value, index) {
      return value === lastArgs[index];
    })) {
      return lastValue;
    }
    lastArgs = args;
    lastValue = cb.apply(void 0, args);
    return lastValue;
  };
}
function charIsNumber(char) {
  return !!(char || '').match(/\d/);
}
function isNil(val) {
  return val === null || val === undefined;
}
function isNanValue(val) {
  return typeof val === 'number' && isNaN(val);
}
function isNotValidValue(val) {
  return isNil(val) || isNanValue(val) || typeof val === 'number' && !isFinite(val);
}
function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}
function getThousandsGroupRegex(thousandsGroupStyle) {
  switch (thousandsGroupStyle) {
    case 'lakh':
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case 'wan':
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case 'thousand':
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
  var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  var index = str.search(/[1-9]/);
  index = index === -1 ? str.length : index;
  return str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, '$1' + thousandSeparator);
}
function usePersistentCallback(cb) {
  var callbackRef = (0,react.useRef)(cb);
  // keep the callback ref upto date
  callbackRef.current = cb;
  /**
   * initialize a persistent callback which never changes
   * through out the component lifecycle
   */
  var persistentCbRef = (0,react.useRef)(function () {
    var args = [],
      len = arguments.length;
    while (len--) args[len] = arguments[len];
    return callbackRef.current.apply(callbackRef, args);
  });
  return persistentCbRef.current;
}
//spilt a float number into different parts beforeDecimal, afterDecimal, and negation
function splitDecimal(numStr, allowNegative) {
  if (allowNegative === void 0) allowNegative = true;
  var hasNegation = numStr[0] === '-';
  var addNegation = hasNegation && allowNegative;
  numStr = numStr.replace('-', '');
  var parts = numStr.split('.');
  var beforeDecimal = parts[0];
  var afterDecimal = parts[1] || '';
  return {
    beforeDecimal: beforeDecimal,
    afterDecimal: afterDecimal,
    hasNegation: hasNegation,
    addNegation: addNegation
  };
}
function fixLeadingZero(numStr) {
  if (!numStr) {
    return numStr;
  }
  var isNegative = numStr[0] === '-';
  if (isNegative) {
    numStr = numStr.substring(1, numStr.length);
  }
  var parts = numStr.split('.');
  var beforeDecimal = parts[0].replace(/^0+/, '') || '0';
  var afterDecimal = parts[1] || '';
  return "" + (isNegative ? '-' : '') + beforeDecimal + (afterDecimal ? "." + afterDecimal : '');
}
/**
 * limit decimal numbers to given scale
 * Not used .fixedTo because that will break with big numbers
 */
function limitToScale(numStr, scale, fixedDecimalScale) {
  var str = '';
  var filler = fixedDecimalScale ? '0' : '';
  for (var i = 0; i <= scale - 1; i++) {
    str += numStr[i] || filler;
  }
  return str;
}
function repeat(str, count) {
  return Array(count + 1).join(str);
}
function toNumericString(num) {
  var _num = num + ''; // typecast number to string
  // store the sign and remove it from the number.
  var sign = _num[0] === '-' ? '-' : '';
  if (sign) {
    _num = _num.substring(1);
  }
  // split the number into cofficient and exponent
  var ref = _num.split(/[eE]/g);
  var coefficient = ref[0];
  var exponent = ref[1];
  // covert exponent to number;
  exponent = Number(exponent);
  // if there is no exponent part or its 0, return the coffiecient with sign
  if (!exponent) {
    return sign + coefficient;
  }
  coefficient = coefficient.replace('.', '');
  /**
   * for scientific notation the current decimal index will be after first number (index 0)
   * So effective decimal index will always be 1 + exponent value
   */
  var decimalIndex = 1 + exponent;
  var coffiecientLn = coefficient.length;
  if (decimalIndex < 0) {
    // if decimal index is less then 0 add preceding 0s
    // add 1 as join will have
    coefficient = '0.' + repeat('0', Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    // if decimal index is less then 0 add leading 0s
    coefficient = coefficient + repeat('0', decimalIndex - coffiecientLn);
  } else {
    // else add decimal point at proper index
    coefficient = (coefficient.substring(0, decimalIndex) || '0') + '.' + coefficient.substring(decimalIndex);
  }
  return sign + coefficient;
}
/**
 * This method is required to round prop value to given scale.
 * Not used .round or .fixedTo because that will break with big numbers
 */
function roundToPrecision(numStr, scale, fixedDecimalScale) {
  //if number is empty don't do anything return empty string
  if (['', '-'].indexOf(numStr) !== -1) {
    return numStr;
  }
  var shouldHaveDecimalSeparator = (numStr.indexOf('.') !== -1 || fixedDecimalScale) && scale;
  var ref = splitDecimal(numStr);
  var beforeDecimal = ref.beforeDecimal;
  var afterDecimal = ref.afterDecimal;
  var hasNegation = ref.hasNegation;
  var floatValue = parseFloat("0." + (afterDecimal || '0'));
  var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
  var roundedDecimalParts = floatValueStr.split('.');
  var intPart = beforeDecimal;
  // if we have cary over from rounding decimal part, add that on before decimal
  if (beforeDecimal && Number(roundedDecimalParts[0])) {
    intPart = beforeDecimal.split('').reverse().reduce(function (roundedStr, current, idx) {
      if (roundedStr.length > idx) {
        return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
      }
      return current + roundedStr;
    }, roundedDecimalParts[0]);
  }
  var decimalPart = limitToScale(roundedDecimalParts[1] || '', scale, fixedDecimalScale);
  var negation = hasNegation ? '-' : '';
  var decimalSeparator = shouldHaveDecimalSeparator ? '.' : '';
  return "" + negation + intPart + decimalSeparator + decimalPart;
}
/** set the caret positon in an input field **/
function setCaretPosition(el, caretPos) {
  el.value = el.value;
  // ^ this is used to not only get 'focus', but
  // to make sure we don't have it everything -selected-
  // (it causes an issue in chrome, and having it doesn't hurt any other browser)
  if (el !== null) {
    /* @ts-ignore */
    if (el.createTextRange) {
      /* @ts-ignore */
      var range = el.createTextRange();
      range.move('character', caretPos);
      range.select();
      return true;
    }
    // (el.selectionStart === 0 added for Firefox bug)
    if (el.selectionStart || el.selectionStart === 0) {
      el.focus();
      el.setSelectionRange(caretPos, caretPos);
      return true;
    }
    // fail city, fortunately this never happens (as far as I've tested) :)
    el.focus();
    return false;
  }
}
var findChangeRange = memoizeOnce(function (prevValue, newValue) {
  var i = 0,
    j = 0;
  var prevLength = prevValue.length;
  var newLength = newValue.length;
  while (prevValue[i] === newValue[i] && i < prevLength) {
    i++;
  }
  //check what has been changed from last
  while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) {
    j++;
  }
  return {
    from: {
      start: i,
      end: prevLength - j
    },
    to: {
      start: i,
      end: newLength - j
    }
  };
});
/*
  Returns a number whose value is limited to the given range
*/
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function geInputCaretPosition(el) {
  /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/
  return Math.max(el.selectionStart, el.selectionEnd);
}
function addInputMode() {
  return typeof navigator !== 'undefined' && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: value.length
    },
    lastValue: ''
  };
}
function getMaskAtIndex(mask, index) {
  if (mask === void 0) mask = ' ';
  if (typeof mask === 'string') {
    return mask;
  }
  return mask[index] || ' ';
}
function defaultIsCharacterSame(ref) {
  var currentValue = ref.currentValue;
  var formattedValue = ref.formattedValue;
  var currentValueIndex = ref.currentValueIndex;
  var formattedValueIndex = ref.formattedValueIndex;
  return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter,
/**
 * format function can change the character, the caret engine relies on mapping old value and new value
 * In such case if character is changed, parent can tell which chars are equivalent
 * Some example, all allowedDecimalCharacters are updated to decimalCharacters, 2nd case if user is coverting
 * number to different numeric system.
 */
isCharacterSame) {
  if (isCharacterSame === void 0) isCharacterSame = defaultIsCharacterSame;

  /**
   * if something got inserted on empty value, add the formatted character before the current value,
   * This is to avoid the case where typed character is present on format characters
   */
  var firstAllowedPosition = boundary.findIndex(function (b) {
    return b;
  });
  var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
  if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
    lastFormattedValue = prefixFormat;
    curValue = prefixFormat + curValue;
    curCaretPos = curCaretPos + prefixFormat.length;
  }
  var curValLn = curValue.length;
  var formattedValueLn = newFormattedValue.length;
  // create index map
  var addedIndexMap = {};
  var indexMap = new Array(curValLn);
  for (var i = 0; i < curValLn; i++) {
    indexMap[i] = -1;
    for (var j = 0, jLn = formattedValueLn; j < jLn; j++) {
      var isCharSame = isCharacterSame({
        currentValue: curValue,
        lastValue: lastFormattedValue,
        formattedValue: newFormattedValue,
        currentValueIndex: i,
        formattedValueIndex: j
      });
      if (isCharSame && addedIndexMap[j] !== true) {
        indexMap[i] = j;
        addedIndexMap[j] = true;
        break;
      }
    }
  }
  /**
   * For current caret position find closest characters (left and right side)
   * which are properly mapped to formatted value.
   * The idea is that the new caret position will exist always in the boundary of
   * that mapped index
   */
  var pos = curCaretPos;
  while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) {
    pos++;
  }
  // if the caret position is on last keep the endIndex as last for formatted value
  var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
  pos = curCaretPos - 1;
  while (pos > 0 && indexMap[pos] === -1) {
    pos--;
  }
  var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
  /**
   * case where a char is added on suffix and removed from middle, example 2sq345 becoming $2,345 sq
   * there is still a mapping but the order of start index and end index is changed
   */
  if (startIndex > endIndex) {
    return endIndex;
  }
  /**
   * given the current caret position if it closer to startIndex
   * keep the new caret position on start index or keep it closer to endIndex
   */
  return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
/* This keeps the caret within typing area so people can't type in between prefix or suffix or format characters */
function getCaretPosInBoundary(value, caretPos, boundary, direction) {
  var valLn = value.length;
  // clamp caret position to [0, value.length]
  caretPos = clamp(caretPos, 0, valLn);
  if (direction === 'left') {
    while (caretPos >= 0 && !boundary[caretPos]) {
      caretPos--;
    }
    // if we don't find any suitable caret position on left, set it on first allowed position
    if (caretPos === -1) {
      caretPos = boundary.indexOf(true);
    }
  } else {
    while (caretPos <= valLn && !boundary[caretPos]) {
      caretPos++;
    }
    // if we don't find any suitable caret position on right, set it on last allowed position
    if (caretPos > valLn) {
      caretPos = boundary.lastIndexOf(true);
    }
  }
  // if we still don't find caret position, set it at the end of value
  if (caretPos === -1) {
    caretPos = valLn;
  }
  return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
  var boundaryAry = Array.from({
    length: formattedValue.length + 1
  }).map(function () {
    return true;
  });
  for (var i = 0, ln = boundaryAry.length; i < ln; i++) {
    // consider caret to be in boundary if it is before or after numeric value
    boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));
  }
  return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format, removeFormatting, onValueChange) {
  if (onValueChange === void 0) onValueChange = noop;
  var getValues = usePersistentCallback(function (value, valueIsNumericString) {
    var formattedValue, numAsString;
    if (isNotValidValue(value)) {
      numAsString = '';
      formattedValue = '';
    } else if (typeof value === 'number' || valueIsNumericString) {
      numAsString = typeof value === 'number' ? toNumericString(value) : value;
      formattedValue = format(numAsString);
    } else {
      numAsString = removeFormatting(value, undefined);
      formattedValue = format(numAsString);
    }
    return {
      formattedValue: formattedValue,
      numAsString: numAsString
    };
  });
  var ref = (0,react.useState)(function () {
    return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);
  });
  var values = ref[0];
  var setValues = ref[1];
  var _onValueChange = function (newValues, sourceInfo) {
    if (newValues.formattedValue !== values.formattedValue) {
      setValues({
        formattedValue: newValues.formattedValue,
        numAsString: newValues.value
      });
    }
    // call parent on value change if only if formatted value is changed
    onValueChange(newValues, sourceInfo);
  };
  // if value is switch from controlled to uncontrolled, use the internal state's value to format with new props
  var _value = value;
  var _valueIsNumericString = valueIsNumericString;
  if (isNil(value)) {
    _value = values.numAsString;
    _valueIsNumericString = true;
  }
  var newValues = getValues(_value, _valueIsNumericString);
  (0,react.useMemo)(function () {
    setValues(newValues);
  }, [newValues.formattedValue]);
  return [values, _onValueChange];
}
function defaultRemoveFormatting(value) {
  return value.replace(/[^0-9]/g, '');
}
function defaultFormat(value) {
  return value;
}
function NumberFormatBase(props) {
  var type = props.type;
  if (type === void 0) type = 'text';
  var displayType = props.displayType;
  if (displayType === void 0) displayType = 'input';
  var customInput = props.customInput;
  var renderText = props.renderText;
  var getInputRef = props.getInputRef;
  var format = props.format;
  if (format === void 0) format = defaultFormat;
  var removeFormatting = props.removeFormatting;
  if (removeFormatting === void 0) removeFormatting = defaultRemoveFormatting;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var isAllowed = props.isAllowed;
  var onChange = props.onChange;
  if (onChange === void 0) onChange = noop;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0) onKeyDown = noop;
  var onMouseUp = props.onMouseUp;
  if (onMouseUp === void 0) onMouseUp = noop;
  var onFocus = props.onFocus;
  if (onFocus === void 0) onFocus = noop;
  var onBlur = props.onBlur;
  if (onBlur === void 0) onBlur = noop;
  var propValue = props.value;
  var getCaretBoundary = props.getCaretBoundary;
  if (getCaretBoundary === void 0) getCaretBoundary = caretUnknownFormatBoundary;
  var isValidInputCharacter = props.isValidInputCharacter;
  if (isValidInputCharacter === void 0) isValidInputCharacter = charIsNumber;
  var isCharacterSame = props.isCharacterSame;
  var otherProps = __rest(props, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]);
  var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format, removeFormatting, onValueChange);
  var ref_0 = ref[0];
  var formattedValue = ref_0.formattedValue;
  var numAsString = ref_0.numAsString;
  var onFormattedValueChange = ref[1];
  var lastUpdatedValue = (0,react.useRef)({
    formattedValue: formattedValue,
    numAsString: numAsString
  });
  var _onValueChange = function (values, source) {
    lastUpdatedValue.current = {
      formattedValue: values.formattedValue,
      numAsString: values.value
    };
    onFormattedValueChange(values, source);
  };
  var ref$1 = (0,react.useState)(false);
  var mounted = ref$1[0];
  var setMounted = ref$1[1];
  var focusedElm = (0,react.useRef)(null);
  var timeout = (0,react.useRef)({
    setCaretTimeout: null,
    focusTimeout: null
  });
  (0,react.useEffect)(function () {
    setMounted(true);
    return function () {
      clearTimeout(timeout.current.setCaretTimeout);
      clearTimeout(timeout.current.focusTimeout);
    };
  }, []);
  var _format = format;
  var getValueObject = function (formattedValue, numAsString) {
    var floatValue = parseFloat(numAsString);
    return {
      formattedValue: formattedValue,
      value: numAsString,
      floatValue: isNaN(floatValue) ? undefined : floatValue
    };
  };
  var setPatchedCaretPosition = function (el, caretPos, currentValue) {
    // don't reset the caret position when the whole input content is selected
    if (el.selectionStart === 0 && el.selectionEnd === el.value.length) {
      return;
    }
    /* setting caret position within timeout of 0ms is required for mobile chrome,
    otherwise browser resets the caret position after we set it
    We are also setting it without timeout so that in normal browser we don't see the flickering */
    setCaretPosition(el, caretPos);
    timeout.current.setCaretTimeout = setTimeout(function () {
      if (el.value === currentValue && el.selectionStart !== caretPos) {
        setCaretPosition(el, caretPos);
      }
    }, 0);
  };
  /* This keeps the caret within typing area so people can't type in between prefix or suffix */
  var correctCaretPosition = function (value, caretPos, direction) {
    return getCaretPosInBoundary(value, caretPos, getCaretBoundary(value), direction);
  };
  var getNewCaretPosition = function (inputValue, newFormattedValue, caretPos) {
    var caretBoundary = getCaretBoundary(newFormattedValue);
    var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
    //correct caret position if its outside of editable area
    updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
    return updatedCaretPos;
  };
  var updateValueAndCaretPosition = function (params) {
    var newFormattedValue = params.formattedValue;
    if (newFormattedValue === void 0) newFormattedValue = '';
    var input = params.input;
    var source = params.source;
    var event = params.event;
    var numAsString = params.numAsString;
    var caretPos;
    if (input) {
      var inputValue = params.inputValue || input.value;
      var currentCaretPosition = geInputCaretPosition(input);
      /**
       * set the value imperatively, this is required for IE fix
       * This is also required as if new caret position is beyond the previous value.
       * Caret position will not be set correctly
       */
      input.value = newFormattedValue;
      //get the caret position
      caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition);
      //set caret position imperatively
      if (caretPos !== undefined) {
        setPatchedCaretPosition(input, caretPos, newFormattedValue);
      }
    }
    if (newFormattedValue !== formattedValue) {
      // trigger onValueChange synchronously, so parent is updated along with the number format. Fix for #277, #287
      _onValueChange(getValueObject(newFormattedValue, numAsString), {
        event: event,
        source: source
      });
    }
  };
  /**
   * if the formatted value is not synced to parent, or if the formatted value is different from last synced value sync it
   * we also don't need to sync to the parent if no formatting is applied
   * if the formatting props is removed, in which case last formatted value will be different from the numeric string value
   * in such case we need to inform the parent.
   */
  (0,react.useEffect)(function () {
    var ref = lastUpdatedValue.current;
    var lastFormattedValue = ref.formattedValue;
    var lastNumAsString = ref.numAsString;
    if (formattedValue !== lastFormattedValue && (formattedValue !== numAsString || lastFormattedValue !== lastNumAsString)) {
      _onValueChange(getValueObject(formattedValue, numAsString), {
        event: undefined,
        source: SourceType.props
      });
    }
  }, [formattedValue, numAsString]);
  // also if formatted value is changed from the props, we need to update the caret position
  // keep the last caret position if element is focused
  var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : undefined;
  // needed to prevent warning with useLayoutEffect on server
  var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
  useIsomorphicLayoutEffect(function () {
    var input = focusedElm.current;
    if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
      var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
      /**
       * set the value imperatively, as we set the caret position as well imperatively.
       * This is to keep value and caret position in sync
       */
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
    }
  }, [formattedValue]);
  var formatInputValue = function (inputValue, event, source) {
    var changeRange = findChangeRange(formattedValue, inputValue);
    var changeMeta = Object.assign(Object.assign({}, changeRange), {
      lastValue: formattedValue
    });
    var _numAsString = removeFormatting(inputValue, changeMeta);
    var _formattedValue = _format(_numAsString);
    // formatting can remove some of the number chars, so we need to fine number string again
    _numAsString = removeFormatting(_formattedValue, undefined);
    if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
      //reset the caret position
      var input = event.target;
      var currentCaretPosition = geInputCaretPosition(input);
      var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
      return false;
    }
    updateValueAndCaretPosition({
      formattedValue: _formattedValue,
      numAsString: _numAsString,
      inputValue: inputValue,
      event: event,
      source: source,
      input: event.target
    });
    return true;
  };
  var _onChange = function (e) {
    var el = e.target;
    var inputValue = el.value;
    var changed = formatInputValue(inputValue, e, SourceType.event);
    if (changed) {
      onChange(e);
    }
  };
  var _onKeyDown = function (e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    if (value === void 0) value = '';
    var expectedCaretPosition;
    //Handle backspace and delete against non numerical/decimal characters or arrow keys
    if (key === 'ArrowLeft' || key === 'Backspace') {
      expectedCaretPosition = Math.max(selectionStart - 1, 0);
    } else if (key === 'ArrowRight') {
      expectedCaretPosition = Math.min(selectionStart + 1, value.length);
    } else if (key === 'Delete') {
      expectedCaretPosition = selectionStart;
    }
    //if expectedCaretPosition is not set it means we don't want to Handle keyDown
    // also if multiple characters are selected don't handle
    if (expectedCaretPosition === undefined || selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    var newCaretPosition = expectedCaretPosition;
    if (key === 'ArrowLeft' || key === 'ArrowRight') {
      var direction = key === 'ArrowLeft' ? 'left' : 'right';
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);
      // arrow left or right only moves the caret, so no need to handle the event, if we are handling it manually
      if (newCaretPosition !== expectedCaretPosition) {
        e.preventDefault();
      }
    } else if (key === 'Delete' && !isValidInputCharacter(value[expectedCaretPosition])) {
      // in case of delete go to closest caret boundary on the right side
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, 'right');
    } else if (key === 'Backspace' && !isValidInputCharacter(value[expectedCaretPosition])) {
      // in case of backspace go to closest caret boundary on the left side
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, 'left');
    }
    if (newCaretPosition !== expectedCaretPosition) {
      setPatchedCaretPosition(el, newCaretPosition, value);
    }
    /* NOTE: this is just required for unit test as we need to get the newCaretPosition,
            Remove this when you find different solution */
    /* @ts-ignore */
    if (e.isUnitTestRun) {
      setPatchedCaretPosition(el, newCaretPosition, value);
    }
    onKeyDown(e);
  };
  /** required to handle the caret position when click anywhere within the input **/
  var _onMouseUp = function (e) {
    var el = e.target;
    /**
     * NOTE: we have to give default value for value as in case when custom input is provided
     * value can come as undefined when nothing is provided on value prop.
     */
    var correctCaretPositionIfRequired = function () {
      var selectionStart = el.selectionStart;
      var selectionEnd = el.selectionEnd;
      var value = el.value;
      if (value === void 0) value = '';
      if (selectionStart === selectionEnd) {
        var caretPosition = correctCaretPosition(value, selectionStart);
        if (caretPosition !== selectionStart) {
          setPatchedCaretPosition(el, caretPosition, value);
        }
      }
    };
    correctCaretPositionIfRequired();
    // try to correct after selection has updated by browser
    // this case is required when user clicks on some position while a text is selected on input
    requestAnimationFrame(function () {
      correctCaretPositionIfRequired();
    });
    onMouseUp(e);
  };
  var _onFocus = function (e) {
    // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328
    // (onFocus event target selectionStart is always 0 before setTimeout)
    if (e.persist) {
      e.persist();
    }
    var el = e.target;
    var currentTarget = e.currentTarget;
    focusedElm.current = el;
    timeout.current.focusTimeout = setTimeout(function () {
      var selectionStart = el.selectionStart;
      var selectionEnd = el.selectionEnd;
      var value = el.value;
      if (value === void 0) value = '';
      var caretPosition = correctCaretPosition(value, selectionStart);
      //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)
      if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {
        setPatchedCaretPosition(el, caretPosition, value);
      }
      onFocus(Object.assign(Object.assign({}, e), {
        currentTarget: currentTarget
      }));
    }, 0);
  };
  var _onBlur = function (e) {
    focusedElm.current = null;
    clearTimeout(timeout.current.focusTimeout);
    clearTimeout(timeout.current.setCaretTimeout);
    onBlur(e);
  };
  // add input mode on element based on format prop and device once the component is mounted
  var inputMode = mounted && addInputMode() ? 'numeric' : undefined;
  var inputProps = Object.assign({
    inputMode: inputMode
  }, otherProps, {
    type: type,
    value: formattedValue,
    onChange: _onChange,
    onKeyDown: _onKeyDown,
    onMouseUp: _onMouseUp,
    onFocus: _onFocus,
    onBlur: _onBlur
  });
  if (displayType === 'text') {
    return renderText ? react.createElement(react.Fragment, null, renderText(formattedValue, otherProps) || null) : react.createElement("span", Object.assign({}, otherProps, {
      ref: getInputRef
    }), formattedValue);
  } else if (customInput) {
    var CustomInput = customInput;
    /* @ts-ignore */
    return react.createElement(CustomInput, Object.assign({}, inputProps, {
      ref: getInputRef
    }));
  }
  return react.createElement("input", Object.assign({}, inputProps, {
    ref: getInputRef
  }));
}
function format(numStr, props) {
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix = props.prefix;
  if (prefix === void 0) prefix = '';
  var suffix = props.suffix;
  if (suffix === void 0) suffix = '';
  var allowNegative = props.allowNegative;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  if (thousandsGroupStyle === void 0) thousandsGroupStyle = 'thousand';
  // don't apply formatting on empty string or '-'
  if (numStr === '' || numStr === '-') {
    return numStr;
  }
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  /**
   * Keep the decimal separator
   * when decimalScale is not defined or non zero and the numStr has decimal in it
   * Or if decimalScale is > 0 and fixeDecimalScale is true (even if numStr has no decimal)
   */
  var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf('.') !== -1 || decimalScale && fixedDecimalScale;
  var ref$1 = splitDecimal(numStr, allowNegative);
  var beforeDecimal = ref$1.beforeDecimal;
  var afterDecimal = ref$1.afterDecimal;
  var addNegation = ref$1.addNegation; // eslint-disable-line prefer-const
  //apply decimal precision if its defined
  if (decimalScale !== undefined) {
    afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
  }
  if (thousandSeparator) {
    beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
  }
  //add prefix and suffix when there is a number present
  if (prefix) {
    beforeDecimal = prefix + beforeDecimal;
  }
  if (suffix) {
    afterDecimal = afterDecimal + suffix;
  }
  //restore negation sign
  if (addNegation) {
    beforeDecimal = '-' + beforeDecimal;
  }
  numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || '') + afterDecimal;
  return numStr;
}
function getSeparators(props) {
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === void 0) decimalSeparator = '.';
  var thousandSeparator = props.thousandSeparator;
  var allowedDecimalSeparators = props.allowedDecimalSeparators;
  if (thousandSeparator === true) {
    thousandSeparator = ',';
  }
  if (!allowedDecimalSeparators) {
    allowedDecimalSeparators = [decimalSeparator, '.'];
  }
  return {
    decimalSeparator: decimalSeparator,
    thousandSeparator: thousandSeparator,
    allowedDecimalSeparators: allowedDecimalSeparators
  };
}
function handleNegation(value, allowNegative) {
  if (value === void 0) value = '';
  var negationRegex = new RegExp('(-)');
  var doubleNegationRegex = new RegExp('(-)(.)*(-)');
  // Check number has '-' value
  var hasNegation = negationRegex.test(value);
  // Check number has 2 or more '-' values
  var removeNegation = doubleNegationRegex.test(value);
  //remove negation
  value = value.replace(/-/g, '');
  if (hasNegation && !removeNegation && allowNegative) {
    value = '-' + value;
  }
  return value;
}
function getNumberRegex(decimalSeparator, global) {
  return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global ? 'g' : undefined);
}
function isNumericString(val, prefix, suffix) {
  // for empty value we can always treat it as numeric string
  if (val === '') {
    return true;
  }
  return !(prefix === null || prefix === void 0 ? void 0 : prefix.match(/\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\d/)) && typeof val === 'string' && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
  var assign;
  if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);
  var allowNegative = props.allowNegative;
  var prefix = props.prefix;
  if (prefix === void 0) prefix = '';
  var suffix = props.suffix;
  if (suffix === void 0) suffix = '';
  var decimalScale = props.decimalScale;
  var from = changeMeta.from;
  var to = changeMeta.to;
  var start = to.start;
  var end = to.end;
  var ref = getSeparators(props);
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var decimalSeparator = ref.decimalSeparator;
  var isBeforeDecimalSeparator = value[end] === decimalSeparator;
  /**
   * If only a number is added on empty input which matches with the prefix or suffix,
   * then don't remove it, just return the same
   */
  if (charIsNumber(value) && (value === prefix || value === suffix) && changeMeta.lastValue === '') {
    return value;
  }
  /** Check for any allowed decimal separator is added in the numeric format and replace it with decimal separator */
  if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {
    var separator = decimalScale === 0 ? '' : decimalSeparator;
    value = value.substring(0, start) + separator + value.substring(start + 1, value.length);
  }
  var stripNegation = function (value, start, end) {
    /**
     * if prefix starts with - we don't allow negative number to avoid confusion
     * if suffix starts with - and the value length is same as suffix length, then the - sign is from the suffix
     * In other cases, if the value starts with - then it is a negation
     */
    var hasNegation = false;
    var hasDoubleNegation = false;
    if (prefix.startsWith('-')) {
      hasNegation = false;
    } else if (value.startsWith('--')) {
      hasNegation = false;
      hasDoubleNegation = true;
    } else if (suffix.startsWith('-') && value.length === suffix.length) {
      hasNegation = false;
    } else if (value[0] === '-') {
      hasNegation = true;
    }
    var charsToRemove = hasNegation ? 1 : 0;
    if (hasDoubleNegation) {
      charsToRemove = 2;
    }
    // remove negation/double negation from start to simplify prefix logic as negation comes before prefix
    if (charsToRemove) {
      value = value.substring(charsToRemove);
      // account for the removal of the negation for start and end index
      start -= charsToRemove;
      end -= charsToRemove;
    }
    return {
      value: value,
      start: start,
      end: end,
      hasNegation: hasNegation
    };
  };
  var toMetadata = stripNegation(value, start, end);
  var hasNegation = toMetadata.hasNegation;
  assign = toMetadata, value = assign.value, start = assign.start, end = assign.end;
  var ref$1 = stripNegation(changeMeta.lastValue, from.start, from.end);
  var fromStart = ref$1.start;
  var fromEnd = ref$1.end;
  var lastValue = ref$1.value;
  // if only prefix and suffix part is updated reset the value to last value
  // if the changed range is from suffix in the updated value, and the the suffix starts with the same characters, allow the change
  var updatedSuffixPart = value.substring(start, end);
  if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {
    value = lastValue;
  }
  /**
   * remove prefix
   * Remove whole prefix part if its present on the value
   * If the prefix is partially deleted (in which case change start index will be less the prefix length)
   * Remove only partial part of prefix.
   */
  var startIndex = 0;
  if (value.startsWith(prefix)) {
    startIndex += prefix.length;
  } else if (start < prefix.length) {
    startIndex = start;
  }
  value = value.substring(startIndex);
  // account for deleted prefix for end
  end -= startIndex;
  /**
   * Remove suffix
   * Remove whole suffix part if its present on the value
   * If the suffix is partially deleted (in which case change end index will be greater than the suffixStartIndex)
   * remove the partial part of suffix
   */
  var endIndex = value.length;
  var suffixStartIndex = value.length - suffix.length;
  if (value.endsWith(suffix)) {
    endIndex = suffixStartIndex;
  }
  // if the suffix is removed from the end
  else if (end > suffixStartIndex) {
    endIndex = end;
  }
  // if the suffix is removed from start
  else if (end > value.length - suffix.length) {
    endIndex = end;
  }
  value = value.substring(0, endIndex);
  // add the negation back and handle for double negation
  value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
  // remove non numeric characters
  value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join('');
  // replace the decimalSeparator with ., and only keep the first separator, ignore following ones
  var firstIndex = value.indexOf(decimalSeparator);
  value = value.replace(new RegExp(escapeRegExp(decimalSeparator), 'g'), function (match, index) {
    return index === firstIndex ? '.' : '';
  });
  //check if beforeDecimal got deleted and there is nothing after decimal,
  //clear all numbers in such case while keeping the - sign
  var ref$2 = splitDecimal(value, allowNegative);
  var beforeDecimal = ref$2.beforeDecimal;
  var afterDecimal = ref$2.afterDecimal;
  var addNegation = ref$2.addNegation; // eslint-disable-line prefer-const
  //clear only if something got deleted before decimal (cursor is before decimal)
  if (to.end - to.start < from.end - from.start && beforeDecimal === '' && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {
    value = addNegation ? '-' : '';
  }
  return value;
}
function getCaretBoundary(formattedValue, props) {
  var prefix = props.prefix;
  if (prefix === void 0) prefix = '';
  var suffix = props.suffix;
  if (suffix === void 0) suffix = '';
  var boundaryAry = Array.from({
    length: formattedValue.length + 1
  }).map(function () {
    return true;
  });
  var hasNegation = formattedValue[0] === '-';
  // fill for prefix and negation
  boundaryAry.fill(false, 0, prefix.length + (hasNegation ? 1 : 0));
  // fill for suffix
  var valLn = formattedValue.length;
  boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);
  return boundaryAry;
}
function validateAndUpdateProps(props) {
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  // eslint-disable-next-line prefer-const
  var prefix = props.prefix;
  if (prefix === void 0) prefix = '';
  var allowNegative = props.allowNegative;
  if (allowNegative === void 0) allowNegative = true;
  if (thousandSeparator === decimalSeparator) {
    throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + " (thousandSeparator = {true} is same as thousandSeparator = \",\")\n        decimalSeparator: " + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
  }
  if (prefix.startsWith('-') && allowNegative) {
    // TODO: throw error in next major version
    console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix + "\n      allowNegative: " + allowNegative + "\n    ");
    allowNegative = false;
  }
  return Object.assign(Object.assign({}, props), {
    allowNegative: allowNegative
  });
}
function useNumericFormat(props) {
  // validate props
  props = validateAndUpdateProps(props);
  var _decimalSeparator = props.decimalSeparator;
  var _allowedDecimalSeparators = props.allowedDecimalSeparators;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  var suffix = props.suffix;
  var allowNegative = props.allowNegative;
  var allowLeadingZeros = props.allowLeadingZeros;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0) onKeyDown = noop;
  var onBlur = props.onBlur;
  if (onBlur === void 0) onBlur = noop;
  var thousandSeparator = props.thousandSeparator;
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix = props.prefix;
  if (prefix === void 0) prefix = '';
  var defaultValue = props.defaultValue;
  var value = props.value;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var restProps = __rest(props, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]);
  // get derived decimalSeparator and allowedDecimalSeparators
  var ref = getSeparators(props);
  var decimalSeparator = ref.decimalSeparator;
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var _format = function (numStr) {
    return format(numStr, props);
  };
  var _removeFormatting = function (inputValue, changeMeta) {
    return removeFormatting(inputValue, changeMeta, props);
  };
  var _value = isNil(value) ? defaultValue : value;
  // try to figure out isValueNumericString based on format prop and value
  var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix, suffix);
  if (!isNil(value)) {
    _valueIsNumericString = _valueIsNumericString || typeof value === 'number';
  } else if (!isNil(defaultValue)) {
    _valueIsNumericString = _valueIsNumericString || typeof defaultValue === 'number';
  }
  var roundIncomingValueToPrecision = function (value) {
    if (isNotValidValue(value)) {
      return value;
    }
    if (typeof value === 'number') {
      value = toNumericString(value);
    }
    /**
     * only round numeric or float string values coming through props,
     * we don't need to do it for onChange events, as we want to prevent typing there
     */
    if (_valueIsNumericString && typeof decimalScale === 'number') {
      return roundToPrecision(value, decimalScale, Boolean(fixedDecimalScale));
    }
    return value;
  };
  var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
  var ref$1_0 = ref$1[0];
  var numAsString = ref$1_0.numAsString;
  var formattedValue = ref$1_0.formattedValue;
  var _onValueChange = ref$1[1];
  var _onKeyDown = function (e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    if (value === void 0) value = '';
    // if multiple characters are selected and user hits backspace, no need to handle anything manually
    if (selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    // if user hits backspace, while the cursor is before prefix, and the input has negation, remove the negation
    if (key === 'Backspace' && value[0] === '-' && selectionStart === prefix.length + 1 && allowNegative) {
      // bring the cursor to after negation
      setCaretPosition(el, 1);
    }
    // don't allow user to delete decimal separator when decimalScale and fixedDecimalScale is set
    if (decimalScale && fixedDecimalScale) {
      if (key === 'Backspace' && value[selectionStart - 1] === decimalSeparator) {
        setCaretPosition(el, selectionStart - 1);
        e.preventDefault();
      } else if (key === 'Delete' && value[selectionStart] === decimalSeparator) {
        e.preventDefault();
      }
    }
    // if user presses the allowed decimal separator before the separator, move the cursor after the separator
    if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value[selectionStart] === decimalSeparator) {
      setCaretPosition(el, selectionStart + 1);
    }
    var _thousandSeparator = thousandSeparator === true ? ',' : thousandSeparator;
    // move cursor when delete or backspace is pressed before/after thousand separator
    if (key === 'Backspace' && value[selectionStart - 1] === _thousandSeparator) {
      setCaretPosition(el, selectionStart - 1);
    }
    if (key === 'Delete' && value[selectionStart] === _thousandSeparator) {
      setCaretPosition(el, selectionStart + 1);
    }
    onKeyDown(e);
  };
  var _onBlur = function (e) {
    var _value = numAsString;
    // if there no no numeric value, clear the input
    if (!_value.match(/\d/g)) {
      _value = '';
    }
    // clear leading 0s
    if (!allowLeadingZeros) {
      _value = fixLeadingZero(_value);
    }
    // apply fixedDecimalScale on blur event
    if (fixedDecimalScale && decimalScale) {
      _value = roundToPrecision(_value, decimalScale, fixedDecimalScale);
    }
    if (_value !== numAsString) {
      var formattedValue = format(_value, props);
      _onValueChange({
        formattedValue: formattedValue,
        value: _value,
        floatValue: parseFloat(_value)
      }, {
        event: e,
        source: SourceType.event
      });
    }
    onBlur(e);
  };
  var isValidInputCharacter = function (inputChar) {
    if (inputChar === decimalSeparator) {
      return true;
    }
    return charIsNumber(inputChar);
  };
  var isCharacterSame = function (ref) {
    var currentValue = ref.currentValue;
    var lastValue = ref.lastValue;
    var formattedValue = ref.formattedValue;
    var currentValueIndex = ref.currentValueIndex;
    var formattedValueIndex = ref.formattedValueIndex;
    var curChar = currentValue[currentValueIndex];
    var newChar = formattedValue[formattedValueIndex];
    /**
     * NOTE: as thousand separator and allowedDecimalSeparators can be same, we need to check on
     * typed range if we have typed any character from allowedDecimalSeparators, in that case we
     * consider different characters like , and . same within the range of updated value.
     */
    var typedRange = findChangeRange(lastValue, currentValue);
    var to = typedRange.to;
    if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {
      return true;
    }
    return curChar === newChar;
  };
  return Object.assign(Object.assign({}, restProps), {
    value: formattedValue,
    valueIsNumericString: false,
    isValidInputCharacter: isValidInputCharacter,
    isCharacterSame: isCharacterSame,
    onValueChange: _onValueChange,
    format: _format,
    removeFormatting: _removeFormatting,
    getCaretBoundary: function (formattedValue) {
      return getCaretBoundary(formattedValue, props);
    },
    onKeyDown: _onKeyDown,
    onBlur: _onBlur
  });
}
function NumericFormat(props) {
  var numericFormatProps = useNumericFormat(props);
  return react.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}
function format$1(numStr, props) {
  var format = props.format;
  var allowEmptyFormatting = props.allowEmptyFormatting;
  var mask = props.mask;
  var patternChar = props.patternChar;
  if (patternChar === void 0) patternChar = '#';
  if (numStr === '' && !allowEmptyFormatting) {
    return '';
  }
  var hashCount = 0;
  var formattedNumberAry = format.split('');
  for (var i = 0, ln = format.length; i < ln; i++) {
    if (format[i] === patternChar) {
      formattedNumberAry[i] = numStr[hashCount] || getMaskAtIndex(mask, hashCount);
      hashCount += 1;
    }
  }
  return formattedNumberAry.join('');
}
function removeFormatting$1(value, changeMeta, props) {
  if (changeMeta === void 0) changeMeta = getDefaultChangeMeta(value);
  var format = props.format;
  var patternChar = props.patternChar;
  if (patternChar === void 0) patternChar = '#';
  var from = changeMeta.from;
  var to = changeMeta.to;
  var lastValue = changeMeta.lastValue;
  if (lastValue === void 0) lastValue = '';
  var isNumericSlot = function (caretPos) {
    return format[caretPos] === patternChar;
  };
  var removeFormatChar = function (string, startIndex) {
    var str = '';
    for (var i = 0; i < string.length; i++) {
      if (isNumericSlot(startIndex + i) && charIsNumber(string[i])) {
        str += string[i];
      }
    }
    return str;
  };
  var extractNumbers = function (str) {
    return str.replace(/[^0-9]/g, '');
  };
  // if format doesn't have any number, remove all the non numeric characters
  if (!format.match(/\d/)) {
    return extractNumbers(value);
  }
  /**
   * if user paste the whole formatted text in an empty input, check if matches to the pattern
   * and remove the format characters, if there is a mismatch on the pattern, do plane number extract
   */
  if (lastValue === '' && value.length === format.length) {
    var str = '';
    for (var i = 0; i < value.length; i++) {
      if (isNumericSlot(i)) {
        if (charIsNumber(value[i])) {
          str += value[i];
        }
      } else if (value[i] !== format[i]) {
        // if there is a mismatch on the pattern, do plane number extract
        return extractNumbers(value);
      }
    }
    return str;
  }
  /**
   * For partial change,
   * where ever there is a change on the input, we can break the number in three parts
   * 1st: left part which is unchanged
   * 2nd: middle part which is changed
   * 3rd: right part which is unchanged
   *
   * The first and third section will be same as last value, only the middle part will change
   * We can consider on the change part all the new characters are non format characters.
   * And on the first and last section it can have partial format characters.
   *
   * We pick first and last section from the lastValue (as that has 1-1 mapping with format)
   * and middle one from the update value.
   */
  var firstSection = lastValue.substring(0, from.start);
  var middleSection = value.substring(to.start, to.end);
  var lastSection = lastValue.substring(from.end);
  return "" + removeFormatChar(firstSection, 0) + extractNumbers(middleSection) + removeFormatChar(lastSection, from.end);
}
function getCaretBoundary$1(formattedValue, props) {
  var format = props.format;
  var mask = props.mask;
  var patternChar = props.patternChar;
  if (patternChar === void 0) patternChar = '#';
  var boundaryAry = Array.from({
    length: formattedValue.length + 1
  }).map(function () {
    return true;
  });
  var hashCount = 0;
  var firstEmptySlot = -1;
  var maskAndIndexMap = {};
  format.split('').forEach(function (char, index) {
    var maskAtIndex = undefined;
    if (char === patternChar) {
      hashCount++;
      maskAtIndex = getMaskAtIndex(mask, hashCount - 1);
      if (firstEmptySlot === -1 && formattedValue[index] === maskAtIndex) {
        firstEmptySlot = index;
      }
    }
    maskAndIndexMap[index] = maskAtIndex;
  });
  var isPosAllowed = function (pos) {
    // the position is allowed if the position is not masked and valid number area
    return format[pos] === patternChar && formattedValue[pos] !== maskAndIndexMap[pos];
  };
  for (var i = 0, ln = boundaryAry.length; i < ln; i++) {
    // consider caret to be in boundary if it is before or after numeric value
    // Note: on pattern based format its denoted by patternCharacter
    // we should also allow user to put cursor on first empty slot
    boundaryAry[i] = i === firstEmptySlot || isPosAllowed(i) || isPosAllowed(i - 1);
  }
  // the first patternChar position is always allowed
  boundaryAry[format.indexOf(patternChar)] = true;
  return boundaryAry;
}
function validateProps(props) {
  var mask = props.mask;
  if (mask) {
    var maskAsStr = mask === 'string' ? mask : mask.toString();
    if (maskAsStr.match(/\d/g)) {
      throw new Error("Mask " + mask + " should not contain numeric character;");
    }
  }
}
function isNumericString$1(val, format) {
  //we can treat empty string as numeric string
  if (val === '') {
    return true;
  }
  return !(format === null || format === void 0 ? void 0 : format.match(/\d/)) && typeof val === 'string' && (!!val.match(/^\d+$/) || val === '');
}
function usePatternFormat(props) {
  var mask = props.mask;
  var allowEmptyFormatting = props.allowEmptyFormatting;
  var formatProp = props.format;
  var inputMode = props.inputMode;
  if (inputMode === void 0) inputMode = 'numeric';
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0) onKeyDown = noop;
  var patternChar = props.patternChar;
  if (patternChar === void 0) patternChar = '#';
  var value = props.value;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var restProps = __rest(props, ["mask", "allowEmptyFormatting", "format", "inputMode", "onKeyDown", "patternChar", "value", "defaultValue", "valueIsNumericString"]);
  // validate props
  validateProps(props);
  var _getCaretBoundary = function (formattedValue) {
    return getCaretBoundary$1(formattedValue, props);
  };
  var _onKeyDown = function (e) {
    var key = e.key;
    var el = e.target;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    // if multiple characters are selected and user hits backspace, no need to handle anything manually
    if (selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    // bring the cursor to closest numeric section
    var caretPos = selectionStart;
    // if backspace is pressed after the format characters, bring it to numeric section
    // if delete is pressed before the format characters, bring it to numeric section
    if (key === 'Backspace' || key === 'Delete') {
      var direction = 'right';
      if (key === 'Backspace') {
        while (caretPos > 0 && formatProp[caretPos - 1] !== patternChar) {
          caretPos--;
        }
        direction = 'left';
      } else {
        var formatLn = formatProp.length;
        while (caretPos < formatLn && formatProp[caretPos] !== patternChar) {
          caretPos++;
        }
        direction = 'right';
      }
      caretPos = getCaretPosInBoundary(value, caretPos, _getCaretBoundary(value), direction);
    } else if (formatProp[caretPos] !== patternChar && key !== 'ArrowLeft' && key !== 'ArrowRight') {
      // if user is typing on format character position, bring user to next allowed caret position
      caretPos = getCaretPosInBoundary(value, caretPos + 1, _getCaretBoundary(value), 'right');
    }
    // if we changing caret position, set the caret position
    if (caretPos !== selectionStart) {
      setCaretPosition(el, caretPos);
    }
    onKeyDown(e);
  };
  // try to figure out isValueNumericString based on format prop and value
  var _value = isNil(value) ? defaultValue : value;
  var isValueNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString$1(_value, formatProp);
  var _props = Object.assign(Object.assign({}, props), {
    valueIsNumericString: isValueNumericString
  });
  return Object.assign(Object.assign({}, restProps), {
    value: value,
    defaultValue: defaultValue,
    valueIsNumericString: isValueNumericString,
    inputMode: inputMode,
    format: function (numStr) {
      return format$1(numStr, _props);
    },
    removeFormatting: function (inputValue, changeMeta) {
      return removeFormatting$1(inputValue, changeMeta, _props);
    },
    getCaretBoundary: _getCaretBoundary,
    onKeyDown: _onKeyDown
  });
}
function PatternFormat(props) {
  var patternFormatProps = usePatternFormat(props);
  return React.createElement(NumberFormatBase, Object.assign({}, patternFormatProps));
}

;// CONCATENATED MODULE: ./node_modules/clsx/dist/clsx.m.js
function r(e) {
  var t,
    f,
    n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
/* harmony default export */ const clsx_m = (clsx);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
// EXTERNAL MODULE: ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(4151);
;// CONCATENATED MODULE: ./node_modules/@loadable/component/dist/loadable.esm.mjs







/* eslint-disable import/prefer-default-export */
function invariant(condition, message) {
  if (condition) return;
  var error = new Error("loadable: " + message);
  error.framesToPop = 1;
  error.name = 'Invariant Violation';
  throw error;
}
function warn(message) {
  // eslint-disable-next-line no-console
  console.warn("loadable: " + message);
}

var Context = /*#__PURE__*/
react.createContext();

var LOADABLE_REQUIRED_CHUNKS_KEY = '__LOADABLE_REQUIRED_CHUNKS__';
function getRequiredChunkKey(namespace) {
  return "" + namespace + LOADABLE_REQUIRED_CHUNKS_KEY;
}

var sharedInternals = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getRequiredChunkKey: getRequiredChunkKey,
  invariant: invariant,
  Context: Context
});

var LOADABLE_SHARED = {
  initialChunks: {}
};

var STATUS_PENDING = 'PENDING';
var STATUS_RESOLVED = 'RESOLVED';
var STATUS_REJECTED = 'REJECTED';

function resolveConstructor(ctor) {
  if (typeof ctor === 'function') {
    return {
      requireAsync: ctor,
      resolve: function resolve() {
        return undefined;
      },
      chunkName: function chunkName() {
        return undefined;
      }
    };
  }

  return ctor;
}

var withChunkExtractor = function withChunkExtractor(Component) {
  var LoadableWithChunkExtractor = function LoadableWithChunkExtractor(props) {
    return react.createElement(Context.Consumer, null, function (extractor) {
      return react.createElement(Component, Object.assign({
        __chunkExtractor: extractor
      }, props));
    });
  };

  if (Component.displayName) {
    LoadableWithChunkExtractor.displayName = Component.displayName + "WithChunkExtractor";
  }

  return LoadableWithChunkExtractor;
};

var identity = function identity(v) {
  return v;
};

function createLoadable(_ref) {
  var _ref$defaultResolveCo = _ref.defaultResolveComponent,
      defaultResolveComponent = _ref$defaultResolveCo === void 0 ? identity : _ref$defaultResolveCo,
      _render = _ref.render,
      onLoad = _ref.onLoad;

  function loadable(loadableConstructor, options) {
    if (options === void 0) {
      options = {};
    }

    var ctor = resolveConstructor(loadableConstructor);
    var cache = {};
    /**
     * Cachekey represents the component to be loaded
     * if key changes - component has to be reloaded
     * @param props
     * @returns {null|Component}
     */

    function _getCacheKey(props) {
      if (options.cacheKey) {
        return options.cacheKey(props);
      }

      if (ctor.resolve) {
        return ctor.resolve(props);
      }

      return 'static';
    }
    /**
     * Resolves loaded `module` to a specific `Component
     * @param module
     * @param props
     * @param Loadable
     * @returns Component
     */


    function resolve(module, props, Loadable) {
      var Component = options.resolveComponent ? options.resolveComponent(module, props) : defaultResolveComponent(module); // FIXME: suppressed due to https://github.com/gregberge/loadable-components/issues/990
      // if (options.resolveComponent && !ReactIs.isValidElementType(Component)) {
      //   throw new Error(
      //     `resolveComponent returned something that is not a React component!`,
      //   )
      // }

      hoist_non_react_statics_cjs(Loadable, Component, {
        preload: true
      });
      return Component;
    }

    var cachedLoad = function cachedLoad(props) {
      var cacheKey = _getCacheKey(props);

      var promise = cache[cacheKey];

      if (!promise || promise.status === STATUS_REJECTED) {
        promise = ctor.requireAsync(props);
        promise.status = STATUS_PENDING;
        cache[cacheKey] = promise;
        promise.then(function () {
          promise.status = STATUS_RESOLVED;
        }, function (error) {
          console.error('loadable-components: failed to asynchronously load component', {
            fileName: ctor.resolve(props),
            chunkName: ctor.chunkName(props),
            error: error ? error.message : error
          });
          promise.status = STATUS_REJECTED;
        });
      }

      return promise;
    };

    var InnerLoadable =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose(InnerLoadable, _React$Component);

      InnerLoadable.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
        var cacheKey = _getCacheKey(props);

        return _extends({}, state, {
          cacheKey: cacheKey,
          // change of a key triggers loading state automatically
          loading: state.loading || state.cacheKey !== cacheKey
        });
      };

      function InnerLoadable(props) {
        var _this;

        _this = _React$Component.call(this, props) || this;
        _this.state = {
          result: null,
          error: null,
          loading: true,
          cacheKey: _getCacheKey(props)
        };
        invariant(!props.__chunkExtractor || ctor.requireSync, 'SSR requires `@loadable/babel-plugin`, please install it'); // Server-side

        if (props.__chunkExtractor) {
          // This module has been marked with no SSR
          if (options.ssr === false) {
            return _assertThisInitialized(_this);
          } // We run load function, we assume that it won't fail and that it
          // triggers a synchronous loading of the module


          ctor.requireAsync(props)["catch"](function () {
            return null;
          }); // So we can require now the module synchronously

          _this.loadSync();

          props.__chunkExtractor.addChunk(ctor.chunkName(props));

          return _assertThisInitialized(_this);
        } // Client-side with `isReady` method present (SSR probably)
        // If module is already loaded, we use a synchronous loading
        // Only perform this synchronous loading if the component has not
        // been marked with no SSR, else we risk hydration mismatches


        if (options.ssr !== false && ( // is ready - was loaded in this session
        ctor.isReady && ctor.isReady(props) || // is ready - was loaded during SSR process
        ctor.chunkName && LOADABLE_SHARED.initialChunks[ctor.chunkName(props)])) {
          _this.loadSync();
        }

        return _this;
      }

      var _proto = InnerLoadable.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true; // retrieve loading promise from a global cache

        var cachedPromise = this.getCache(); // if promise exists, but rejected - clear cache

        if (cachedPromise && cachedPromise.status === STATUS_REJECTED) {
          this.setCache();
        } // component might be resolved synchronously in the constructor


        if (this.state.loading) {
          this.loadAsync();
        }
      };

      _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        // Component has to be reloaded on cacheKey change
        if (prevState.cacheKey !== this.state.cacheKey) {
          this.loadAsync();
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };

      _proto.safeSetState = function safeSetState(nextState, callback) {
        if (this.mounted) {
          this.setState(nextState, callback);
        }
      }
      /**
       * returns a cache key for the current props
       * @returns {Component|string}
       */
      ;

      _proto.getCacheKey = function getCacheKey() {
        return _getCacheKey(this.props);
      }
      /**
       * access the persistent cache
       */
      ;

      _proto.getCache = function getCache() {
        return cache[this.getCacheKey()];
      }
      /**
       * sets the cache value. If called without value sets it as undefined
       */
      ;

      _proto.setCache = function setCache(value) {
        if (value === void 0) {
          value = undefined;
        }

        cache[this.getCacheKey()] = value;
      };

      _proto.triggerOnLoad = function triggerOnLoad() {
        var _this2 = this;

        if (onLoad) {
          setTimeout(function () {
            onLoad(_this2.state.result, _this2.props);
          });
        }
      }
      /**
       * Synchronously loads component
       * target module is expected to already exists in the module cache
       * or be capable to resolve synchronously (webpack target=node)
       */
      ;

      _proto.loadSync = function loadSync() {
        // load sync is expecting component to be in the "loading" state already
        // sounds weird, but loading=true is the initial state of InnerLoadable
        if (!this.state.loading) return;

        try {
          var loadedModule = ctor.requireSync(this.props);
          var result = resolve(loadedModule, this.props, Loadable);
          this.state.result = result;
          this.state.loading = false;
        } catch (error) {
          console.error('loadable-components: failed to synchronously load component, which expected to be available', {
            fileName: ctor.resolve(this.props),
            chunkName: ctor.chunkName(this.props),
            error: error ? error.message : error
          });
          this.state.error = error;
        }
      }
      /**
       * Asynchronously loads a component.
       */
      ;

      _proto.loadAsync = function loadAsync() {
        var _this3 = this;

        var promise = this.resolveAsync();
        promise.then(function (loadedModule) {
          var result = resolve(loadedModule, _this3.props, Loadable);

          _this3.safeSetState({
            result: result,
            loading: false
          }, function () {
            return _this3.triggerOnLoad();
          });
        })["catch"](function (error) {
          return _this3.safeSetState({
            error: error,
            loading: false
          });
        });
        return promise;
      }
      /**
       * Asynchronously resolves(not loads) a component.
       * Note - this function does not change the state
       */
      ;

      _proto.resolveAsync = function resolveAsync() {
        var _this$props = this.props,
            __chunkExtractor = _this$props.__chunkExtractor,
            forwardedRef = _this$props.forwardedRef,
            props = _objectWithoutPropertiesLoose(_this$props, ["__chunkExtractor", "forwardedRef"]);

        return cachedLoad(props);
      };

      _proto.render = function render() {
        var _this$props2 = this.props,
            forwardedRef = _this$props2.forwardedRef,
            propFallback = _this$props2.fallback,
            __chunkExtractor = _this$props2.__chunkExtractor,
            props = _objectWithoutPropertiesLoose(_this$props2, ["forwardedRef", "fallback", "__chunkExtractor"]);

        var _this$state = this.state,
            error = _this$state.error,
            loading = _this$state.loading,
            result = _this$state.result;

        if (options.suspense) {
          var cachedPromise = this.getCache() || this.loadAsync();

          if (cachedPromise.status === STATUS_PENDING) {
            throw this.loadAsync();
          }
        }

        if (error) {
          throw error;
        }

        var fallback = propFallback || options.fallback || null;

        if (loading) {
          return fallback;
        }

        return _render({
          fallback: fallback,
          result: result,
          options: options,
          props: _extends({}, props, {
            ref: forwardedRef
          })
        });
      };

      return InnerLoadable;
    }(react.Component);

    var EnhancedInnerLoadable = withChunkExtractor(InnerLoadable);
    var Loadable = react.forwardRef(function (props, ref) {
      return react.createElement(EnhancedInnerLoadable, Object.assign({
        forwardedRef: ref
      }, props));
    });
    Loadable.displayName = 'Loadable'; // In future, preload could use `<link rel="preload">`

    Loadable.preload = function (props) {
      Loadable.load(props);
    };

    Loadable.load = function (props) {
      return cachedLoad(props);
    };

    return Loadable;
  }

  function lazy(ctor, options) {
    return loadable(ctor, _extends({}, options, {
      suspense: true
    }));
  }

  return {
    loadable: loadable,
    lazy: lazy
  };
}

function defaultResolveComponent(loadedModule) {
  // eslint-disable-next-line no-underscore-dangle
  return loadedModule.__esModule ? loadedModule["default"] : loadedModule["default"] || loadedModule;
}

/* eslint-disable no-use-before-define, react/no-multi-comp */

var _createLoadable =
/*#__PURE__*/
createLoadable({
  defaultResolveComponent: defaultResolveComponent,
  render: function render(_ref) {
    var Component = _ref.result,
        props = _ref.props;
    return react.createElement(Component, props);
  }
}),
    loadable = _createLoadable.loadable,
    lazy = _createLoadable.lazy;

/* eslint-disable no-use-before-define, react/no-multi-comp */

var _createLoadable$1 =
/*#__PURE__*/
createLoadable({
  onLoad: function onLoad(result, props) {
    if (result && props.forwardedRef) {
      if (typeof props.forwardedRef === 'function') {
        props.forwardedRef(result);
      } else {
        props.forwardedRef.current = result;
      }
    }
  },
  render: function render(_ref) {
    var result = _ref.result,
        props = _ref.props;

    if (props.children) {
      return props.children(result);
    }

    return null;
  }
}),
    loadable$1 = _createLoadable$1.loadable,
    lazy$1 = _createLoadable$1.lazy;

/* eslint-disable no-underscore-dangle, camelcase */
var BROWSER = typeof window !== 'undefined';
function loadableReady(done, _temp) {
  if (done === void 0) {
    done = function done() {};
  }

  var _ref = _temp === void 0 ? {} : _temp,
      _ref$namespace = _ref.namespace,
      namespace = _ref$namespace === void 0 ? '' : _ref$namespace,
      _ref$chunkLoadingGlob = _ref.chunkLoadingGlobal,
      chunkLoadingGlobal = _ref$chunkLoadingGlob === void 0 ? '__LOADABLE_LOADED_CHUNKS__' : _ref$chunkLoadingGlob;

  if (!BROWSER) {
    warn('`loadableReady()` must be called in browser only');
    done();
    return Promise.resolve();
  }

  var requiredChunks = null;

  if (BROWSER) {
    var id = getRequiredChunkKey(namespace);
    var dataElement = document.getElementById(id);

    if (dataElement) {
      requiredChunks = JSON.parse(dataElement.textContent);
      var extElement = document.getElementById(id + "_ext");

      if (extElement) {
        var _JSON$parse = JSON.parse(extElement.textContent),
            namedChunks = _JSON$parse.namedChunks;

        namedChunks.forEach(function (chunkName) {
          LOADABLE_SHARED.initialChunks[chunkName] = true;
        });
      } else {
        // version mismatch
        throw new Error('loadable-component: @loadable/server does not match @loadable/component');
      }
    }
  }

  if (!requiredChunks) {
    warn('`loadableReady()` requires state, please use `getScriptTags` or `getScriptElements` server-side');
    done();
    return Promise.resolve();
  }

  var resolved = false;
  return new Promise(function (resolve) {
    window[chunkLoadingGlobal] = window[chunkLoadingGlobal] || [];
    var loadedChunks = window[chunkLoadingGlobal];
    var originalPush = loadedChunks.push.bind(loadedChunks);

    function checkReadyState() {
      if (requiredChunks.every(function (chunk) {
        return loadedChunks.some(function (_ref2) {
          var chunks = _ref2[0];
          return chunks.indexOf(chunk) > -1;
        });
      })) {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      }
    }

    loadedChunks.push = function () {
      originalPush.apply(void 0, arguments);
      checkReadyState();
    };

    checkReadyState();
  }).then(done);
}

/* eslint-disable no-underscore-dangle */
var loadable$2 = loadable;
loadable$2.lib = loadable$1;
var lazy$2 = lazy;
lazy$2.lib = lazy$1;
var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (/* unused pure expression or super */ null && (sharedInternals));

/* harmony default export */ const loadable_esm = (loadable$2);


;// CONCATENATED MODULE: ../../src/react/src/components/SvgIcon/SvgIconsEnums.ts
var SizeMap;
(function (SizeMap) {
    SizeMap["xs"] = "Icon--xs";
    SizeMap["sm"] = "Icon--sm";
    SizeMap["nm"] = "Icon--nm";
    SizeMap["md"] = "Icon--md";
    SizeMap["lg"] = "Icon--lg";
    SizeMap["xl"] = "Icon--xl";
    SizeMap["xxl"] = "Icon--xxl";
})(SizeMap || (SizeMap = {}));
var ColorMap;
(function (ColorMap) {
    ColorMap["blue-light"] = "icon-base-blue-100";
    ColorMap["blue"] = "icon-base-blue-600";
    ColorMap["blue-mid"] = "icon-base-blue-700";
    ColorMap["blue-dark"] = "icon-base-blue-900";
    ColorMap["teal"] = "icon-base-teal-500";
    ColorMap["white"] = "icon-base-white";
    ColorMap["gray-light"] = "icon-base-gray-100";
    ColorMap["gray"] = "icon-base-gray-400";
    ColorMap["gray-medium"] = "icon-base-gray-500";
    ColorMap["slate"] = "icon-base-gray-700";
    ColorMap["black"] = "icon-base-gray-900";
    ColorMap["green"] = "icon-base-green-400";
    ColorMap["green-dark"] = "icon-base-green-600";
    ColorMap["red-light"] = "icon-base-red-50";
    ColorMap["red"] = "icon-base-red-600";
    ColorMap["gold"] = "icon-base-yellow-200";
    ColorMap["yellow"] = "icon-base-yellow-200";
    ColorMap["transparent"] = "icon-base-transparent";
})(ColorMap || (ColorMap = {}));
var HighlightMap;
(function (HighlightMap) {
    HighlightMap["blue-light"] = "icon-highlight-blue-100";
    HighlightMap["blue"] = "icon-highlight-blue-600";
    HighlightMap["blue-mid"] = "icon-highlight-blue-700";
    HighlightMap["blue-dark"] = "icon-highlight-blue-900";
    HighlightMap["teal"] = "icon-highlight-teal-500";
    HighlightMap["white"] = "icon-highlight-white";
    HighlightMap["gray-light"] = "icon-highlight-gray-100";
    HighlightMap["gray"] = "icon-highlight-gray-400";
    HighlightMap["gray-medium"] = "icon-highlight-gray-500";
    HighlightMap["slate"] = "icon-highlight-gray-700";
    HighlightMap["black"] = "icon-highlight-gray-900";
    HighlightMap["green"] = "icon-highlight-green-400";
    HighlightMap["green-dark"] = "icon-highlight-green-600";
    HighlightMap["red-light"] = "icon-highlight-red-50";
    HighlightMap["red"] = "icon-highlight-red-600";
    HighlightMap["gold"] = "icon-highlight-yellow-200";
    HighlightMap["yellow"] = "icon-highlight-yellow-200";
    HighlightMap["transparent"] = "icon-highlight-transparent";
})(HighlightMap || (HighlightMap = {}));
var ColorHoverMap;
(function (ColorHoverMap) {
    ColorHoverMap["blue-light"] = "hover:icon-base-blue-100";
    ColorHoverMap["blue"] = "hover:icon-base-blue-600";
    ColorHoverMap["blue-mid"] = "hover:icon-base-blue-700";
    ColorHoverMap["blue-dark"] = "hover:icon-base-blue-900";
    ColorHoverMap["teal"] = "hover:icon-base-teal-500";
    ColorHoverMap["white"] = "hover:icon-base-white";
    ColorHoverMap["gray-light"] = "hover:icon-base-gray-100";
    ColorHoverMap["gray"] = "hover:icon-base-gray-400";
    ColorHoverMap["gray-medium"] = "hover:icon-base-gray-500";
    ColorHoverMap["slate"] = "hover:icon-base-gray-700";
    ColorHoverMap["black"] = "hover:icon-base-gray-900";
    ColorHoverMap["green"] = "hover:icon-base-green-400";
    ColorHoverMap["green-dark"] = "hover:icon-base-green-600";
    ColorHoverMap["red-light"] = "hover:icon-base-red-50";
    ColorHoverMap["red"] = "hover:icon-base-red-600";
    ColorHoverMap["gold"] = "hover:icon-base-yellow-200";
    ColorHoverMap["yellow"] = "hover:icon-base-yellow-200";
    ColorHoverMap["transparent"] = "hover:icon-base-transparent";
})(ColorHoverMap || (ColorHoverMap = {}));
var HighlightHoverMap;
(function (HighlightHoverMap) {
    HighlightHoverMap["blue-light"] = "hover:icon-highlight-blue-100";
    HighlightHoverMap["blue"] = "hover:icon-highlight-blue-600";
    HighlightHoverMap["blue-mid"] = "hover:icon-highlight-blue-700";
    HighlightHoverMap["blue-dark"] = "hover:icon-highlight-blue-900";
    HighlightHoverMap["teal"] = "hover:icon-highlight-teal-500";
    HighlightHoverMap["white"] = "hover:icon-highlight-white";
    HighlightHoverMap["gray-light"] = "hover:icon-highlight-gray-100";
    HighlightHoverMap["gray"] = "hover:icon-highlight-gray-400";
    HighlightHoverMap["gray-medium"] = "hover:icon-highlight-gray-500";
    HighlightHoverMap["slate"] = "hover:icon-highlight-gray-700";
    HighlightHoverMap["black"] = "hover:icon-highlight-gray-900";
    HighlightHoverMap["green"] = "hover:icon-highlight-green-400";
    HighlightHoverMap["green-dark"] = "hover:icon-highlight-green-600";
    HighlightHoverMap["red-light"] = "hover:icon-highlight-red-50";
    HighlightHoverMap["red"] = "hover:icon-highlight-red-600";
    HighlightHoverMap["gold"] = "hover:icon-highlight-yellow-200";
    HighlightHoverMap["yellow"] = "hover:icon-highlight-yellow-200";
    HighlightHoverMap["transparent"] = "hover:icon-highlight-transparent";
})(HighlightHoverMap || (HighlightHoverMap = {}));


;// CONCATENATED MODULE: ../../src/react/src/components/SvgIcon/index.tsx





var SvgIcon = react.memo(function (_a) {
    var _b;
    var name = _a.name, size = _a.size, color = _a.color, colorHover = _a.colorHover, highlight = _a.highlight, highlightHover = _a.highlightHover, className = _a.className;
    var SvgComponent = loadable_esm(function () { return __webpack_require__(2845)("./".concat(name, ".tsx")); });
    return ((0,jsx_runtime.jsx)(SvgComponent, { className: clsx_m("Icon", (_b = {},
            _b[SizeMap[size]] = size,
            _b[ColorMap[color]] = color,
            _b[HighlightMap[highlight]] = highlight,
            _b[ColorHoverMap[colorHover]] = colorHover,
            _b[HighlightHoverMap[highlightHover]] = highlightHover,
            _b["".concat(className)] = className,
            _b)) }));
});
/* harmony default export */ const components_SvgIcon = (SvgIcon);

;// CONCATENATED MODULE: ../../src/react/src/components/ShowHint/ShowHint.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ShowHint_module = ({"ReactHintIcon":"QxFwoV7XpSGcscMjndow","IsDisabled":"rR5721hTdEykgqx06EOB","ReactHintTopTriangle":"eOefWr_gndhkV06DX3zj","HintOpenLeft":"wXbgTBQO1vhsApudpjRU","HintOpenRight":"z5k5ZLJC3mSNiUZYo3o0"});
;// CONCATENATED MODULE: ../../src/react/src/scss/Global.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Global_module = ({"ReactRadioButtonGroupLabel":"e_KAXeuSLhv6OVAr6qUu","ReactCheckBoxGroupLabel":"YGQ5rv77cMIiEeyb0kIZ","ReactInputFieldLabel":"Pwi47clRynwWcwi5CAdO","ReactSupportiveText":"uC5THFLTMU6DMTGEhmTO","ReactRadioButtonLabel":"UgLCIfCqVP80BSnypkmX","ReactCheckBoxLabel":"B0h3HR_RL4u8vWu_5Z_L","Focus":"VDMGp_ww_MEVqaELMJBR","ReactElementIsDisabled":"PISb643LDnpmqjlfZe5c","LabelText":"aSathc98Khe3tEAa50wE","ReactCheckBox":"Abq1XfTPqT9XOlNA5QWd","ReactInputField":"BsPh5pITe4ngiBgWp7Vt","ReactSelect":"qR15cmi2RAw1rLRfnGe_","IsDisabled":"oVAzI2wcR1MEHaFhPFoQ","HasErrors":"P5JquHDm1kHK4bm6Ioq0","ReactElementTopPadding":"pvkmvqSCsogqw1gNxT73","ReactElementTopSpace":"Te3hRXoKBtgNqg31UhYa","Horizontal":"Ief90C8NmvmkDG5VMNyw"});
;// CONCATENATED MODULE: ../../src/react/src/components/ShowHint/index.tsx
var ShowHint_assign = (undefined && undefined.__assign) || function () {
    ShowHint_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ShowHint_assign.apply(this, arguments);
};






function ShowHint(_a) {
    var _b;
    var hintText = _a.hintText, disabled = _a.disabled, _c = _a.position, position = _c === void 0 ? 'right' : _c;
    return ((0,jsx_runtime.jsx)("div", ShowHint_assign({ className: clsx_m("".concat(ShowHint_module.ReactHintIcon, " ").concat(ShowHint_module.ReactHintTopTriangle, " ").concat(position === 'right'
            ? ShowHint_module.HintOpenRight
            : ShowHint_module.HintOpenLeft, " align-self-flex-start self-start font-normal"), (_b = {},
            _b["".concat(Global_module.ReactElementIsDisabled, " ").concat(ShowHint_module.IsDisabled)] = disabled,
            _b)), "data-hint": hintText, role: "note", "aria-label": hintText }, { children: (0,jsx_runtime.jsx)(components_SvgIcon, { name: "Info", size: "xs", className: "Icon-glyph" }) })));
}
/* harmony default export */ const components_ShowHint = (ShowHint);

;// CONCATENATED MODULE: ../../src/react/src/components/ShowError/ShowError.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ShowError_module = ({"ReactErrorIcon":"EuSJ9FTDrg_ye9OFDv_S","ReactErrorText":"hSEjrsbRziI5OQvu4_Ly","ReactErrorTopSpace":"oFdBNtzlpdDoE41xlr1F"});
;// CONCATENATED MODULE: ../../src/react/src/components/ShowError/index.tsx
var ShowError_assign = (undefined && undefined.__assign) || function () {
    ShowError_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ShowError_assign.apply(this, arguments);
};





function ShowError(_a) {
    var errorText = _a.errorText, containerClasses = _a.containerClasses;
    return ((0,jsx_runtime.jsxs)("div", ShowError_assign({ className: containerClasses !== null && containerClasses !== void 0 ? containerClasses : "w-full display-flex flex ".concat(ShowError_module.ReactErrorTopSpace), role: "note", "aria-label": errorText }, { children: [(0,jsx_runtime.jsx)("div", ShowError_assign({ className: "".concat(ShowError_module.ReactErrorIcon, " text-red align-self-flex-start text-red-600 self-start") }, { children: (0,jsx_runtime.jsx)(components_SvgIcon, { name: "Error", size: "xs", className: "Icon-glyph" }) })), (0,jsx_runtime.jsx)("span", ShowError_assign({ className: "".concat(Global_module.ReactSupportiveText, " ").concat(ShowError_module.ReactErrorText, " text-red text-red-600") }, { children: errorText }))] })));
}
/* harmony default export */ const components_ShowError = (ShowError);

;// CONCATENATED MODULE: ../../src/react/src/components/InputField/InputField.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputField_module = ({"ReactInputFieldContainer":"koERVitu2SzlvSsw6ho0","WithPrefix":"V9ee856NVbnqtNa7XEng","LeadingIcon":"a8Hg2wBGTM6P7qNrliBp","WithSuffix":"GeqbVMxPrTZp4a2PPeaW","TrailingIcon":"m5L2eUAwSz_UgjnArqtI","ExtraContent":"di9rx46mRpzNAidzESJM","IsDisabled":"VPlavUfCNBZab1iURfGa","HasErrors":"mGAOc8yijxbOXGJovDbd","ReactInputField":"qVwpghzECqFvciuwqvaW"});
;// CONCATENATED MODULE: ../../src/react/src/components/InputField/index.tsx
var InputField_assign = (undefined && undefined.__assign) || function () {
    InputField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return InputField_assign.apply(this, arguments);
};











function InputField(_a) {
    var _b, _c, _d, _e, _f, _g, _h;
    var _j = _a.fixedDecimalScale, fixedDecimalScale = _j === void 0 ? false : _j, inputType = _a.inputType, textInputId = _a.textInputId, label = _a.label, iconPosition = _a.iconPosition, value = _a.value, className = _a.className, placeHolder = _a.placeHolder, supportiveText = _a.supportiveText, hintText = _a.hintText, secondaryText = _a.secondaryText, errorText = _a.errorText, inputMode = _a.inputMode, _k = _a.disabled, disabled = _k === void 0 ? false : _k, decimalScale = _a.decimalScale, _l = _a.required, required = _l === void 0 ? false : _l, min = _a.min, max = _a.max, maxLength = _a.maxLength, formSubmitted = _a.formSubmitted, onChange = _a.onChange, setErrorText = _a.setErrorText, customRequiredErrorMessage = _a.customRequiredErrorMessage, _m = _a.thousandSeparator, thousandSeparator = _m === void 0 ? ',' : _m, handleBlur = _a.handleBlur, _o = _a.disabledLabelOptional, disabledLabelOptional = _o === void 0 ? false : _o;
    var _p = (0,react.useState)(''), valueAsString = _p[0], setValueAsString = _p[1];
    var randomID = (0,react.useId)();
    var inputId = textInputId || randomID;
    var showPrefix = inputType === 'money';
    var showSuffix = inputType === 'percent' || (inputType === 'number' && secondaryText);
    var showIcon = inputType === 'text' && iconPosition !== 'none';
    var showLeadingIcon = inputType === 'text' && iconPosition === 'leading';
    var showTrailingIcon = inputType === 'text' && iconPosition === 'trailing';
    var _q = (0,react.useState)(null), cursor = _q[0], setCursor = _q[1];
    var inputRef = (0,react.useRef)(null);
    var validateRequired = (0,react.useCallback)(function (inputValue) {
        if (!setErrorText) {
            return true;
        }
        if (required && !inputValue) {
            setErrorText(customRequiredErrorMessage || 'This field cannot be blank');
            return false;
        }
        setErrorText('');
        return true;
    }, [required, setErrorText, customRequiredErrorMessage]);
    var validateMinAndMax = (0,react.useCallback)(function (inputValue) {
        if (inputType === 'text' || !setErrorText) {
            return true;
        }
        var valueAsNumber = convertStringToNumberOrNull(inputValue ? inputValue.toString() : '');
        if (valueAsNumber === null) {
            return true;
        }
        if ((min || min === 0) && valueAsNumber < min) {
            setErrorText("Minimum value is ".concat(commaFormat(min, 'number')));
            return false;
        }
        if ((max || max === 0) && valueAsNumber > max) {
            setErrorText("Maximum value is ".concat(commaFormat(max, 'number')));
            return false;
        }
        setErrorText('');
        return true;
    }, [inputType, max, min, setErrorText]);
    var getDecimalScale = function () {
        if (decimalScale !== undefined) {
            return decimalScale;
        }
        if (inputType === 'money') {
            return constants_MaxLength.MoneyFractionalPart;
        }
        if (inputType === 'percent') {
            return constants_MaxLength.PercentWholeNumber;
        }
        if (inputType === 'text') {
            return 0;
        }
        return constants_MaxLength.DefaultFractionalPart;
    };
    var getMaxLength = function () {
        if (maxLength !== undefined) {
            return maxLength;
        }
        if (inputType === 'percent') {
            return constants_MaxLength.PercentWholeNumber + getDecimalScale();
        }
        if (inputType === 'text') {
            return constants_MaxLength.Text;
        }
        return constants_MaxLength.DefaultWholeNumber + getDecimalScale();
    };
    (0,react.useEffect)(function () {
        var input = inputRef.current;
        if (input && cursor !== null)
            input.setSelectionRange(cursor, cursor);
    }, [inputRef, cursor, valueAsString]);
    (0,react.useEffect)(function () {
        if (value === 0) {
            setValueAsString('0');
            return;
        }
        setValueAsString(value ? value.toString() : '');
    }, [value, inputType]);
    (0,react.useEffect)(function () {
        if (!formSubmitted) {
            return;
        }
        if (validateRequired(valueAsString)) {
            validateMinAndMax(valueAsString);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [formSubmitted, validateRequired, validateMinAndMax]);
    // Block to define the format character
    var dataFormat;
    switch (inputType) {
        case 'money':
            dataFormat = '$';
            break;
        case 'percent':
            dataFormat = '%';
            break;
        case 'number':
            dataFormat = secondaryText;
            break;
        default:
            dataFormat = '';
    }
    // Function for input format
    var handleChange = function (event) {
        if (inputType === 'text') {
            setCursor(event.target.selectionStart);
        }
        if (onChange) {
            onChange(event);
        }
        if (validateRequired(event.target.value)) {
            validateMinAndMax(event.target.value);
        }
    };
    var handleOnBlur = function (e) {
        if (!handleBlur) {
            return;
        }
        // eslint-disable-next-line consistent-return
        return handleBlur(e);
    };
    return ((0,jsx_runtime.jsxs)("div", InputField_assign({ className: className }, { children: [(0,jsx_runtime.jsxs)("div", InputField_assign({ className: "flex flex-row content-between w-full display-flex flex flex-direction-row flex-row align-content-space-between content-between" }, { children: [(0,jsx_runtime.jsxs)("label", InputField_assign({ className: clsx_m("".concat(Global_module.ReactInputFieldLabel, " w-full"), (_b = {},
                            _b[Global_module.ReactElementIsDisabled] = disabled,
                            _b)), htmlFor: inputId }, { children: [label, !required && !disabledLabelOptional && (0,jsx_runtime.jsx)("span", { children: " (optional)" })] })), hintText && (0,jsx_runtime.jsx)(components_ShowHint, { hintText: hintText, disabled: disabled })] })), errorText && (0,jsx_runtime.jsx)(components_ShowError, { errorText: errorText }), (0,jsx_runtime.jsxs)("div", InputField_assign({ className: clsx_m("".concat(InputField_module.ReactInputFieldContainer), (_c = {},
                    _c[InputField_module.WithPrefix] = showPrefix,
                    _c[InputField_module.WithSuffix] = showSuffix,
                    _c[InputField_module.LeadingIcon] = showLeadingIcon,
                    _c[InputField_module.TrailingIcon] = showTrailingIcon,
                    _c[InputField_module.IsDisabled] = disabled,
                    _c[InputField_module.HasErrors] = errorText,
                    _c)), "data-content": dataFormat }, { children: [inputType === 'text' ? ((0,jsx_runtime.jsx)("input", { className: clsx_m("ReactComponent ".concat(Global_module.ReactInputField, " ").concat(InputField_module.ReactInputField), (_d = {},
                            _d[Global_module.IsDisabled] = disabled,
                            _d)), ref: inputRef, type: "text", inputMode: inputMode || (inputType === 'text' ? 'text' : 'decimal'), id: inputId, name: inputId, "data-testid": inputId, placeholder: placeHolder, disabled: disabled, onChange: handleChange, value: valueAsString, "aria-required": !!required, onBlur: handleOnBlur, maxLength: getMaxLength() })) : ((0,jsx_runtime.jsx)(NumericFormat, { fixedDecimalScale: fixedDecimalScale, allowLeadingZeros: false, thousandSeparator: thousandSeparator, className: clsx_m("ReactComponent ".concat(Global_module.ReactInputField, " ").concat(InputField_module.ReactInputField), (_e = {},
                            _e[Global_module.IsDisabled] = disabled,
                            _e)), type: "text", inputMode: inputMode || 'decimal', id: inputId, name: inputId, "data-testid": inputId, placeholder: placeHolder, disabled: disabled, onChange: handleChange, value: valueAsString, "aria-required": !!required, onBlur: handleOnBlur, allowedDecimalSeparators: [''], decimalScale: getDecimalScale(), maxLength: getMaxLength(), "data-lpignore": true })), (0,jsx_runtime.jsxs)("label", InputField_assign({ htmlFor: inputId, className: clsx_m(InputField_module.ExtraContent, (_f = {},
                            _f[InputField_module.ReactInputFieldIcon] = showIcon,
                            _f[InputField_module.LeadingIcon] = showLeadingIcon,
                            _f[InputField_module.TrailingIcon] = showTrailingIcon,
                            _f[InputField_module.WithPrefix] = showPrefix,
                            _f[InputField_module.WithSuffix] = showSuffix,
                            _f[InputField_module.IsDisabled] = disabled,
                            _f)) }, { children: [(showPrefix || showSuffix) && dataFormat, showIcon && ((0,jsx_runtime.jsx)(components_SvgIcon, { name: "Profile", size: "sm", className: clsx_m((_g = {},
                                    _g[Global_module.ReactElementIsDisabled] = disabled,
                                    _g)) }))] }))] })), (0,jsx_runtime.jsx)("span", InputField_assign({ className: clsx_m("".concat(Global_module.ReactSupportiveText, " ").concat(Global_module.ReactElementTopPadding), (_h = {},
                    _h[Global_module.ReactElementIsDisabled] = disabled,
                    _h)) }, { children: supportiveText }))] })));
}
/* harmony default export */ const components_InputField = (InputField);

;// CONCATENATED MODULE: ./node_modules/@react-aria/utils/dist/import.mjs





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, react).useLayoutEffect : ()=>{};



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {
    const ref = (0, react.useRef)(null);
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        ref.current = fn;
    }, [
        fn
    ]);
    // @ts-ignore
    return (0, react.useCallback)((...args)=>{
        const f = ref.current;
        return f === null || f === void 0 ? void 0 : f(...args);
    }, []);
}


function $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {
    let [value, setValue] = (0, $12uGp$useState)(defaultValue);
    let effect = (0, $12uGp$useRef)(null);
    // Store the function in a ref so we can always access the current version
    // which has the proper `value` in scope.
    let nextRef = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{
        if (!effect.current) return;
        // Run the generator to the next yield.
        let newValue = effect.current.next();
        // If the generator is done, reset the effect.
        if (newValue.done) {
            effect.current = null;
            return;
        }
        // If the value is the same as the current value,
        // then continue to the next yield. Otherwise,
        // set the value in state and wait for the next layout effect.
        if (value === newValue.value) nextRef();
        else setValue(newValue.value);
    });
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        // If there is an effect currently running, continue to the next yield.
        if (effect.current) nextRef();
    });
    let queue = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((fn)=>{
        effect.current = fn(value);
        nextRef();
    });
    return [
        value,
        queue
    ];
}


// copied from SSRProvider.tsx to reduce exports, if needed again, consider sharing
let $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
let $bdb11010cef70236$var$idsUpdaterMap = new Map();
function $bdb11010cef70236$export$f680877a34711e37(defaultId) {
    let [value, setValue] = (0, $12uGp$useState)(defaultId);
    let nextId = (0, $12uGp$useRef)(null);
    let res = (0, $12uGp$useSSRSafeId)(value);
    let updateValue = (0, $12uGp$useCallback)((val)=>{
        nextId.current = val;
    }, []);
    if ($bdb11010cef70236$var$canUseDOM) $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        let r = res;
        return ()=>{
            $bdb11010cef70236$var$idsUpdaterMap.delete(r);
        };
    }, [
        res
    ]);
    // This cannot cause an infinite loop because the ref is updated first.
    // eslint-disable-next-line
    (0, $12uGp$useEffect)(()=>{
        let newId = nextId.current;
        if (newId) {
            nextId.current = null;
            setValue(newId);
        }
    });
    return res;
}
function $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {
    if (idA === idB) return idA;
    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);
    if (setIdA) {
        setIdA(idB);
        return idB;
    }
    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);
    if (setIdB) {
        setIdB(idA);
        return idA;
    }
    return idB;
}
function $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {
    let id = $bdb11010cef70236$export$f680877a34711e37();
    let [resolvedId, setResolvedId] = (0, $1dbecbe27a04f9af$export$14d238f342723f25)(id);
    let updateId = (0, $12uGp$useCallback)(()=>{
        setResolvedId(function*() {
            yield id;
            yield document.getElementById(id) ? id : undefined;
        });
    }, [
        id,
        setResolvedId
    ]);
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(updateId, [
        id,
        updateId,
        ...depArray
    ]);
    return resolvedId;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /**
 * Calls all functions in the order they were chained with the same arguments.
 */ function $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {
    return (...args)=>{
        for (let callback of callbacks)if (typeof callback === "function") callback(...args);
    };
}


const $431fbd86ca7dc216$export$b204af158042fbac = (el)=>{
    var _el_ownerDocument;
    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el)=>{
    if (el && "window" in el && el.window === el) return el;
    const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
    return doc.defaultView || window;
};


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {
    // Start with a base clone of the first argument. This is a lot faster than starting
    // with an empty object and adding properties as we go.
    let result = {
        ...args[0]
    };
    for(let i = 1; i < args.length; i++){
        let props = args[i];
        for(let key in props){
            let a = result[key];
            let b = props[key];
            // Chain events
            if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
            key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);
            else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") result[key] = (0, $12uGp$clsx)(a, b);
            else if (key === "id" && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);
            else result[key] = b !== undefined ? b : a;
        }
    }
    return result;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $5dc95899b306f630$export$c9058316764c140e(...refs) {
    if (refs.length === 1) return refs[0];
    return (value)=>{
        for (let ref of refs){
            if (typeof ref === "function") ref(value);
            else if (ref != null) ref.current = value;
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ const $65484d02dcb7eb3e$var$DOMPropNames = new Set([
    "id"
]);
const $65484d02dcb7eb3e$var$labelablePropNames = new Set([
    "aria-label",
    "aria-labelledby",
    "aria-describedby",
    "aria-details"
]);
// See LinkDOMProps in dom.d.ts.
const $65484d02dcb7eb3e$var$linkPropNames = new Set([
    "href",
    "target",
    "rel",
    "download",
    "ping",
    "referrerPolicy"
]);
const $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;
function $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {}) {
    let { labelable: labelable, isLink: isLink, propNames: propNames } = opts;
    let filteredProps = {};
    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || isLink && $65484d02dcb7eb3e$var$linkPropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];
    return filteredProps;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $7215afc6de606d6b$export$de79e2c695e052f3(element) {
    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({
        preventScroll: true
    });
    else {
        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);
        element.focus();
        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
    }
}
let $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
        $7215afc6de606d6b$var$supportsPreventScrollCached = false;
        try {
            let focusElem = document.createElement("div");
            focusElem.focus({
                get preventScroll () {
                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;
                    return true;
                }
            });
        } catch (e) {
        // Ignore
        }
    }
    return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element) {
    let parent = element.parentNode;
    let scrollableElements = [];
    let rootScrollingElement = document.scrollingElement || document.documentElement;
    while(parent instanceof HTMLElement && parent !== rootScrollingElement){
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
        });
        parent = parent.parentNode;
    }
    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
        element: rootScrollingElement,
        scrollTop: rootScrollingElement.scrollTop,
        scrollLeft: rootScrollingElement.scrollLeft
    });
    return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
    for (let { element: element, scrollTop: scrollTop, scrollLeft: scrollLeft } of scrollableElements){
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = "horizontal") {
    let rect = element.getBoundingClientRect();
    if (reverse) return orientation === "horizontal" ? rect.right : rect.bottom;
    return orientation === "horizontal" ? rect.left : rect.top;
}


/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $c87311424ea30a05$var$testUserAgent(re) {
    var _window_navigator_userAgentData;
    if (typeof window === "undefined" || window.navigator == null) return false;
    return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand)=>re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
    var _window_navigator_userAgentData;
    return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$export$9ac100e40613ea10() {
    return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}
function $c87311424ea30a05$export$186c6964ca17d99() {
    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
}
function $c87311424ea30a05$export$7bef049ce92e4224() {
    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
}
function $c87311424ea30a05$export$fedb369cb70207f1() {
    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
}
function $c87311424ea30a05$export$e1865c3bedcd822b() {
    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
}
function $c87311424ea30a05$export$78551043582a6a98() {
    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
}
function $c87311424ea30a05$export$6446a186d09e379e() {
    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
}
function $c87311424ea30a05$export$a11b0059900ceec8() {
    return $c87311424ea30a05$var$testUserAgent(/Android/i);
}
function $c87311424ea30a05$export$b7d78993b74f766d() {
    return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
}




const $ea8dcbcb9ea1b556$var$RouterContext = /*#__PURE__*/ (0, react.createContext)({
    isNative: true,
    open: $ea8dcbcb9ea1b556$var$openSyntheticLink
});
function $ea8dcbcb9ea1b556$export$323e4fc2fa4753fb(props) {
    let { children: children, navigate: navigate } = props;
    let ctx = (0, $12uGp$useMemo)(()=>({
            isNative: false,
            open: (target, modifiers)=>{
                $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>{
                    if ($ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers)) navigate(link.pathname + link.search + link.hash);
                    else $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers);
                });
            }
        }), [
        navigate
    ]);
    return /*#__PURE__*/ (0, $12uGp$react).createElement($ea8dcbcb9ea1b556$var$RouterContext.Provider, {
        value: ctx
    }, children);
}
function $ea8dcbcb9ea1b556$export$9a302a45f65d0572() {
    return (0, $12uGp$useContext)($ea8dcbcb9ea1b556$var$RouterContext);
}
function $ea8dcbcb9ea1b556$export$efa8c9099e530235(link, modifiers) {
    // Use getAttribute here instead of link.target. Firefox will default link.target to "_parent" when inside an iframe.
    let target = link.getAttribute("target");
    return (!target || target === "_self") && link.origin === location.origin && !link.hasAttribute("download") && !modifiers.metaKey && // open in new tab (mac)
    !modifiers.ctrlKey && // open in new tab (windows)
    !modifiers.altKey && // download
    !modifiers.shiftKey;
}
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
    var _window_event_type, _window_event;
    let { metaKey: metaKey, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey } = modifiers;
    // Firefox does not recognize keyboard events as a user action by default, and the popup blocker
    // will prevent links with target="_blank" from opening. However, it does allow the event if the
    // Command/Control key is held, which opens the link in a background tab. This seems like the best we can do.
    // See https://bugzilla.mozilla.org/show_bug.cgi?id=257870 and https://bugzilla.mozilla.org/show_bug.cgi?id=746640.
    if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
        if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;
        else ctrlKey = true;
    }
    // WebKit does not support firing click events with modifier keys, but does support keyboard events.
    // https://github.com/WebKit/WebKit/blob/c03d0ac6e6db178f90923a0a63080b5ca210d25f/Source/WebCore/html/HTMLAnchorElement.cpp#L184
    let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
        keyIdentifier: "Enter",
        metaKey: metaKey,
        ctrlKey: ctrlKey,
        altKey: altKey,
        shiftKey: shiftKey
    }) : new MouseEvent("click", {
        metaKey: metaKey,
        ctrlKey: ctrlKey,
        altKey: altKey,
        shiftKey: shiftKey,
        bubbles: true,
        cancelable: true
    });
    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
    (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
    target.dispatchEvent(event);
    $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
// https://github.com/parcel-bundler/parcel/issues/8724
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open) {
    if (target instanceof HTMLAnchorElement) open(target);
    else if (target.hasAttribute("data-href")) {
        let link = document.createElement("a");
        link.href = target.getAttribute("data-href");
        if (target.hasAttribute("data-target")) link.target = target.getAttribute("data-target");
        if (target.hasAttribute("data-rel")) link.rel = target.getAttribute("data-rel");
        if (target.hasAttribute("data-download")) link.download = target.getAttribute("data-download");
        if (target.hasAttribute("data-ping")) link.ping = target.getAttribute("data-ping");
        if (target.hasAttribute("data-referrer-policy")) link.referrerPolicy = target.getAttribute("data-referrer-policy");
        target.appendChild(link);
        open(link);
        target.removeChild(link);
    }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
    $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link)=>$ea8dcbcb9ea1b556$export$95185d699e05d4d7(link, modifiers));
}
function $ea8dcbcb9ea1b556$export$51437d503373d223(props) {
    return {
        "data-href": props.href,
        "data-target": props.target,
        "data-rel": props.rel,
        "data-download": props.download,
        "data-ping": props.ping,
        "data-referrer-policy": props.referrerPolicy
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // We store a global list of elements that are currently transitioning,
// mapped to a set of CSS properties that are transitioning for that element.
// This is necessary rather than a simple count of transitions because of browser
// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather
// than one or the other. So we need to track what's actually transitioning so that
// we can ignore these duplicate events.
let $bbed8b41f857bcc0$var$transitionsByElement = new Map();
// A list of callbacks to call once there are no transitioning elements.
let $bbed8b41f857bcc0$var$transitionCallbacks = new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
    if (typeof window === "undefined") return;
    function isTransitionEvent(event) {
        return "propertyName" in event;
    }
    let onTransitionStart = (e)=>{
        if (!isTransitionEvent(e) || !e.target) return;
        // Add the transitioning property to the list for this element.
        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);
        if (!transitions) {
            transitions = new Set();
            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);
            // The transitioncancel event must be registered on the element itself, rather than as a global
            // event. This enables us to handle when the node is deleted from the document while it is transitioning.
            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.
            e.target.addEventListener("transitioncancel", onTransitionEnd, {
                once: true
            });
        }
        transitions.add(e.propertyName);
    };
    let onTransitionEnd = (e)=>{
        if (!isTransitionEvent(e) || !e.target) return;
        // Remove property from list of transitioning properties.
        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);
        if (!properties) return;
        properties.delete(e.propertyName);
        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.
        if (properties.size === 0) {
            e.target.removeEventListener("transitioncancel", onTransitionEnd);
            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);
        }
        // If no transitioning elements, call all of the queued callbacks.
        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();
            $bbed8b41f857bcc0$var$transitionCallbacks.clear();
        }
    };
    document.body.addEventListener("transitionrun", onTransitionStart);
    document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
    if (document.readyState !== "loading") $bbed8b41f857bcc0$var$setupGlobalEvents();
    else document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}
function $bbed8b41f857bcc0$export$24490316f764c430(fn) {
    // Wait one frame to see if an animation starts, e.g. a transition on mount.
    requestAnimationFrame(()=>{
        // If no transitions are running, call the function immediately.
        // Otherwise, add it to a list of callbacks to run at the end of the animation.
        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();
        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 

// Keep track of elements that we are currently handling dragging for via useDrag1D.
// If there's an ancestor and a descendant both using useDrag1D(), and the user starts
// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.
const $9cc09df9fd7676be$var$draggingElements = (/* unused pure expression or super */ null && ([]));
function $9cc09df9fd7676be$export$7bbed75feba39706(props) {
    console.warn("useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html");
    let { containerRef: containerRef, reverse: reverse, orientation: orientation, onHover: onHover, onDrag: onDrag, onPositionChange: onPositionChange, onIncrement: onIncrement, onDecrement: onDecrement, onIncrementToMax: onIncrementToMax, onDecrementToMin: onDecrementToMin, onCollapseToggle: onCollapseToggle } = props;
    let getPosition = (e)=>orientation === "horizontal" ? e.clientX : e.clientY;
    let getNextOffset = (e)=>{
        let containerOffset = (0, $ab71dadb03a6fb2e$export$622cea445a1c5b7d)(containerRef.current, reverse, orientation);
        let mouseOffset = getPosition(e);
        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;
        return nextOffset;
    };
    let dragging = (0, $12uGp$useRef)(false);
    let prevPosition = (0, $12uGp$useRef)(0);
    // Keep track of the current handlers in a ref so that the events can access them.
    let handlers = (0, $12uGp$useRef)({
        onPositionChange: onPositionChange,
        onDrag: onDrag
    });
    handlers.current.onDrag = onDrag;
    handlers.current.onPositionChange = onPositionChange;
    let onMouseDragged = (e)=>{
        e.preventDefault();
        let nextOffset = getNextOffset(e);
        if (!dragging.current) {
            dragging.current = true;
            if (handlers.current.onDrag) handlers.current.onDrag(true);
            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        }
        if (prevPosition.current === nextOffset) return;
        prevPosition.current = nextOffset;
        if (onPositionChange) onPositionChange(nextOffset);
    };
    let onMouseUp = (e)=>{
        const target = e.target;
        dragging.current = false;
        let nextOffset = getNextOffset(e);
        if (handlers.current.onDrag) handlers.current.onDrag(false);
        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);
        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);
        window.removeEventListener("mouseup", onMouseUp, false);
        window.removeEventListener("mousemove", onMouseDragged, false);
    };
    let onMouseDown = (e)=>{
        const target = e.currentTarget;
        // If we're already handling dragging on a descendant with useDrag1D, then
        // we don't want to handle the drag motion on this target as well.
        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt))) return;
        $9cc09df9fd7676be$var$draggingElements.push(target);
        window.addEventListener("mousemove", onMouseDragged, false);
        window.addEventListener("mouseup", onMouseUp, false);
    };
    let onMouseEnter = ()=>{
        if (onHover) onHover(true);
    };
    let onMouseOut = ()=>{
        if (onHover) onHover(false);
    };
    let onKeyDown = (e)=>{
        switch(e.key){
            case "Left":
            case "ArrowLeft":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Up":
            case "ArrowUp":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onDecrement && !reverse) onDecrement();
                    else if (onIncrement && reverse) onIncrement();
                }
                break;
            case "Right":
            case "ArrowRight":
                if (orientation === "horizontal") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Down":
            case "ArrowDown":
                if (orientation === "vertical") {
                    e.preventDefault();
                    if (onIncrement && !reverse) onIncrement();
                    else if (onDecrement && reverse) onDecrement();
                }
                break;
            case "Home":
                e.preventDefault();
                if (onDecrementToMin) onDecrementToMin();
                break;
            case "End":
                e.preventDefault();
                if (onIncrementToMax) onIncrementToMax();
                break;
            case "Enter":
                e.preventDefault();
                if (onCollapseToggle) onCollapseToggle();
                break;
        }
    };
    return {
        onMouseDown: onMouseDown,
        onMouseEnter: onMouseEnter,
        onMouseOut: onMouseOut,
        onKeyDown: onKeyDown
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
    let globalListeners = (0, $12uGp$useRef)(new Map());
    let addGlobalListener = (0, $12uGp$useCallback)((eventTarget, type, listener, options)=>{
        // Make sure we remove the listener after it is called with the `once` option.
        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{
            globalListeners.current.delete(listener);
            listener(...args);
        } : listener;
        globalListeners.current.set(listener, {
            type: type,
            eventTarget: eventTarget,
            fn: fn,
            options: options
        });
        eventTarget.addEventListener(type, listener, options);
    }, []);
    let removeGlobalListener = (0, $12uGp$useCallback)((eventTarget, type, listener, options)=>{
        var _globalListeners_current_get;
        let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
        eventTarget.removeEventListener(type, fn, options);
        globalListeners.current.delete(listener);
    }, []);
    let removeAllGlobalListeners = (0, $12uGp$useCallback)(()=>{
        globalListeners.current.forEach((value, key)=>{
            removeGlobalListener(value.eventTarget, value.type, key, value.options);
        });
    }, [
        removeGlobalListener
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $12uGp$useEffect)(()=>{
        return removeAllGlobalListeners;
    }, [
        removeAllGlobalListeners
    ]);
    return {
        addGlobalListener: addGlobalListener,
        removeGlobalListener: removeGlobalListener,
        removeAllGlobalListeners: removeAllGlobalListeners
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {
    let { id: id, "aria-label": label, "aria-labelledby": labelledBy } = props;
    // If there is both an aria-label and aria-labelledby,
    // combine them by pointing to the element itself.
    id = (0, $bdb11010cef70236$export$f680877a34711e37)(id);
    if (labelledBy && label) {
        let ids = new Set([
            id,
            ...labelledBy.trim().split(/\s+/)
        ]);
        labelledBy = [
            ...ids
        ].join(" ");
    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\s+/).join(" ");
    // If no labels are provided, use the default
    if (!label && !labelledBy && defaultLabel) label = defaultLabel;
    return {
        id: id,
        "aria-label": label,
        "aria-labelledby": labelledBy
    };
}


/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {
    const objRef = (0, $12uGp$useRef)(null);
    return (0, $12uGp$useMemo)(()=>({
            get current () {
                return objRef.current;
            },
            set current (value){
                objRef.current = value;
                if (typeof forwardedRef === "function") forwardedRef(value);
                else if (forwardedRef) forwardedRef.current = value;
            }
        }), [
        forwardedRef
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {
    const isInitialMount = (0, $12uGp$useRef)(true);
    const lastDeps = (0, $12uGp$useRef)(null);
    (0, $12uGp$useEffect)(()=>{
        isInitialMount.current = true;
        return ()=>{
            isInitialMount.current = false;
        };
    }, []);
    (0, $12uGp$useEffect)(()=>{
        if (isInitialMount.current) isInitialMount.current = false;
        else if (!lastDeps.current || dependencies.some((dep, i)=>!Object.is(dep, lastDeps[i]))) effect();
        lastDeps.current = dependencies;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
}




function $9daab02d461809db$var$hasResizeObserver() {
    return typeof window.ResizeObserver !== "undefined";
}
function $9daab02d461809db$export$683480f191c0e3ea(options) {
    const { ref: ref, onResize: onResize } = options;
    (0, $12uGp$useEffect)(()=>{
        let element = ref === null || ref === void 0 ? void 0 : ref.current;
        if (!element) return;
        if (!$9daab02d461809db$var$hasResizeObserver()) {
            window.addEventListener("resize", onResize, false);
            return ()=>{
                window.removeEventListener("resize", onResize, false);
            };
        } else {
            const resizeObserverInstance = new window.ResizeObserver((entries)=>{
                if (!entries.length) return;
                onResize();
            });
            resizeObserverInstance.observe(element);
            return ()=>{
                if (element) resizeObserverInstance.unobserve(element);
            };
        }
    }, [
        onResize,
        ref
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        if (context && context.ref && ref) {
            context.ref.current = ref.current;
            return ()=>{
                if (context.ref) context.ref.current = null;
            };
        }
    });
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $62d8ded9296f3872$export$cfa2225e87938781(node, checkForOverflow) {
    let scrollableNode = node;
    if ($62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow)) scrollableNode = scrollableNode.parentElement;
    while(scrollableNode && !$62d8ded9296f3872$export$2bb74740c4e19def(scrollableNode, checkForOverflow))scrollableNode = scrollableNode.parentElement;
    return scrollableNode || document.scrollingElement || document.documentElement;
}
function $62d8ded9296f3872$export$2bb74740c4e19def(node, checkForOverflow) {
    let style = window.getComputedStyle(node);
    let isScrollable = /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);
    if (isScrollable && checkForOverflow) isScrollable = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;
    return isScrollable;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

// @ts-ignore
let $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;
function $5df64b3807dc15ee$export$d699905dd57c73ca() {
    let isSSR = (0, $12uGp$useIsSSR)();
    let [size, setSize] = (0, $12uGp$useState)(()=>isSSR ? {
            width: 0,
            height: 0
        } : $5df64b3807dc15ee$var$getViewportSize());
    (0, $12uGp$useEffect)(()=>{
        // Use visualViewport api to track available height even on iOS virtual keyboard opening
        let onResize = ()=>{
            setSize((size)=>{
                let newSize = $5df64b3807dc15ee$var$getViewportSize();
                if (newSize.width === size.width && newSize.height === size.height) return size;
                return newSize;
            });
        };
        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener("resize", onResize);
        else $5df64b3807dc15ee$var$visualViewport.addEventListener("resize", onResize);
        return ()=>{
            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener("resize", onResize);
            else $5df64b3807dc15ee$var$visualViewport.removeEventListener("resize", onResize);
        };
    }, []);
    return size;
}
function $5df64b3807dc15ee$var$getViewportSize() {
    return {
        width: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,
        height: $5df64b3807dc15ee$var$visualViewport && ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

let $ef06256079686ba0$var$descriptionId = 0;
const $ef06256079686ba0$var$descriptionNodes = new Map();
function $ef06256079686ba0$export$f8aeda7b10753fa1(description) {
    let [id, setId] = (0, $12uGp$useState)();
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        if (!description) return;
        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);
        if (!desc) {
            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;
            setId(id);
            let node = document.createElement("div");
            node.id = id;
            node.style.display = "none";
            node.textContent = description;
            document.body.appendChild(node);
            desc = {
                refCount: 0,
                element: node
            };
            $ef06256079686ba0$var$descriptionNodes.set(description, desc);
        } else setId(desc.element.id);
        desc.refCount++;
        return ()=>{
            if (desc && --desc.refCount === 0) {
                desc.element.remove();
                $ef06256079686ba0$var$descriptionNodes.delete(description);
            }
        };
    }, [
        description
    ]);
    return {
        "aria-describedby": description ? id : undefined
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler, options) {
    let handleEvent = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(handler);
    let isDisabled = handler == null;
    (0, $12uGp$useEffect)(()=>{
        if (isDisabled || !ref.current) return;
        let element = ref.current;
        element.addEventListener(event, handleEvent, options);
        return ()=>{
            element.removeEventListener(event, handleEvent, options);
        };
    }, [
        ref,
        event,
        options,
        isDisabled,
        handleEvent
    ]);
}



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {
    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, "left");
    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, "top");
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    let x = scrollView.scrollLeft;
    let y = scrollView.scrollTop;
    // Account for top/left border offsetting the scroll top/Left
    let { borderTopWidth: borderTopWidth, borderLeftWidth: borderLeftWidth } = getComputedStyle(scrollView);
    let borderAdjustedX = scrollView.scrollLeft + parseInt(borderLeftWidth, 10);
    let borderAdjustedY = scrollView.scrollTop + parseInt(borderTopWidth, 10);
    // Ignore end/bottom border via clientHeight/Width instead of offsetHeight/Width
    let maxX = borderAdjustedX + scrollView.clientWidth;
    let maxY = borderAdjustedY + scrollView.clientHeight;
    if (offsetX <= x) x = offsetX - parseInt(borderLeftWidth, 10);
    else if (offsetX + width > maxX) x += offsetX + width - maxX;
    if (offsetY <= borderAdjustedY) y = offsetY - parseInt(borderTopWidth, 10);
    else if (offsetY + height > maxY) y += offsetY + height - maxY;
    scrollView.scrollLeft = x;
    scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {
    const prop = axis === "left" ? "offsetLeft" : "offsetTop";
    let sum = 0;
    while(child.offsetParent){
        sum += child[prop];
        if (child.offsetParent === ancestor) break;
        else if (child.offsetParent.contains(ancestor)) {
            // If the ancestor is not `position:relative`, then we stop at
            // _its_ offset parent, and we subtract off _its_ offset, so that
            // we end up with the proper offset from child to ancestor.
            sum -= ancestor[prop];
            break;
        }
        child = child.offsetParent;
    }
    return sum;
}
function $2f04cbc44ee30ce0$export$c826860796309d1b(targetElement, opts) {
    if (document.contains(targetElement)) {
        let root = document.scrollingElement || document.documentElement;
        let isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
        // If scrolling is not currently prevented then we arent in a overlay nor is a overlay open, just use element.scrollIntoView to bring the element into view
        if (!isScrollPrevented) {
            var // use scrollIntoView({block: 'nearest'}) instead of .focus to check if the element is fully in view or not since .focus()
            // won't cause a scroll if the element is already focused and doesn't behave consistently when an element is partially out of view horizontally vs vertically
            _targetElement_scrollIntoView;
            let { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();
            targetElement === null || targetElement === void 0 ? void 0 : (_targetElement_scrollIntoView = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView === void 0 ? void 0 : _targetElement_scrollIntoView.call(targetElement, {
                block: "nearest"
            });
            let { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();
            // Account for sub pixel differences from rounding
            if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
                var _opts_containingElement_scrollIntoView, _opts_containingElement, _targetElement_scrollIntoView1;
                opts === null || opts === void 0 ? void 0 : (_opts_containingElement = opts.containingElement) === null || _opts_containingElement === void 0 ? void 0 : (_opts_containingElement_scrollIntoView = _opts_containingElement.scrollIntoView) === null || _opts_containingElement_scrollIntoView === void 0 ? void 0 : _opts_containingElement_scrollIntoView.call(_opts_containingElement, {
                    block: "center",
                    inline: "center"
                });
                (_targetElement_scrollIntoView1 = targetElement.scrollIntoView) === null || _targetElement_scrollIntoView1 === void 0 ? void 0 : _targetElement_scrollIntoView1.call(targetElement, {
                    block: "nearest"
                });
            }
        } else {
            let scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
            // If scrolling is prevented, we don't want to scroll the body since it might move the overlay partially offscreen and the user can't scroll it back into view.
            while(targetElement && scrollParent && targetElement !== root && scrollParent !== root){
                $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollParent, targetElement);
                targetElement = scrollParent;
                scrollParent = (0, $62d8ded9296f3872$export$cfa2225e87938781)(targetElement);
            }
        }
    }
}



/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $6a7db85432448f7f$export$60278871457622de(event) {
    // JAWS/NVDA with Firefox.
    if (event.mozInputSource === 0 && event.isTrusted) return true;
    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead
    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check
    // to detect TalkBack virtual clicks.
    if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType) return event.type === "click" && event.buttons === 1;
    return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {
    // If the pointer size is zero, then we assume it's from a screen reader.
    // Android TalkBack double tap will sometimes return a event with width and height of 1
    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.
    // Cannot use "event.pressure === 0" as the sole check due to Safari pointer events always returning pressure === 0
    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush
    // Talkback double tap from Windows Firefox touch screen press
    return !(0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}



/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /* eslint-disable rulesdir/pure-render */ 
function $5a387cc49350e6db$export$722debc0e56fea39(value, isEqual) {
    // Using a ref during render is ok here because it's only an optimization  both values are equivalent.
    // If a render is thrown away, it'll still work the same no matter if the next render is the same or not.
    let lastValue = (0, $12uGp$useRef)(null);
    if (value && lastValue.current && isEqual(value, lastValue.current)) value = lastValue.current;
    lastValue.current = value;
    return value;
}


/*
 * Copyright 2023 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $99facab73266f662$export$5add1d006293d136(ref, initialValue, onReset) {
    let resetValue = (0, $12uGp$useRef)(initialValue);
    let handleReset = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)(()=>{
        if (onReset) onReset(resetValue.current);
    });
    (0, $12uGp$useEffect)(()=>{
        var _ref_current;
        let form = ref === null || ref === void 0 ? void 0 : (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.form;
        form === null || form === void 0 ? void 0 : form.addEventListener("reset", handleReset);
        return ()=>{
            form === null || form === void 0 ? void 0 : form.removeEventListener("reset", handleReset);
        };
    }, [
        ref,
        handleReset
    ]);
}





//# sourceMappingURL=module.js.map

;// CONCATENATED MODULE: ./node_modules/@react-aria/interactions/dist/import.mjs







/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions




/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually
let $14c0b72509d70225$var$state = "default";
let $14c0b72509d70225$var$savedUserSelect = "";
let $14c0b72509d70225$var$modifiedElementMap = new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
    if ((0, $bx7SL$isIOS)()) {
        if ($14c0b72509d70225$var$state === "default") {
            // eslint-disable-next-line no-restricted-globals
            const documentObject = (0, $bx7SL$getOwnerDocument)(target);
            $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
            documentObject.documentElement.style.webkitUserSelect = "none";
        }
        $14c0b72509d70225$var$state = "disabled";
    } else if (target instanceof HTMLElement || target instanceof SVGElement) {
        // If not iOS, store the target's original user-select and change to user-select: none
        // Ignore state since it doesn't apply for non iOS
        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
    if ((0, $bx7SL$isIOS)()) {
        // If the state is already default, there's nothing to do.
        // If it is restoring, then there's no need to queue a second restore.
        if ($14c0b72509d70225$var$state !== "disabled") return;
        $14c0b72509d70225$var$state = "restoring";
        // There appears to be a delay on iOS where selection still might occur
        // after pointer up, so wait a bit before removing user-select.
        setTimeout(()=>{
            // Wait for any CSS transitions to complete so we don't recompute style
            // for the whole page in the middle of the animation and cause jank.
            (0, $bx7SL$runAfterTransition)(()=>{
                // Avoid race conditions
                if ($14c0b72509d70225$var$state === "restoring") {
                    // eslint-disable-next-line no-restricted-globals
                    const documentObject = (0, $bx7SL$getOwnerDocument)(target);
                    if (documentObject.documentElement.style.webkitUserSelect === "none") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
                    $14c0b72509d70225$var$savedUserSelect = "";
                    $14c0b72509d70225$var$state = "default";
                }
            });
        }, 300);
    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    {
        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
            if (target.style.userSelect === "none") target.style.userSelect = targetOldUserSelect;
            if (target.getAttribute("style") === "") target.removeAttribute("style");
            $14c0b72509d70225$var$modifiedElementMap.delete(target);
        }
    }
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
const $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, react).createContext({
    register: ()=>{}
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";



function $f6c31cce2adf654f$var$usePressResponderContext(props) {
    // Consume context from <PressResponder> and merge with props.
    let context = (0, $bx7SL$useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
    if (context) {
        let { register: register, ...contextProps } = context;
        props = (0, $bx7SL$mergeProps)(contextProps, props);
        register();
    }
    (0, $bx7SL$useSyncRef)(context, props.ref);
    return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/ new WeakMap();
class $f6c31cce2adf654f$var$PressEvent {
    continuePropagation() {
        (0, $bx7SL$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
    }
    get shouldStopPropagation() {
        return (0, $bx7SL$_)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
    }
    constructor(type, pointerType, originalEvent){
        (0, $bx7SL$_1)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
            writable: true,
            value: void 0
        });
        (0, $bx7SL$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
        this.type = type;
        this.pointerType = pointerType;
        this.target = originalEvent.currentTarget;
        this.shiftKey = originalEvent.shiftKey;
        this.metaKey = originalEvent.metaKey;
        this.ctrlKey = originalEvent.ctrlKey;
        this.altKey = originalEvent.altKey;
    }
}
const $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
    let { onPress: onPress, onPressChange: onPressChange, onPressStart: onPressStart, onPressEnd: onPressEnd, onPressUp: onPressUp, isDisabled: isDisabled, isPressed: isPressedProp, preventFocusOnPress: preventFocusOnPress, shouldCancelOnPointerExit: shouldCancelOnPointerExit, allowTextSelectionOnPress: allowTextSelectionOnPress, // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: _, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);
    let [isPressed, setPressed] = (0, $bx7SL$useState)(false);
    let ref = (0, $bx7SL$useRef)({
        isPressed: false,
        ignoreEmulatedMouseEvents: false,
        ignoreClickAfterPress: false,
        didFirePressStart: false,
        isTriggeringEvent: false,
        activePointerId: null,
        target: null,
        isOverTarget: false,
        pointerType: null
    });
    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, $bx7SL$useGlobalListeners)();
    let triggerPressStart = (0, $bx7SL$useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled || state.didFirePressStart) return false;
        let shouldStopPropagation = true;
        state.isTriggeringEvent = true;
        if (onPressStart) {
            let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
            onPressStart(event);
            shouldStopPropagation = event.shouldStopPropagation;
        }
        if (onPressChange) onPressChange(true);
        state.isTriggeringEvent = false;
        state.didFirePressStart = true;
        setPressed(true);
        return shouldStopPropagation;
    });
    let triggerPressEnd = (0, $bx7SL$useEffectEvent)((originalEvent, pointerType, wasPressed = true)=>{
        let state = ref.current;
        if (!state.didFirePressStart) return false;
        state.ignoreClickAfterPress = true;
        state.didFirePressStart = false;
        state.isTriggeringEvent = true;
        let shouldStopPropagation = true;
        if (onPressEnd) {
            let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
            onPressEnd(event);
            shouldStopPropagation = event.shouldStopPropagation;
        }
        if (onPressChange) onPressChange(false);
        setPressed(false);
        if (onPress && wasPressed && !isDisabled) {
            let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
            onPress(event);
            shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
        }
        state.isTriggeringEvent = false;
        return shouldStopPropagation;
    });
    let triggerPressUp = (0, $bx7SL$useEffectEvent)((originalEvent, pointerType)=>{
        let state = ref.current;
        if (isDisabled) return false;
        if (onPressUp) {
            state.isTriggeringEvent = true;
            let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
            onPressUp(event);
            state.isTriggeringEvent = false;
            return event.shouldStopPropagation;
        }
        return true;
    });
    let cancel = (0, $bx7SL$useEffectEvent)((e)=>{
        let state = ref.current;
        if (state.isPressed && state.target) {
            if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);
            state.isPressed = false;
            state.isOverTarget = false;
            state.activePointerId = null;
            state.pointerType = null;
            removeAllGlobalListeners();
            if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        }
    });
    let cancelOnPointerExit = (0, $bx7SL$useEffectEvent)((e)=>{
        if (shouldCancelOnPointerExit) cancel(e);
    });
    let pressProps = (0, $bx7SL$useMemo)(()=>{
        let state = ref.current;
        let pressProps = {
            onKeyDown (e) {
                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {
                    var _state_metaKeyEvents;
                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                    // If the event is repeating, it may have started on a different element
                    // after which focus moved to the current element. Ignore these events and
                    // only handle the first key down event.
                    let shouldStopPropagation = true;
                    if (!state.isPressed && !e.repeat) {
                        state.target = e.currentTarget;
                        state.isPressed = true;
                        shouldStopPropagation = triggerPressStart(e, "keyboard");
                        // Focus may move before the key up event, so register the event on the document
                        // instead of the same element where the key down event occurred. Make it capturing so that it will trigger
                        // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.
                        let originalTarget = e.currentTarget;
                        let pressUp = (e)=>{
                            if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e, originalTarget) && !e.repeat && originalTarget.contains(e.target) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), "keyboard");
                        };
                        addGlobalListener((0, $bx7SL$getOwnerDocument)(e.currentTarget), "keyup", (0, $bx7SL$chain)(pressUp, onKeyUp), true);
                    }
                    if (shouldStopPropagation) e.stopPropagation();
                    // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.
                    // macOS has a bug where keyup events are not fired while the Meta key is down.
                    // When the Meta key itself is released we will get an event for that, and we'll act as if
                    // all of these other keys were released as well.
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524
                    // https://bugs.webkit.org/show_bug.cgi?id=55291
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553
                    if (e.metaKey && (0, $bx7SL$isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);
                } else if (e.key === "Meta") state.metaKeyEvents = new Map();
            },
            onClick (e) {
                if (e && !e.currentTarget.contains(e.target)) return;
                if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $bx7SL$openLink).isOpening) {
                    let shouldStopPropagation = true;
                    if (isDisabled) e.preventDefault();
                    // If triggered from a screen reader or by using element.click(),
                    // trigger as if it were a keyboard click.
                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $bx7SL$isVirtualClick)(e.nativeEvent))) {
                        // Ensure the element receives focus (VoiceOver on iOS does not do this)
                        if (!isDisabled && !preventFocusOnPress) (0, $bx7SL$focusWithoutScrolling)(e.currentTarget);
                        let stopPressStart = triggerPressStart(e, "virtual");
                        let stopPressUp = triggerPressUp(e, "virtual");
                        let stopPressEnd = triggerPressEnd(e, "virtual");
                        shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
                    }
                    state.ignoreEmulatedMouseEvents = false;
                    state.ignoreClickAfterPress = false;
                    if (shouldStopPropagation) e.stopPropagation();
                }
            }
        };
        let onKeyUp = (e)=>{
            var _state_metaKeyEvents;
            if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {
                var _state_metaKeyEvents1;
                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();
                let target = e.target;
                triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), "keyboard", state.target.contains(target));
                removeAllGlobalListeners();
                // If a link was triggered with a key other than Enter, open the URL ourselves.
                // This means the link has a role override, and the default browser behavior
                // only applies when using the Enter key.
                if (e.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {
                    // Store a hidden property on the event so we only trigger link click once,
                    // even if there are multiple usePress instances attached to the element.
                    e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
                    (0, $bx7SL$openLink)(state.target, e, false);
                }
                state.isPressed = false;
                (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);
            } else if (e.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
                var _state_target;
                // If we recorded keydown events that occurred while the Meta key was pressed,
                // and those haven't received keyup events already, fire keyup events ourselves.
                // See comment above for more info about the macOS bug causing this.
                let events = state.metaKeyEvents;
                state.metaKeyEvents = undefined;
                for (let event of events.values())(_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
            }
        };
        if (typeof PointerEvent !== "undefined") {
            pressProps.onPointerDown = (e)=>{
                // Only handle left clicks, and ignore events that bubbled through portals.
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
                // Ignore and let the onClick handler take care of it instead.
                // https://bugs.webkit.org/show_bug.cgi?id=222627
                // https://bugs.webkit.org/show_bug.cgi?id=223202
                if ((0, $bx7SL$isVirtualPointerEvent)(e.nativeEvent)) {
                    state.pointerType = "virtual";
                    return;
                }
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on pointer down and handle focusing the pressable element ourselves.
                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                state.pointerType = e.pointerType;
                let shouldStopPropagation = true;
                if (!state.isPressed) {
                    state.isPressed = true;
                    state.isOverTarget = true;
                    state.activePointerId = e.pointerId;
                    state.target = e.currentTarget;
                    if (!isDisabled && !preventFocusOnPress) (0, $bx7SL$focusWithoutScrolling)(e.currentTarget);
                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
                    shouldStopPropagation = triggerPressStart(e, state.pointerType);
                    addGlobalListener((0, $bx7SL$getOwnerDocument)(e.currentTarget), "pointermove", onPointerMove, false);
                    addGlobalListener((0, $bx7SL$getOwnerDocument)(e.currentTarget), "pointerup", onPointerUp, false);
                    addGlobalListener((0, $bx7SL$getOwnerDocument)(e.currentTarget), "pointercancel", onPointerCancel, false);
                }
                if (shouldStopPropagation) e.stopPropagation();
            };
            pressProps.onMouseDown = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (e.button === 0) {
                    // Chrome and Firefox on touch Windows devices require mouse down events
                    // to be canceled in addition to pointer events, or an extra asynchronous
                    // focus event will be fired.
                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                    e.stopPropagation();
                }
            };
            pressProps.onPointerUp = (e)=>{
                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
                if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") return;
                // Only handle left clicks
                // Safari on iOS sometimes fires pointerup events, even
                // when the touch isn't over the target, so double check.
                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);
            };
            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
            // Use pointer move events instead to implement our own hit testing.
            // See https://bugs.webkit.org/show_bug.cgi?id=199803
            let onPointerMove = (e)=>{
                if (e.pointerId !== state.activePointerId) return;
                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target)) {
                    if (!state.isOverTarget && state.pointerType != null) {
                        state.isOverTarget = true;
                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);
                    }
                } else if (state.target && state.isOverTarget && state.pointerType != null) {
                    state.isOverTarget = false;
                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);
                    cancelOnPointerExit(e);
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {
                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);
                    else if (state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);
                    state.isPressed = false;
                    state.isOverTarget = false;
                    state.activePointerId = null;
                    state.pointerType = null;
                    removeAllGlobalListeners();
                    if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
                }
            };
            let onPointerCancel = (e)=>{
                cancel(e);
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
                cancel(e);
            };
        } else {
            pressProps.onMouseDown = (e)=>{
                // Only handle left clicks
                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;
                // Due to browser inconsistencies, especially on mobile browsers, we prevent
                // default on mouse down and handle focusing the pressable element ourselves.
                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();
                if (state.ignoreEmulatedMouseEvents) {
                    e.stopPropagation();
                    return;
                }
                state.isPressed = true;
                state.isOverTarget = true;
                state.target = e.currentTarget;
                state.pointerType = (0, $bx7SL$isVirtualClick)(e.nativeEvent) ? "virtual" : "mouse";
                if (!isDisabled && !preventFocusOnPress) (0, $bx7SL$focusWithoutScrolling)(e.currentTarget);
                let shouldStopPropagation = triggerPressStart(e, state.pointerType);
                if (shouldStopPropagation) e.stopPropagation();
                addGlobalListener((0, $bx7SL$getOwnerDocument)(e.currentTarget), "mouseup", onMouseUp, false);
            };
            pressProps.onMouseEnter = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                let shouldStopPropagation = true;
                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
                    state.isOverTarget = true;
                    shouldStopPropagation = triggerPressStart(e, state.pointerType);
                }
                if (shouldStopPropagation) e.stopPropagation();
            };
            pressProps.onMouseLeave = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                let shouldStopPropagation = true;
                if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
                    state.isOverTarget = false;
                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
                if (shouldStopPropagation) e.stopPropagation();
            };
            pressProps.onMouseUp = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || "mouse");
            };
            let onMouseUp = (e)=>{
                // Only handle left clicks
                if (e.button !== 0) return;
                state.isPressed = false;
                removeAllGlobalListeners();
                if (state.ignoreEmulatedMouseEvents) {
                    state.ignoreEmulatedMouseEvents = false;
                    return;
                }
                if (state.target && $f6c31cce2adf654f$var$isOverTarget(e, state.target) && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);
                else if (state.target && state.isOverTarget && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);
                state.isOverTarget = false;
            };
            pressProps.onTouchStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);
                if (!touch) return;
                state.activePointerId = touch.identifier;
                state.ignoreEmulatedMouseEvents = true;
                state.isOverTarget = true;
                state.isPressed = true;
                state.target = e.currentTarget;
                state.pointerType = "touch";
                // Due to browser inconsistencies, especially on mobile browsers, we prevent default
                // on the emulated mouse event and handle focusing the pressable element ourselves.
                if (!isDisabled && !preventFocusOnPress) (0, $bx7SL$focusWithoutScrolling)(e.currentTarget);
                if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
                let shouldStopPropagation = triggerPressStart(e, state.pointerType);
                if (shouldStopPropagation) e.stopPropagation();
                addGlobalListener((0, $bx7SL$getOwnerWindow)(e.currentTarget), "scroll", onScroll, true);
            };
            pressProps.onTouchMove = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.isPressed) {
                    e.stopPropagation();
                    return;
                }
                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);
                let shouldStopPropagation = true;
                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {
                    if (!state.isOverTarget && state.pointerType != null) {
                        state.isOverTarget = true;
                        shouldStopPropagation = triggerPressStart(e, state.pointerType);
                    }
                } else if (state.isOverTarget && state.pointerType != null) {
                    state.isOverTarget = false;
                    shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);
                    cancelOnPointerExit(e);
                }
                if (shouldStopPropagation) e.stopPropagation();
            };
            pressProps.onTouchEnd = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                if (!state.isPressed) {
                    e.stopPropagation();
                    return;
                }
                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);
                let shouldStopPropagation = true;
                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {
                    triggerPressUp(e, state.pointerType);
                    shouldStopPropagation = triggerPressEnd(e, state.pointerType);
                } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);
                if (shouldStopPropagation) e.stopPropagation();
                state.isPressed = false;
                state.activePointerId = null;
                state.isOverTarget = false;
                state.ignoreEmulatedMouseEvents = true;
                if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
                removeAllGlobalListeners();
            };
            pressProps.onTouchCancel = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                e.stopPropagation();
                if (state.isPressed) cancel(e);
            };
            let onScroll = (e)=>{
                if (state.isPressed && e.target.contains(state.target)) cancel({
                    currentTarget: state.target,
                    shiftKey: false,
                    ctrlKey: false,
                    metaKey: false,
                    altKey: false
                });
            };
            pressProps.onDragStart = (e)=>{
                if (!e.currentTarget.contains(e.target)) return;
                cancel(e);
            };
        }
        return pressProps;
    }, [
        addGlobalListener,
        isDisabled,
        preventFocusOnPress,
        removeAllGlobalListeners,
        allowTextSelectionOnPress,
        cancel,
        cancelOnPointerExit,
        triggerPressEnd,
        triggerPressStart,
        triggerPressUp
    ]);
    // Remove user-select: none in case component unmounts immediately after pressStart
    // eslint-disable-next-line arrow-body-style
    (0, $bx7SL$useEffect)(()=>{
        return ()=>{
            var _ref_current_target;
            if (!allowTextSelectionOnPress) // eslint-disable-next-line react-hooks/exhaustive-deps
            (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_ref_current_target = ref.current.target) !== null && _ref_current_target !== void 0 ? _ref_current_target : undefined);
        };
    }, [
        allowTextSelectionOnPress
    ]);
    return {
        isPressed: isPressedProp || isPressed,
        pressProps: (0, $bx7SL$mergeProps)(domProps, pressProps)
    };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
    return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
    const { key: key, code: code } = event;
    const element = currentTarget;
    const role = element.getAttribute("role");
    // Accessibility for keyboards. Space and Enter only.
    // "Spacebar" is for IE 11
    return (key === "Enter" || key === " " || key === "Spacebar" || code === "Space") && !(element instanceof (0, $bx7SL$getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, $bx7SL$getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key
    !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$getTouchFromEvent(event) {
    const { targetTouches: targetTouches } = event;
    if (targetTouches.length > 0) return targetTouches[0];
    return null;
}
function $f6c31cce2adf654f$var$getTouchById(event, pointerId) {
    const changedTouches = event.changedTouches;
    for(let i = 0; i < changedTouches.length; i++){
        const touch = changedTouches[i];
        if (touch.identifier === pointerId) return touch;
    }
    return null;
}
function $f6c31cce2adf654f$var$createEvent(target, e) {
    return {
        currentTarget: target,
        shiftKey: e.shiftKey,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey
    };
}
function $f6c31cce2adf654f$var$getPointClientRect(point) {
    let offsetX = 0;
    let offsetY = 0;
    if (point.width !== undefined) offsetX = point.width / 2;
    else if (point.radiusX !== undefined) offsetX = point.radiusX;
    if (point.height !== undefined) offsetY = point.height / 2;
    else if (point.radiusY !== undefined) offsetY = point.radiusY;
    return {
        top: point.clientY - offsetY,
        right: point.clientX + offsetX,
        bottom: point.clientY + offsetY,
        left: point.clientX - offsetX
    };
}
function $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {
    // check if they cannot overlap on x axis
    if (a.left > b.right || b.left > a.right) return false;
    // check if they cannot overlap on y axis
    if (a.top > b.bottom || b.top > a.bottom) return false;
    return true;
}
function $f6c31cce2adf654f$var$isOverTarget(point, target) {
    let rect = target.getBoundingClientRect();
    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);
    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);
}
function $f6c31cce2adf654f$var$shouldPreventDefault(target) {
    // We cannot prevent default if the target is a draggable element.
    return !(target instanceof HTMLElement) || !target.hasAttribute("draggable");
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
    if (target instanceof HTMLButtonElement) return target.type !== "submit" && target.type !== "reset";
    if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;
    return true;
}
const $f6c31cce2adf654f$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
    // Only space should toggle checkboxes and radios, not enter.
    return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}



const $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ (/* unused pure expression or super */ null && ((0, $bx7SL$react).forwardRef(({ children: children, ...props }, ref)=>{
    ref = (0, $bx7SL$useObjectRef)(ref);
    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
        ...props,
        ref: ref
    });
    let child = (0, $bx7SL$react).Children.only(children);
    return /*#__PURE__*/ (0, $bx7SL$react).cloneElement(child, // @ts-ignore
    {
        ref: ref,
        ...(0, $bx7SL$mergeProps)(child.props, pressProps)
    });
})));


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ (/* unused pure expression or super */ null && ((0, $bx7SL$react).forwardRef(({ children: children, ...props }, ref)=>{
    let isRegistered = (0, $bx7SL$useRef)(false);
    let prevContext = (0, $bx7SL$useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
    ref = (0, $bx7SL$useObjectRef)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
    let context = (0, $bx7SL$mergeProps)(prevContext || {}, {
        ...props,
        ref: ref,
        register () {
            isRegistered.current = true;
            if (prevContext) prevContext.register();
        }
    });
    (0, $bx7SL$useSyncRef)(prevContext, ref);
    (0, $bx7SL$useEffect)(()=>{
        if (!isRegistered.current) {
            console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
            isRegistered.current = true; // only warn once in strict mode.
        }
    }, []);
    return /*#__PURE__*/ (0, $bx7SL$react).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
})));
function $f1ab8c75478c6f73$export$cf75428e0b9ed1ea({ children: children }) {
    let context = (0, $bx7SL$useMemo)(()=>({
            register: ()=>{}
        }), []);
    return /*#__PURE__*/ (0, $bx7SL$react).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
        value: context
    }, children);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

class $8a9cb279dc87e130$export$905e7fc544a71f36 {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented;
    }
    preventDefault() {
        this.defaultPrevented = true;
        this.nativeEvent.preventDefault();
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation();
        this.isPropagationStopped = ()=>true;
    }
    isPropagationStopped() {
        return false;
    }
    persist() {}
    constructor(type, nativeEvent){
        this.nativeEvent = nativeEvent;
        this.target = nativeEvent.target;
        this.currentTarget = nativeEvent.currentTarget;
        this.relatedTarget = nativeEvent.relatedTarget;
        this.bubbles = nativeEvent.bubbles;
        this.cancelable = nativeEvent.cancelable;
        this.defaultPrevented = nativeEvent.defaultPrevented;
        this.eventPhase = nativeEvent.eventPhase;
        this.isTrusted = nativeEvent.isTrusted;
        this.timeStamp = nativeEvent.timeStamp;
        this.type = type;
    }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
    let stateRef = (0, react.useRef)({
        isFocused: false,
        observer: null
    });
    // Clean up MutationObserver on unmount. See below.
    // eslint-disable-next-line arrow-body-style
    (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(()=>{
        const state = stateRef.current;
        return ()=>{
            if (state.observer) {
                state.observer.disconnect();
                state.observer = null;
            }
        };
    }, []);
    let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e)=>{
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    });
    // This function is called during a React onFocus event.
    return (0, react.useCallback)((e)=>{
        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142
        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a
        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.
        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.
        if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {
            stateRef.current.isFocused = true;
            let target = e.target;
            let onBlurHandler = (e)=>{
                stateRef.current.isFocused = false;
                if (target.disabled) // For backward compatibility, dispatch a (fake) React synthetic event.
                dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e));
                // We no longer need the MutationObserver once the target is blurred.
                if (stateRef.current.observer) {
                    stateRef.current.observer.disconnect();
                    stateRef.current.observer = null;
                }
            };
            target.addEventListener("focusout", onBlurHandler, {
                once: true
            });
            stateRef.current.observer = new MutationObserver(()=>{
                if (stateRef.current.isFocused && target.disabled) {
                    var _stateRef_current_observer;
                    (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
                    let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
                    target.dispatchEvent(new FocusEvent("blur", {
                        relatedTarget: relatedTargetEl
                    }));
                    target.dispatchEvent(new FocusEvent("focusout", {
                        bubbles: true,
                        relatedTarget: relatedTargetEl
                    }));
                }
            });
            stateRef.current.observer.observe(target, {
                attributes: true,
                attributeFilter: [
                    "disabled"
                ]
            });
        }
    }, [
        dispatchBlur
    ]);
}


function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
    let { isDisabled: isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange: onFocusChange } = props;
    const onBlur = (0, react.useCallback)((e)=>{
        if (e.target === e.currentTarget) {
            if (onBlurProp) onBlurProp(e);
            if (onFocusChange) onFocusChange(false);
            return true;
        }
    }, [
        onBlurProp,
        onFocusChange
    ]);
    const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
    const onFocus = (0, react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (e.target === e.currentTarget && document.activeElement === e.target) {
            if (onFocusProp) onFocusProp(e);
            if (onFocusChange) onFocusChange(true);
            onSyntheticFocus(e);
        }
    }, [
        onFocusChange,
        onFocusProp,
        onSyntheticFocus
    ]);
    return {
        focusProps: {
            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,
            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions



let $507fabe10e71c6fb$var$currentModality = null;
let $507fabe10e71c6fb$var$changeHandlers = new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
// Only Tab or Esc keys will make focus visible on text input elements
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {
    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);
}
/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */ function $507fabe10e71c6fb$var$isValidKey(e) {
    // Control and Shift keys trigger when navigating back to the tab with keyboard.
    return !(e.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    if ($507fabe10e71c6fb$var$isValidKey(e)) {
        $507fabe10e71c6fb$var$currentModality = "keyboard";
        $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e);
    }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e) {
    $507fabe10e71c6fb$var$currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e);
    }
}
function $507fabe10e71c6fb$var$handleClickEvent(e) {
    if ((0, $6a7db85432448f7f$export$60278871457622de)(e)) {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        $507fabe10e71c6fb$var$currentModality = "virtual";
    }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e) {
    // Firefox fires two extra focus events when the user first clicks into an iframe:
    // first on the window, then on the document. We ignore these events so they don't
    // cause keyboard focus rings to appear.
    if (e.target === window || e.target === document) return;
    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
        $507fabe10e71c6fb$var$currentModality = "virtual";
        $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e);
    }
    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
    // When the window is blurred, reset state. This is necessary when tabbing out of the window,
    // for example, since a subsequent focus event won't be fired.
    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
    if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element))) return;
    const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
    // Programmatic focus() calls shouldn't affect the current input modality.
    // However, we need to detect other cases when a focus event occurs without
    // a preceding user event (e.g. screen reader focus). Overriding the focus
    // method on HTMLElement.prototype is a bit hacky, but works.
    let focus = windowObject.HTMLElement.prototype.focus;
    windowObject.HTMLElement.prototype.focus = function() {
        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
        focus.apply(this, arguments);
    };
    documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
    // Register focus events on the window so they are sure to happen
    // before React's event listeners (registered on the document).
    windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
    windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
    } else {
        documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
    }
    // Add unmount handler
    windowObject.addEventListener("beforeunload", ()=>{
        $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
    }, {
        once: true
    });
    $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
        focus: focus
    });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener)=>{
    const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
    if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
    if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
    windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
    documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
    documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
    windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
    windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
    if (typeof PointerEvent !== "undefined") {
        documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
    } else {
        documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
        documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
    }
    $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
    const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);
    let loadListener;
    if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    else {
        loadListener = ()=>{
            $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
        };
        documentObject.addEventListener("DOMContentLoaded", loadListener);
    }
    return ()=>$507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
// Server-side rendering does not have the document object defined
// eslint-disable-next-line no-restricted-globals
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
    return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
    return $507fabe10e71c6fb$var$currentModality;
}
function $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {
    $507fabe10e71c6fb$var$currentModality = modality;
    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);
}
function $507fabe10e71c6fb$export$98e20ec92f614cfe() {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
    let [modality, setModality] = (0, $bx7SL$useState)($507fabe10e71c6fb$var$currentModality);
    (0, $bx7SL$useEffect)(()=>{
        let handler = ()=>{
            setModality($507fabe10e71c6fb$var$currentModality);
        };
        $507fabe10e71c6fb$var$changeHandlers.add(handler);
        return ()=>{
            $507fabe10e71c6fb$var$changeHandlers.delete(handler);
        };
    }, []);
    return (0, $bx7SL$useIsSSR)() ? null : modality;
}
const $507fabe10e71c6fb$var$nonTextInputTypes = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
]);
/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {
    var _e_target;
    const IHTMLInputElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;
    const IHTMLTextAreaElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;
    const IHTMLElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;
    const IKeyboardEvent = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;
    isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);
    return !(isTextInput && modality === "keyboard" && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);
}
function $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {
    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;
    let [isFocusVisibleState, setFocusVisible] = (0, $bx7SL$useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());
    $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible)=>{
        setFocusVisible(isFocusVisible);
    }, [
        isTextInput
    ], {
        isTextInput: isTextInput
    });
    return {
        isFocusVisible: isFocusVisibleState
    };
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents();
    (0, react.useEffect)(()=>{
        let handler = (modality, e)=>{
            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;
            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
        };
        $507fabe10e71c6fb$var$changeHandlers.add(handler);
        return ()=>{
            $507fabe10e71c6fb$var$changeHandlers.delete(handler);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
    let { isDisabled: isDisabled, onBlurWithin: onBlurWithin, onFocusWithin: onFocusWithin, onFocusWithinChange: onFocusWithinChange } = props;
    let state = (0, react.useRef)({
        isFocusWithin: false
    });
    let onBlur = (0, react.useCallback)((e)=>{
        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again
        // when moving focus inside the element. Only trigger if the currentTarget doesn't
        // include the relatedTarget (where focus is moving).
        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {
            state.current.isFocusWithin = false;
            if (onBlurWithin) onBlurWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(false);
        }
    }, [
        onBlurWithin,
        onFocusWithinChange,
        state
    ]);
    let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
    let onFocus = (0, react.useCallback)((e)=>{
        // Double check that document.activeElement actually matches e.target in case a previously chained
        // focus handler already moved focus somewhere else.
        if (!state.current.isFocusWithin && document.activeElement === e.target) {
            if (onFocusWithin) onFocusWithin(e);
            if (onFocusWithinChange) onFocusWithinChange(true);
            state.current.isFocusWithin = true;
            onSyntheticFocus(e);
        }
    }, [
        onFocusWithin,
        onFocusWithinChange,
        onSyntheticFocus
    ]);
    if (isDisabled) return {
        focusWithinProps: {
            // These should not have been null, that would conflict in mergeProps
            onFocus: undefined,
            onBlur: undefined
        }
    };
    return {
        focusWithinProps: {
            onFocus: onFocus,
            onBlur: onBlur
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions

// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
    // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
    // the distant future because a user previously touched the element.
    setTimeout(()=>{
        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
    }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e) {
    if (e.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
    if (typeof document === "undefined") return;
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
    $6179b936705e76d3$var$hoverCount++;
    return ()=>{
        $6179b936705e76d3$var$hoverCount--;
        if ($6179b936705e76d3$var$hoverCount > 0) return;
        if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
        else document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
    let { onHoverStart: onHoverStart, onHoverChange: onHoverChange, onHoverEnd: onHoverEnd, isDisabled: isDisabled } = props;
    let [isHovered, setHovered] = (0, $bx7SL$useState)(false);
    let state = (0, $bx7SL$useRef)({
        isHovered: false,
        ignoreEmulatedMouseEvents: false,
        pointerType: "",
        target: null
    }).current;
    (0, $bx7SL$useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
    let { hoverProps: hoverProps, triggerHoverEnd: triggerHoverEnd } = (0, $bx7SL$useMemo)(()=>{
        let triggerHoverStart = (event, pointerType)=>{
            state.pointerType = pointerType;
            if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
            state.isHovered = true;
            let target = event.currentTarget;
            state.target = target;
            if (onHoverStart) onHoverStart({
                type: "hoverstart",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(true);
            setHovered(true);
        };
        let triggerHoverEnd = (event, pointerType)=>{
            state.pointerType = "";
            state.target = null;
            if (pointerType === "touch" || !state.isHovered) return;
            state.isHovered = false;
            let target = event.currentTarget;
            if (onHoverEnd) onHoverEnd({
                type: "hoverend",
                target: target,
                pointerType: pointerType
            });
            if (onHoverChange) onHoverChange(false);
            setHovered(false);
        };
        let hoverProps = {};
        if (typeof PointerEvent !== "undefined") {
            hoverProps.onPointerEnter = (e)=>{
                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") return;
                triggerHoverStart(e, e.pointerType);
            };
            hoverProps.onPointerLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);
            };
        } else {
            hoverProps.onTouchStart = ()=>{
                state.ignoreEmulatedMouseEvents = true;
            };
            hoverProps.onMouseEnter = (e)=>{
                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, "mouse");
                state.ignoreEmulatedMouseEvents = false;
            };
            hoverProps.onMouseLeave = (e)=>{
                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, "mouse");
            };
        }
        return {
            hoverProps: hoverProps,
            triggerHoverEnd: triggerHoverEnd
        };
    }, [
        onHoverStart,
        onHoverChange,
        onHoverEnd,
        isDisabled,
        state
    ]);
    (0, $bx7SL$useEffect)(()=>{
        // Call the triggerHoverEnd as soon as isDisabled changes to true
        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
        if (isDisabled) triggerHoverEnd({
            currentTarget: state.target
        }, state.pointerType);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        isDisabled
    ]);
    return {
        hoverProps: hoverProps,
        isHovered: isHovered
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // Portions of the code in this file are based on code from react.
// Original licensing for the following can be found in the
// NOTICE file in the root directory of this source tree.
// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions


function $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {
    let { ref: ref, onInteractOutside: onInteractOutside, isDisabled: isDisabled, onInteractOutsideStart: onInteractOutsideStart } = props;
    let stateRef = (0, $bx7SL$useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
    });
    let onPointerDown = (0, $bx7SL$useEffectEvent)((e)=>{
        if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {
            if (onInteractOutsideStart) onInteractOutsideStart(e);
            stateRef.current.isPointerDown = true;
        }
    });
    let triggerInteractOutside = (0, $bx7SL$useEffectEvent)((e)=>{
        if (onInteractOutside) onInteractOutside(e);
    });
    (0, $bx7SL$useEffect)(()=>{
        let state = stateRef.current;
        if (isDisabled) return;
        const element = ref.current;
        const documentObject = (0, $bx7SL$getOwnerDocument)(element);
        // Use pointer events if available. Otherwise, fall back to mouse and touch events.
        if (typeof PointerEvent !== "undefined") {
            let onPointerUp = (e)=>{
                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            // changing these to capture phase fixed combobox
            documentObject.addEventListener("pointerdown", onPointerDown, true);
            documentObject.addEventListener("pointerup", onPointerUp, true);
            return ()=>{
                documentObject.removeEventListener("pointerdown", onPointerDown, true);
                documentObject.removeEventListener("pointerup", onPointerUp, true);
            };
        } else {
            let onMouseUp = (e)=>{
                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;
                else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            let onTouchEnd = (e)=>{
                state.ignoreEmulatedMouseEvents = true;
                if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);
                state.isPointerDown = false;
            };
            documentObject.addEventListener("mousedown", onPointerDown, true);
            documentObject.addEventListener("mouseup", onMouseUp, true);
            documentObject.addEventListener("touchstart", onPointerDown, true);
            documentObject.addEventListener("touchend", onTouchEnd, true);
            return ()=>{
                documentObject.removeEventListener("mousedown", onPointerDown, true);
                documentObject.removeEventListener("mouseup", onMouseUp, true);
                documentObject.removeEventListener("touchstart", onPointerDown, true);
                documentObject.removeEventListener("touchend", onTouchEnd, true);
            };
        }
    }, [
        ref,
        isDisabled,
        onPointerDown,
        triggerInteractOutside
    ]);
}
function $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {
    if (event.button > 0) return false;
    if (event.target) {
        // if the event target is no longer in the document, ignore
        const ownerDocument = event.target.ownerDocument;
        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;
        // If the target is within a top layer element (e.g. toasts), ignore.
        if (event.target.closest("[data-react-aria-top-layer]")) return false;
    }
    return ref.current && !ref.current.contains(event.target);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $93925083ecbb358c$export$48d1ea6320830260(handler) {
    if (!handler) return undefined;
    let shouldStopPropagation = true;
    return (e)=>{
        let event = {
            ...e,
            preventDefault () {
                e.preventDefault();
            },
            isDefaultPrevented () {
                return e.isDefaultPrevented();
            },
            stopPropagation () {
                console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
            },
            continuePropagation () {
                shouldStopPropagation = false;
            }
        };
        handler(event);
        if (shouldStopPropagation) e.stopPropagation();
    };
}


function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
    return {
        keyboardProps: props.isDisabled ? {} : {
            onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
            onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $e8a7022cf87cba2a$export$36da96379f79f245(props) {
    let { onMoveStart: onMoveStart, onMove: onMove, onMoveEnd: onMoveEnd } = props;
    let state = (0, $bx7SL$useRef)({
        didMove: false,
        lastPosition: null,
        id: null
    });
    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, $bx7SL$useGlobalListeners)();
    let move = (0, $bx7SL$useEffectEvent)((originalEvent, pointerType, deltaX, deltaY)=>{
        if (deltaX === 0 && deltaY === 0) return;
        if (!state.current.didMove) {
            state.current.didMove = true;
            onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({
                type: "movestart",
                pointerType: pointerType,
                shiftKey: originalEvent.shiftKey,
                metaKey: originalEvent.metaKey,
                ctrlKey: originalEvent.ctrlKey,
                altKey: originalEvent.altKey
            });
        }
        onMove === null || onMove === void 0 ? void 0 : onMove({
            type: "move",
            pointerType: pointerType,
            deltaX: deltaX,
            deltaY: deltaY,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let end = (0, $bx7SL$useEffectEvent)((originalEvent, pointerType)=>{
        (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)();
        if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({
            type: "moveend",
            pointerType: pointerType,
            shiftKey: originalEvent.shiftKey,
            metaKey: originalEvent.metaKey,
            ctrlKey: originalEvent.ctrlKey,
            altKey: originalEvent.altKey
        });
    });
    let moveProps = (0, $bx7SL$useMemo)(()=>{
        let moveProps = {};
        let start = ()=>{
            (0, $14c0b72509d70225$export$16a4697467175487)();
            state.current.didMove = false;
        };
        if (typeof PointerEvent === "undefined") {
            let onMouseMove = (e)=>{
                if (e.button === 0) {
                    var _state_current_lastPosition, _state_current_lastPosition1;
                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
                    move(e, "mouse", e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onMouseUp = (e)=>{
                if (e.button === 0) {
                    end(e, "mouse");
                    removeGlobalListener(window, "mousemove", onMouseMove, false);
                    removeGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            moveProps.onMouseDown = (e)=>{
                if (e.button === 0) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    addGlobalListener(window, "mousemove", onMouseMove, false);
                    addGlobalListener(window, "mouseup", onMouseUp, false);
                }
            };
            let onTouchMove = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);
                if (touch >= 0) {
                    var _state_current_lastPosition, _state_current_lastPosition1;
                    let { pageX: pageX, pageY: pageY } = e.changedTouches[touch];
                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
                    move(e, "touch", pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
                    state.current.lastPosition = {
                        pageX: pageX,
                        pageY: pageY
                    };
                }
            };
            let onTouchEnd = (e)=>{
                let touch = [
                    ...e.changedTouches
                ].findIndex(({ identifier: identifier })=>identifier === state.current.id);
                if (touch >= 0) {
                    end(e, "touch");
                    state.current.id = null;
                    removeGlobalListener(window, "touchmove", onTouchMove);
                    removeGlobalListener(window, "touchend", onTouchEnd);
                    removeGlobalListener(window, "touchcancel", onTouchEnd);
                }
            };
            moveProps.onTouchStart = (e)=>{
                if (e.changedTouches.length === 0 || state.current.id != null) return;
                let { pageX: pageX, pageY: pageY, identifier: identifier } = e.changedTouches[0];
                start();
                e.stopPropagation();
                e.preventDefault();
                state.current.lastPosition = {
                    pageX: pageX,
                    pageY: pageY
                };
                state.current.id = identifier;
                addGlobalListener(window, "touchmove", onTouchMove, false);
                addGlobalListener(window, "touchend", onTouchEnd, false);
                addGlobalListener(window, "touchcancel", onTouchEnd, false);
            };
        } else {
            let onPointerMove = (e)=>{
                if (e.pointerId === state.current.id) {
                    var _state_current_lastPosition, _state_current_lastPosition1;
                    let pointerType = e.pointerType || "mouse";
                    var _state_current_lastPosition_pageX, _state_current_lastPosition_pageY;
                    // Problems with PointerEvent#movementX/movementY:
                    // 1. it is always 0 on macOS Safari.
                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
                    move(e, pointerType, e.pageX - ((_state_current_lastPosition_pageX = (_state_current_lastPosition = state.current.lastPosition) === null || _state_current_lastPosition === void 0 ? void 0 : _state_current_lastPosition.pageX) !== null && _state_current_lastPosition_pageX !== void 0 ? _state_current_lastPosition_pageX : 0), e.pageY - ((_state_current_lastPosition_pageY = (_state_current_lastPosition1 = state.current.lastPosition) === null || _state_current_lastPosition1 === void 0 ? void 0 : _state_current_lastPosition1.pageY) !== null && _state_current_lastPosition_pageY !== void 0 ? _state_current_lastPosition_pageY : 0));
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                }
            };
            let onPointerUp = (e)=>{
                if (e.pointerId === state.current.id) {
                    let pointerType = e.pointerType || "mouse";
                    end(e, pointerType);
                    state.current.id = null;
                    removeGlobalListener(window, "pointermove", onPointerMove, false);
                    removeGlobalListener(window, "pointerup", onPointerUp, false);
                    removeGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
            moveProps.onPointerDown = (e)=>{
                if (e.button === 0 && state.current.id == null) {
                    start();
                    e.stopPropagation();
                    e.preventDefault();
                    state.current.lastPosition = {
                        pageX: e.pageX,
                        pageY: e.pageY
                    };
                    state.current.id = e.pointerId;
                    addGlobalListener(window, "pointermove", onPointerMove, false);
                    addGlobalListener(window, "pointerup", onPointerUp, false);
                    addGlobalListener(window, "pointercancel", onPointerUp, false);
                }
            };
        }
        let triggerKeyboardMove = (e, deltaX, deltaY)=>{
            start();
            move(e, "keyboard", deltaX, deltaY);
            end(e, "keyboard");
        };
        moveProps.onKeyDown = (e)=>{
            switch(e.key){
                case "Left":
                case "ArrowLeft":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, -1, 0);
                    break;
                case "Right":
                case "ArrowRight":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 1, 0);
                    break;
                case "Up":
                case "ArrowUp":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, -1);
                    break;
                case "Down":
                case "ArrowDown":
                    e.preventDefault();
                    e.stopPropagation();
                    triggerKeyboardMove(e, 0, 1);
                    break;
            }
        };
        return moveProps;
    }, [
        state,
        addGlobalListener,
        removeGlobalListener,
        move,
        end
    ]);
    return {
        moveProps: moveProps
    };
}



/*
 * Copyright 2021 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {
    let { onScroll: onScroll, isDisabled: isDisabled } = props;
    let onScrollHandler = (0, $bx7SL$useCallback)((e)=>{
        // If the ctrlKey is pressed, this is a zoom event, do nothing.
        if (e.ctrlKey) return;
        // stop scrolling the page
        e.preventDefault();
        e.stopPropagation();
        if (onScroll) onScroll({
            deltaX: e.deltaX,
            deltaY: e.deltaY
        });
    }, [
        onScroll
    ]);
    (0, $bx7SL$useEvent)(ref, "wheel", isDisabled ? undefined : onScrollHandler);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


const $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;
function $8a26561d2877236e$export$c24ed0104d07eab9(props) {
    let { isDisabled: isDisabled, onLongPressStart: onLongPressStart, onLongPressEnd: onLongPressEnd, onLongPress: onLongPress, threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD, accessibilityDescription: accessibilityDescription } = props;
    const timeRef = (0, $bx7SL$useRef)();
    let { addGlobalListener: addGlobalListener, removeGlobalListener: removeGlobalListener } = (0, $bx7SL$useGlobalListeners)();
    let { pressProps: pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
        isDisabled: isDisabled,
        onPressStart (e) {
            e.continuePropagation();
            if (e.pointerType === "mouse" || e.pointerType === "touch") {
                if (onLongPressStart) onLongPressStart({
                    ...e,
                    type: "longpressstart"
                });
                timeRef.current = setTimeout(()=>{
                    // Prevent other usePress handlers from also handling this event.
                    e.target.dispatchEvent(new PointerEvent("pointercancel", {
                        bubbles: true
                    }));
                    if (onLongPress) onLongPress({
                        ...e,
                        type: "longpress"
                    });
                    timeRef.current = undefined;
                }, threshold);
                // Prevent context menu, which may be opened on long press on touch devices
                if (e.pointerType === "touch") {
                    let onContextMenu = (e)=>{
                        e.preventDefault();
                    };
                    addGlobalListener(e.target, "contextmenu", onContextMenu, {
                        once: true
                    });
                    addGlobalListener(window, "pointerup", ()=>{
                        // If no contextmenu event is fired quickly after pointerup, remove the handler
                        // so future context menu events outside a long press are not prevented.
                        setTimeout(()=>{
                            removeGlobalListener(e.target, "contextmenu", onContextMenu);
                        }, 30);
                    }, {
                        once: true
                    });
                }
            }
        },
        onPressEnd (e) {
            if (timeRef.current) clearTimeout(timeRef.current);
            if (onLongPressEnd && (e.pointerType === "mouse" || e.pointerType === "touch")) onLongPressEnd({
                ...e,
                type: "longpressend"
            });
        }
    });
    let descriptionProps = (0, $bx7SL$useDescription)(onLongPress && !isDisabled ? accessibilityDescription : undefined);
    return {
        longPressProps: (0, $bx7SL$mergeProps)(pressProps, descriptionProps)
    };
}





//# sourceMappingURL=module.js.map

;// CONCATENATED MODULE: ./node_modules/@react-aria/focus/dist/import.mjs





/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $6a99195332edec8b$export$80f3e147d781571c(element) {
    // If the user is interacting with a virtual cursor, e.g. screen reader, then
    // wait until after any animated transition